<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>它夏了夏天</title>
  
  <subtitle>生命中有一种遇见，就让它美如行云流水，然后一生去回味。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tokyle.com/"/>
  <updated>2019-06-14T06:30:36.537Z</updated>
  <id>http://tokyle.com/</id>
  
  <author>
    <name>Kyle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker简单使用（六）</title>
    <link href="http://tokyle.com/2019/06/14/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/14/docker简单使用（六）/</id>
    <published>2019-06-14T06:29:55.000Z</published>
    <updated>2019-06-14T06:30:36.537Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（六）</p><p>数据卷<br><a id="more"></a></p><p>数据卷的使用，类似于linux下的挂载。</p><p>数据卷是一个可供一个或多个容器使用的特殊目录，有以下特性：</p><ul><li>数据卷可以在容器间共享和重用</li><li>对数据卷的修改立刻生效</li><li>对数据卷的更新，不会影响到镜像</li><li>数据卷默认一直存在，即使容器被删除</li></ul><p>创建数据卷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create test_vol</span><br></pre></td></tr></table></figure></p><p>查看数据卷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mynexus]# docker volume ls | grep test</span><br><span class="line">local               test_vol</span><br></pre></td></tr></table></figure></p><p>查看数据卷详细信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mynexus]# docker volume inspect test_vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2019-06-14T14:08:45+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/test_vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;test_vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>启动一个挂载数据卷的容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8077:80 --name web2 --mount source=test_vol,target=/webapp nginx</span><br></pre></td></tr></table></figure></p><p>查看数据卷具体信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker inspect web2</span><br><span class="line"></span><br><span class="line"># 在Mounts节点</span><br><span class="line"> &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;test_vol&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/test_vol/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/webapp&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure></p><p>删除数据卷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm test_vol</span><br></pre></td></tr></table></figure></p><p>删除之前需要将使用这个数据卷的容器关闭，否则报错</p><p>挂载主机目录<br>使用<code>--mount</code>标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8076:80 --name web3 --mount type=bind,source=/home/volumetest,target=/opt/webapp nginx</span><br></pre></td></tr></table></figure><p>本地文件需要存在，否则报错</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（六）&lt;/p&gt;
&lt;p&gt;数据卷&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（五）</title>
    <link href="http://tokyle.com/2019/06/13/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/13/docker简单使用（五）/</id>
    <published>2019-06-14T00:40:45.000Z</published>
    <updated>2019-06-14T05:46:56.644Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（五）</p><p>仓库<br><a id="more"></a></p><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>类似<code>github</code>，docker也有<code>Docker Hub</code>注册了账号之后，也就可以进行镜像的<br>拉取：<code>docker pull nginx</code><br>上传：<code>docker push nginx</code><br>上传到Ddocker Hub时候，可以给自己的镜像一个标注，自己的docker hub id加上镜像<code>kyle/nginx</code>这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:v3 kyle/nginx:v3</span><br><span class="line"></span><br><span class="line">docker push kyle/nginx:v3</span><br></pre></td></tr></table></figure></p><h3 id="私仓"><a href="#私仓" class="headerlink" title="私仓"></a>私仓</h3><p>个人、公司级别的镜像，可能不适合上传到公有仓库，类似gitlab一样，可以在本地创建私有仓库</p><h4 id="创建私仓"><a href="#创建私仓" class="headerlink" title="创建私仓"></a>创建私仓</h4><p>官方提供的工具：<code>docker-registry</code><br>运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8090:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure></p><p>进入容器：<code>docker exec -it registry sh</code><br>仓库默认会创建到容器的该路径：<code>/var/lib/registry</code></p><p>或者通过<code>-v</code>更改路径，将镜像文件放在本地指定路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8081:5000 -v /home/images:/var/lib/registry  --restart=always --name registry2 registry</span><br></pre></td></tr></table></figure></p><p>将本地<code>/home/images</code>作为镜像上传路径，替换默认路径（该文件不存在，会自动创建）</p><h4 id="操作镜像"><a href="#操作镜像" class="headerlink" title="操作镜像"></a>操作镜像</h4><p>先打tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu:16.04 192.168.0.97:8081/ubuntu:16.04</span><br></pre></td></tr></table></figure></p><p>再推送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost images]# docker push 192.168.0.97:8081/ubuntu:16.04</span><br><span class="line">The push refers to repository [192.168.0.97:8081/ubuntu]</span><br><span class="line">Get https://192.168.0.97:8081/v2/: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure></p><p>嗯。失败了、、、因为Docker默认不允许非<code>HTTPS</code>方式推送镜像，解决办法，要么是该配置，要么配置https</p><h4 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h4><p>适用于：<code>ubuntu 16.04+</code>、<code>Debian 8+</code>、<code>centos 7</code><br>修改<code>/etc/docker/daemon.json</code>（不存在就新建）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;:[</span><br><span class="line">        &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;insecure-registries&quot;:[</span><br><span class="line">        &quot;192.168.0.97:8081&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重启docker:<code>systemctl restart docker</code><br>重新push：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost images]# docker push 192.168.0.97:8081/ubuntu:16.04</span><br><span class="line">The push refers to repository [192.168.0.97:8081/ubuntu]</span><br><span class="line">4c54072a5034: Pushed </span><br><span class="line">49652298c779: Pushed </span><br><span class="line">e15278fcccca: Pushed </span><br><span class="line">739482a9723d: Pushed </span><br><span class="line">16.04: digest: sha256:08f4295167241c59fc4a24f18816618ff8f959756fb4b236e880a3b7f45f0ba0 size: 1150</span><br></pre></td></tr></table></figure></p><p>看到成功了。。。<br>在本地<code>/home/images</code>下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# tree images/</span><br><span class="line">images/</span><br><span class="line">└── docker</span><br><span class="line">    └── registry</span><br><span class="line">        └── v2</span><br><span class="line">            ├── blobs</span><br><span class="line">            │   └── sha256</span><br><span class="line">            │       ├── 08</span><br><span class="line">            │       │   └── 08f4295167241c59fc4a24f18816618ff8f959756fb4b236e880a3b7f45f0ba0</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── 2a</span><br><span class="line">            │       │   └── 2a697363a8709093834e852b26bedb1d85b316c613120720fea9524f0e98e4a2</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── 59</span><br><span class="line">            │       │   └── 59856638ac9f32d4caa0f5761b2597fe251642786fdfe1b917ddbb074b890c29</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── 6f</span><br><span class="line">            │       │   └── 6f317d6d954b9a59c54b2cb09e1f30cd3e872796e431cd2ceac5ed570beb2939</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── 9f</span><br><span class="line">            │       │   └── 9ff7e2e5f967fb9c4e8099e63508ab0dddebe3f820d08ca7fd568431b0d10c0e</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       └── a9</span><br><span class="line">            │           └── a9dde5e2a643eca8fde0eed52f4aed31f3ecd9c1b2f24d5e3729cd8d2ae68177</span><br><span class="line">            │               └── data</span><br><span class="line">            └── repositories</span><br><span class="line">                └── ubuntu</span><br><span class="line">                    ├── _layers</span><br><span class="line">                    │   └── sha256</span><br><span class="line">                    │       ├── 2a697363a8709093834e852b26bedb1d85b316c613120720fea9524f0e98e4a2</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       ├── 59856638ac9f32d4caa0f5761b2597fe251642786fdfe1b917ddbb074b890c29</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       ├── 6f317d6d954b9a59c54b2cb09e1f30cd3e872796e431cd2ceac5ed570beb2939</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       ├── 9ff7e2e5f967fb9c4e8099e63508ab0dddebe3f820d08ca7fd568431b0d10c0e</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       └── a9dde5e2a643eca8fde0eed52f4aed31f3ecd9c1b2f24d5e3729cd8d2ae68177</span><br><span class="line">                    │           └── link</span><br><span class="line">                    ├── _manifests</span><br><span class="line">                    │   ├── revisions</span><br><span class="line">                    │   │   └── sha256</span><br><span class="line">                    │   │       └── 08f4295167241c59fc4a24f18816618ff8f959756fb4b236e880a3b7f45f0ba0</span><br><span class="line">                    │   │           └── link</span><br><span class="line">                    │   └── tags</span><br><span class="line">                    │       └── 16.04</span><br><span class="line">                    │           ├── current</span><br><span class="line">                    │           │   └── link</span><br><span class="line">                    │           └── index</span><br><span class="line">                    │               └── sha256</span><br><span class="line">                    │                   └── 08f4295167241c59fc4a24f18816618ff8f959756fb4b236e880a3b7f45f0ba0</span><br><span class="line">                    │                       └── link</span><br><span class="line">                    └── _uploads</span><br></pre></td></tr></table></figure></p><p>使用curl获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# curl 192.168.0.97:8081/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Docker-Compose建私仓"><a href="#Docker-Compose建私仓" class="headerlink" title="Docker Compose建私仓"></a>Docker Compose建私仓</h3><p>参照《docker practice》建私仓，配置全新啊认证，TLS<br>使用openssl自动签发站点SSL证书</p><p>新建一个空白文件夹，进入文件夹，开始操作<br><code>/etc/docker/registry</code></p><h4 id="创建CA私钥"><a href="#创建CA私钥" class="headerlink" title="创建CA私钥"></a>创建CA私钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out &quot;root-ca.key&quot; 4096</span><br></pre></td></tr></table></figure><h4 id="创建CA根证书请求文件"><a href="#创建CA根证书请求文件" class="headerlink" title="创建CA根证书请求文件"></a>创建CA根证书请求文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key &quot;root-ca.key&quot; -out &quot;root-ca.csr&quot; -sha256 \</span><br><span class="line">&gt; -subj &apos;/C=CN/ST=Jiangsu/L=Suzhou/O=Company Xaa/CN=Company Xaa Docker Registry CA&apos;</span><br></pre></td></tr></table></figure><p>其中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/C表示国家，如CN；/ST表示省，如Jiangsu；/L表示城市或地区，如Suzhou；/O表示组织名，如公司名；/CN表示组织通用名称，如公司对外的名称，XXX company</span><br></pre></td></tr></table></figure></p><h4 id="配置CA根证书"><a href="#配置CA根证书" class="headerlink" title="配置CA根证书"></a>配置CA根证书</h4><p><code>vim root-ca.cnf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root_ca]</span><br><span class="line">basicConstraints = critical,CA:TRUE,pathlen:1</span><br><span class="line">keyUsage = critical, nonRepudiation, cRLSign, keyCertSign</span><br><span class="line">subjectKeyIdentifier=hash</span><br></pre></td></tr></table></figure></p><h4 id="签发根证书"><a href="#签发根证书" class="headerlink" title="签发根证书"></a>签发根证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in &quot;root-ca.csr&quot; \</span><br><span class="line">&gt; -signkey &quot;root-ca.key&quot; -sha256 -out &quot;root-ca.crt&quot; \</span><br><span class="line">&gt; -extfile &quot;root-ca.cnf&quot; -extensions \</span><br><span class="line">&gt; root_ca</span><br></pre></td></tr></table></figure><h4 id="生成站点SSL私钥"><a href="#生成站点SSL私钥" class="headerlink" title="生成站点SSL私钥"></a>生成站点SSL私钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out &quot;tokyle.com.key&quot; 4096</span><br></pre></td></tr></table></figure><h4 id="使用私钥生成证书请求文件"><a href="#使用私钥生成证书请求文件" class="headerlink" title="使用私钥生成证书请求文件"></a>使用私钥生成证书请求文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key &quot;tokyle.com.key&quot; -out &quot;site.csr&quot; -sha256 \</span><br><span class="line">&gt; -subj &apos;/C=CN/ST=Jiangsu/L=Suzhou/O=Company Xaa/CN=tokyle.com&apos;</span><br></pre></td></tr></table></figure><h4 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h4><p>新建<code>site.cnf</code>文件 <code>vim site.cnf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints = critical,CA:FALSE</span><br><span class="line">extendedKeyUsage=serverAuth</span><br><span class="line">keyUsage = critical, digitalSignature, keyEncipherment</span><br><span class="line">subjectAltName = DNS:tokyle.com, IP:127.0.0.1</span><br><span class="line">subjectKeyIdentifier=hash</span><br></pre></td></tr></table></figure></p><h4 id="签署站点SSL证书"><a href="#签署站点SSL证书" class="headerlink" title="签署站点SSL证书"></a>签署站点SSL证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 750 -in &quot;site.csr&quot; -sha256 \</span><br><span class="line">&gt; -CA &quot;root-ca.crt&quot; -CAkey &quot;root-ca.key&quot; -CAcreateserial \</span><br><span class="line">&gt; -out &quot;tokyle.com.crt&quot; -extfile &quot;site.cnf&quot; -extensions server</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost registry]# ll</span><br><span class="line">总用量 36</span><br><span class="line">-rw-r--r-- 1 root root  140 6月  13 17:03 root-ca.cnf</span><br><span class="line">-rw-r--r-- 1 root root 2021 6月  13 17:05 root-ca.crt</span><br><span class="line">-rw-r--r-- 1 root root 1708 6月  13 16:49 root-ca.csr</span><br><span class="line">-rw-r--r-- 1 root root 3247 6月  13 16:45 root-ca.key</span><br><span class="line">-rw-r--r-- 1 root root   17 6月  13 17:18 root-ca.srl</span><br><span class="line">-rw-r--r-- 1 root root  237 6月  13 17:14 site.cnf</span><br><span class="line">-rw-r--r-- 1 root root 1679 6月  13 17:10 site.csr</span><br><span class="line">-rw-r--r-- 1 root root 2098 6月  13 17:18 tokyle.com.crt</span><br><span class="line">-rw-r--r-- 1 root root 3243 6月  13 17:08 tokyle.com.key</span><br></pre></td></tr></table></figure><p>这样，就已经拥有了<code>tokyle.com</code>的网站SSL私钥<code>tokyle.com.key</code>和SSL证书<code>tokyle.com.crt</code>及CA根证书<code>root-ca.crt</code></p><p>新建ssl文件夹，将<code>tokyle.com.key</code>、<code>tokyle.com.crt</code>、<code>root-ca.crt</code>拷入，其他删除。</p><h4 id="配置私有仓库"><a href="#配置私有仓库" class="headerlink" title="配置私有仓库"></a>配置私有仓库</h4><p>私仓默认配置文件位于:<code>/etc/docker/registry/config.yml</code>，先本地编辑config.yml再挂在到容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">version: 0.1</span><br><span class="line">log:</span><br><span class="line">  accesslog:</span><br><span class="line">    disabled: true</span><br><span class="line">  level: debug</span><br><span class="line">  formatter: text</span><br><span class="line">  fields:</span><br><span class="line">    service: registry</span><br><span class="line">    environment: staging</span><br><span class="line">storage:</span><br><span class="line">  delete:</span><br><span class="line">    enabled: true</span><br><span class="line">  cache:</span><br><span class="line">    blobdescriptor: inmemory</span><br><span class="line">  filesystem:</span><br><span class="line">    rootdirectory: /var/lib/registry</span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    realm: basic-realm</span><br><span class="line">    path: /etc/docker/registry/auth/nginx.htpasswd</span><br><span class="line">http:</span><br><span class="line">  addr: :443</span><br><span class="line">  host: https://tokyle.com</span><br><span class="line">  headers:</span><br><span class="line">    X-Content-Type-Options: [nosniff]</span><br><span class="line">  http2:</span><br><span class="line">    disabled: false</span><br><span class="line">  tls:</span><br><span class="line">    certificate: /etc/docker/registry/ssl/tokyle.com.crt</span><br><span class="line">    key: /etc/docker/registry/ssl/tokyle.com.key</span><br><span class="line">health:</span><br><span class="line">  storagedriver:</span><br><span class="line">    enabled: true</span><br><span class="line">    interval: 10s</span><br><span class="line">threshold: 3</span><br></pre></td></tr></table></figure></p><h4 id="生成http认证文件"><a href="#生成http认证文件" class="headerlink" title="生成http认证文件"></a>生成http认证文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir auth</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">    --entrypoint htpasswd \</span><br><span class="line">    registry \</span><br><span class="line">    -Bbn username pwd &gt; auth/nginx.htpasswd</span><br></pre></td></tr></table></figure><p>用户名密码用自己的</p><h4 id="编辑docker-compose-yml"><a href="#编辑docker-compose-yml" class="headerlink" title="编辑docker-compose.yml"></a>编辑docker-compose.yml</h4><p><code>vim docker-compose.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  registry:</span><br><span class="line">    image: registry</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;443:443&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./:/etc/docker/registry</span><br><span class="line">      - registry-data:/var/lib/registry</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  registry-data:</span><br></pre></td></tr></table></figure></p><h4 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h4><p><code>vim /etc/hosts</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 tokyle.com</span><br></pre></td></tr></table></figure></p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>安装docker-compose<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U docker-compose</span><br></pre></td></tr></table></figure></p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p><p>由于自行签发的 CA 根证书不被系统信任，所以我们需要将 CA 根证书 ssl/root-ca.crt 移入/etc/docker/certs.d/docker.domain.com 文件夹中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker/certs.d/tokyle.com</span><br><span class="line">cp ssl/root-ca.crt /etc/docker/certs.d/tokyle.com/ca.crt</span><br></pre></td></tr></table></figure></p><h4 id="私仓操作"><a href="#私仓操作" class="headerlink" title="私仓操作"></a>私仓操作</h4><p>登录私仓：<code>docker login tokyle.com</code><br>就可以进行镜像推送、拉取了（需要登录进去）</p><h3 id="参考docker-practice"><a href="#参考docker-practice" class="headerlink" title="参考docker practice"></a>参考docker practice</h3><blockquote><p><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry_auth.html" target="_blank" rel="noopener">私仓高级配置</a></p></blockquote><h3 id="使用Nexus建私仓"><a href="#使用Nexus建私仓" class="headerlink" title="使用Nexus建私仓"></a>使用Nexus建私仓</h3><p>docker官方的registry建立的仓库，有些镜像删除后不会回收空间，必须命令去释放空间，重启Registry程序。当前比较常见的做法是使用<code>Nexus</code>来管理<code>Docker</code>、<code>Yum</code>、<code>PyPI</code>等</p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nexus3 --restart=always \</span><br><span class="line">    -p 8081:8081 sonatype/nexus3</span><br></pre></td></tr></table></figure></p><p>需要等一段时间，可以进容器<code>docker exec -it nexus3 bash</code>，看日志<code>/nexus-data/log/nexus.log</code>看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Started Sonatype Nexus OSS 3.16.2-01</span><br></pre></td></tr></table></figure></p><p>就是起好了，可以通过<a href="http://IP:8088访问web页面。默认账密：`admin/admin123`" target="_blank" rel="noopener">http://IP:8088访问web页面。默认账密：`admin/admin123`</a></p><h4 id="Nexus配置"><a href="#Nexus配置" class="headerlink" title="Nexus配置"></a>Nexus配置</h4><h5 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h5><p>进入nexus界面之后，创建仓库：<br>点击设置（齿轮）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Repository-&gt;Repositories 点击右边菜单 Create repository 选择 docker (hosted)</span><br></pre></td></tr></table></figure></p><ul><li>Name: 仓库的名称，如dockertest</li><li>HTTP: 仓库单独的访问端口，如8082</li><li>Enable Docker V1 API: 如果需要同时支持 V1 版本请勾选此项</li><li>Hosted -&gt; Deployment pollcy: 请选择 Allow redeploy 否则无法上传 Docker 镜像</li></ul><h5 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h5><p>菜单 Security-&gt;Realms 把 Docker Bearer Token Realm 移到右边的框中保存。</p><p>添加用户规则：菜单 Security-&gt;Roles-&gt;Create role 在 Privlleges 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p><p>添加用户：菜单 Security-&gt;Users-&gt;Create local user 在 Roles 选项中选中刚才创建的规则移动到右边的窗口保存。</p><h4 id="操作Nexus私仓"><a href="#操作Nexus私仓" class="headerlink" title="操作Nexus私仓"></a>操作Nexus私仓</h4><p>和之前官方私仓一样，不是https访问，需要在<code>/etc/docker/daemon.json</code>中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   &quot;insecure-registries&quot;:[&quot;http://192.168.0.97:8082&quot;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重启docker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>登录：<code>docker login 192.168.0.97:8082</code>，输入创建的用户名和密码，完成登录。</p><h5 id="Error-response-from-daemon-Get-http-192-168-0-97-8082-v2-dial-tcp-192-168-0-97-8082-connect-connection-refused"><a href="#Error-response-from-daemon-Get-http-192-168-0-97-8082-v2-dial-tcp-192-168-0-97-8082-connect-connection-refused" class="headerlink" title="Error response from daemon: Get http://192.168.0.97:8082/v2/: dial tcp 192.168.0.97:8082: connect: connection refused"></a>Error response from daemon: Get <a href="http://192.168.0.97:8082/v2/" target="_blank" rel="noopener">http://192.168.0.97:8082/v2/</a>: dial tcp 192.168.0.97:8082: connect: connection refused</h5><p><code>docker login 192.168.0.97:8082</code>时候，登录不进去，确认用户名密码正确，确认有添加到daemon.json中。<br>这个问题折腾我一个上午，想来想去，配置的没有问题，然后翻Stack Overflow时候看到差不多的问题，才知道什么鬼。。</p><p>首先，碰到这个，用curl验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http://192.168.0.97:8082/v2/_catalog&quot;</span><br><span class="line"></span><br><span class="line">curl: (7) Failed connect to 192.168.0.97:8082; Connection refused</span><br></pre></td></tr></table></figure></p><p>证明这个端口应该压根就没起来，然后往回翻，看看起nexus3这个容器的命令，发现是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nexus3 --restart=always \</span><br><span class="line">    -p 8081:8081 sonatype/nexus3</span><br></pre></td></tr></table></figure></p><p>只给nexus3分配了8081端口，没有其他端口暴露出来，即使在页面设置了8082端口，因为8082是在容器内部，没有暴露出来，所以在服务器上，根本就连不到192.168.0.97的8082端口，解决办法就是暴露出8082端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8081:8081 -p 8082:8082 -p 8083:8083 --restart=always --name nexus3 sonatype/nexus3</span><br></pre></td></tr></table></figure></p><p>然后再进入nexus页面重新设置，这样，就可以登陆了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost log]# docker login 192.168.0.97:8082</span><br><span class="line">Username: admin</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure></p><h5 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h5><p>首先登录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker login 192.168.0.97:8082</span><br><span class="line">Username: kyle</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure></p><p>镜像操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:v2 192.168.0.97:8082/nginx:v2</span><br><span class="line"></span><br><span class="line">[root@localhost docker]# docker push 192.168.0.97:8082/nginx:v2</span><br><span class="line">The push refers to repository [192.168.0.97:8082/nginx]</span><br><span class="line">7df9ba6b1822: Pushed </span><br><span class="line">ea06a73e56fc: Pushed </span><br><span class="line">22c458a3ff08: Pushed </span><br><span class="line">6270adb5794c: Pushed </span><br><span class="line">v2: digest: sha256:619a4fd83aef966bbee5677f0a2c169ae990cf83b9183aed0969c991b04e23dc size: 1155</span><br></pre></td></tr></table></figure></p><p>可以到nexus界面的Docker栏看到推送上去的镜像。</p><p>删除本地镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker image ls</span><br><span class="line">REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.0.97:8082/nginx   v2                  f531cfc896d6        3 days ago          109MB</span><br><span class="line">nginx                     v2                  f531cfc896d6        3 days ago          109MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost docker]# docker rmi 192.168.0.97:8082/nginx:v2</span><br><span class="line">Untagged: 192.168.0.97:8082/nginx:v2</span><br><span class="line">Untagged: 192.168.0.97:8082/nginx@sha256:619a4fd83aef966bbee5677f0a2c169ae990cf83b9183aed0969c991b04e23dc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost docker]# docker image ls</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                 v2                  f531cfc896d6        3 days ago          109MB</span><br></pre></td></tr></table></figure></p><p>从nexus私仓拉取镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker pull 192.168.0.97:8082/nginx:v2</span><br><span class="line">v2: Pulling from nginx</span><br><span class="line">Digest: sha256:619a4fd83aef966bbee5677f0a2c169ae990cf83b9183aed0969c991b04e23dc</span><br><span class="line">Status: Downloaded newer image for 192.168.0.97:8082/nginx:v2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost docker]# docker image ls</span><br><span class="line">REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.0.97:8082/nginx   v2                  f531cfc896d6        3 days ago          109MB</span><br><span class="line">nginx                     v2                  f531cfc896d6        3 days ago          109MB</span><br></pre></td></tr></table></figure></p><p>退出私仓：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker logout 192.168.0.97:8082</span><br><span class="line">Removing login credentials for 192.168.0.97:8082</span><br></pre></td></tr></table></figure></p><p>然后，可以对自己的私仓加上个<strong>s</strong>，更安全一点，这个，教程一堆</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（五）&lt;/p&gt;
&lt;p&gt;仓库&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（四）</title>
    <link href="http://tokyle.com/2019/06/13/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/13/docker简单使用（四）/</id>
    <published>2019-06-13T06:48:29.000Z</published>
    <updated>2019-06-13T06:49:04.406Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（四）</p><p>Docker容器操作<br><a id="more"></a></p><h3 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h3><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>构建完镜像之后，启动容器<br>例如：<code>docker run -it ubintu:16.04 bash</code>，启ubuntu，并开启交互终端</p><h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><p>容器已经关闭，可以使用<code>docker container start containerID(或name)</code>启动<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser2]# docker run --name web1 -d -p 8088:80 nginx</span><br><span class="line">73a5c1a3ac2300f6e2317ae39c9571b84be07e44beb92fcb98b41ee68aa6672a</span><br><span class="line"></span><br><span class="line">[root@localhost myuser2]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                          PORTS                  NAMES</span><br><span class="line">73a5c1a3ac23        nginx               &quot;nginx -g &apos;daemon of…&quot;   14 seconds ago      Up 4 seconds                    0.0.0.0:8088-&gt;80/tcp   web1</span><br></pre></td></tr></table></figure></p><p>关掉容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser2]# docker kill 73a5c1a3ac23</span><br><span class="line">73a5c1a3ac23</span><br><span class="line"></span><br><span class="line">[root@localhost myuser2]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                        PORTS               NAMES</span><br><span class="line">73a5c1a3ac23        nginx               &quot;nginx -g &apos;daemon of…&quot;   About a minute ago   Exited (137) 14 seconds ago                       web1</span><br></pre></td></tr></table></figure></p><p>重新启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser2]# docker container start 73a5c1a3ac23</span><br><span class="line">73a5c1a3ac23</span><br><span class="line"></span><br><span class="line">[root@localhost myuser2]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                     PORTS                  NAMES</span><br><span class="line">73a5c1a3ac23        nginx               &quot;nginx -g &apos;daemon of…&quot;   About a minute ago   Up 9 seconds               0.0.0.0:8088-&gt;80/tcp   web1</span><br></pre></td></tr></table></figure></p><p><code>docker container start -i  5879098886bf</code>以交互模式重启</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>推荐<code>docker exec</code>，交互模式：<code>docker exec -it container</code></p><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>可以<code>docker container stop containerid(name)</code><br>也可以暴力的<code>dokcer kill containerid</code></p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p><code>docker rm containerid</code></p><p>删除镜像：<code>docker rmi imageid</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（四）&lt;/p&gt;
&lt;p&gt;Docker容器操作&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（三）</title>
    <link href="http://tokyle.com/2019/06/12/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/12/docker简单使用（三）/</id>
    <published>2019-06-13T02:43:54.000Z</published>
    <updated>2019-06-13T02:44:32.823Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（三）</p><p>Dockerfile简介二<br><a id="more"></a><br>简单介绍Dockerfile的一些指令</p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>COPY，复制文件指令，格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;源路径&gt;  &lt;目标路径&gt;</span><br></pre></td></tr></table></figure></p><p>另一种格式类似函数调用：<code>COPY [&quot;&lt;源路径&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p><p>COPY指令作用是从构建上下文目录中<code>&lt;源路径&gt;</code>（相对于上下文的路径）下的文件复制到镜像中的<code>目标路径</code></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY test1.txt /usr/local/test/</span><br></pre></td></tr></table></figure></p><p>将当前上下文目录下的test1.txt复制到新镜像的/usr/local/test/文件夹下<br>&lt;目标路径&gt;可以是容器内的绝对路径，也可以是相对于<code>WOKDIR</code>的相对路径</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>不实用的命令，有拷贝的功能，同时，可以拷贝url，但是使用ADD url时，docker会先将url的文件下载下来，如果是个压缩包，还需要自己添加一层RUN进行解压，剔除不需要的文件，再复制；所以不如直接RUN wget，然后解压缩，剔除文件复制</p><p>ADD命令在有一种情况下很有用，源路径是一个gzip，bzip2以及xz的压缩包，ADD会自动解压压缩包到目标路径。</p><p>在《docker practice》中指出，<strong>在COPY和ADD指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用COPY指令，仅在需要自动解压缩场合使用ADD</strong></p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>首先要理解，容器是进程，不是虚拟机，在正常linux中，运行进程一般都伴随有启动参数，类似的，容器也有，CMD就是用于指定默认的容器主进程的启动命令的</p><p>格式：<br><code>shell</code>格式：<code>CMD &lt;命令&gt;</code><br><code>exec</code>格式：<code>CMD [&quot;可执行文件&quot;， &quot;参数1&quot;, &quot;参数2&quot;...]</code></p><p>在运行时，可以使用CMD来指定新的命令来替代镜像中设置的默认命令，例如，ubuntu镜像的默认CMD是<code>/bin/bash</code>，如果我们直接<code>docker run -it ubuntu:16.04</code>会直接进入<code>bash</code>；也可以指定别的命令，例如输出系统版本：<code>docker run -it ubuntu:16.04 cat /etc/os-rlease</code></p><p>在指令格式上，推荐使用<code>CMD [&quot;可执行文件&quot;， &quot;参数1&quot;, &quot;参数2&quot;...]</code>，这类格式会被解析成JSON，因此一定要是用双引号<code>&quot;</code><br>如果使用shell格式，例如<code>CMD echo $JAVA_HOME</code>在实际执行中会变更为<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $JAVA_HOME&quot;]</code>，实际会被包装成<code>sh -c</code>的参数形式。（这也是shell中可以直接使用环境变量的原因）</p><p>前面说过，容器其实就是进程，本身就是进程，所以就不存在什么进程里面的程序有后台执行的说法了，容器中的应用，都是在前台执行的，不存在systemctl这样的操作，不会像虚拟机中有<code>systemctl start mysqld</code>这样的操作，如果使用CMD写成这样的：<code>CMD systemctl start nginx</code>，会发现容器执行后立刻退出。</p><p>这是因为，docker容器，默认会把容器内部第一个进程，也就是pid=1的程序作为docker容器正在运行的依据，如果容器中pid=1的程序挂了，那docker容器就会直接退出；在执行<code>CMD systemctl start nginx</code>时候，实际执行的是<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;systemctl start nginx&quot;]</code>，起初pid=1的程序是bash，但是后面接上了systemctl start nginx（后台守护模式daemon启动nginx），使得systemctl start nginx进程启动后，sh也结束了（CMD会更改默认命令），当pid=1的程序结束，容器就退出了。所以只要运行程序时候，在非守护模式下，容器就不会退出，因此，容器内启动nginx可以：<code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off&quot;]</code></p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>和CMD类似，不同的是，CMD会被docker run覆盖，而ENTERPOINT不会，例如以下一个最简单的镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">CMD [&quot;/bin/echo&quot;, &quot;test&quot;]</span><br></pre></td></tr></table></figure></p><p>构建镜像：<code>docker build -t echotest .</code>，<br>运行容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myip]# docker run echotest </span><br><span class="line">test</span><br></pre></td></tr></table></figure></p><p>但是既然容器是进程，那如果像其他进程一样，加参数，效果如何：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myip]# docker run echotest -i</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;exec: \&quot;-i\&quot;: executable file not found in $PATH&quot;: unknown.</span><br><span class="line">ERRO[0001] error waiting for container: context canceled</span><br></pre></td></tr></table></figure></p><p>直接就报错了。。这是因为跟在镜像名之后的执行，会替换调CMD的默认值，但是-i又不是个指令，所以就报错了。</p><p>ENTRYPOINT在这点上就可以做到带参数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;test&quot;]</span><br></pre></td></tr></table></figure></p><p>构建：<code>docker build -t echotest2 .</code>，运行容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost echotest]# docker run echotest2 -i</span><br><span class="line">test -i</span><br></pre></td></tr></table></figure></p><p>可以看到，-i可以带进去。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>顾名思义，设置环境变量<code>ENV JAVA_VERSION 1.8.0_191</code></p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>和ENV类似，都是设置环境变量。区别在于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The ARG instruction defines a variable that users can pass at build-time to the builder with the docker build command using the --build-arg &lt;varname&gt;=&lt;value&gt; flag.ARG指令定义了用户可以在编译时或者运行时传递的变量，如使用如下命令：--build-arg &lt;varname&gt;=&lt;value&gt;</span><br><span class="line"></span><br><span class="line">The ENV instruction sets the environment variable &lt;key&gt; to the value &lt;value&gt;. The environment variables set using ENV will persist when a container is run from the resulting image.ENV指令是在dockerfile里面设置环境变量，不能在编译时或运行时传递。</span><br></pre></td></tr></table></figure></p><p>例如，在Dockerfile中定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG a_key1</span><br><span class="line">ARG a_key2 = a_value2</span><br></pre></td></tr></table></figure></p><p>ARG指令定义的参数，在docker build命令中可以通过–build-arg a_key1=avalue1来覆盖</p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>创建一个可以从本地主机或其他容器挂载的挂在点，格式：<code>VOLUME [&quot;/data&quot;]</code><br>对于数据库类需要保存动态数据的应用，数据库文件应该保存在卷（volume）。为了防止运行时用户忘记将动态文件所保存的目录挂在为卷，在写Dockerfile时，就可以事先指定某些目录挂载为匿名卷，这样运行时如果用户不挂载，应用也可以正常运行，不会向容器存储层写大量数据</p><p><code>VOLUME [&quot;/data&quot;]</code>,这里的<code>/data</code>目录就会在运行时自动挂载为匿名卷，任何向/data中写入的信息都不会记录进容器存储层。当然，docker run时候也可以覆盖这个设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data/tmp mysql</span><br></pre></td></tr></table></figure></p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>声明端口，格式：<code>EXPOSE &lt;port1&gt; &lt;port2&gt;</code><br>用来指定要映射出去的端口，例如，容器内部开启了nginx,就需要将80（或者指定的端口）暴露出去：<code>EXPOSE 80</code>。这个需要-P（大写）配合，启动容器是，加上-P，让它自动分配。如果想指定具体端口，使用-p(小写)</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定工作目录，格式：<code>WORKDIR &lt;工作目录路径&gt;</code>，作用就是为后续的<code>RUN</code>、<code>COPY</code>等指定工作目录<br>在Dockerfile中，每个RUN，都会启一个容器，都是一个<code>启动容器</code>、<code>执行命令</code>、<code>提交存储层文件变更</code>的操作。<br>示例，如果Dockerfile这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN cd /home \</span><br><span class="line">    &amp;&amp; mkdir myapp \</span><br><span class="line">    &amp;&amp; cd myapp</span><br><span class="line">RUN echo &quot;docker practice&quot; &gt; test1.txt</span><br></pre></td></tr></table></figure></p><p>然后构建镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myworkfile]# docker build -t workfile1 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/3 : FROM ubuntu:16.04</span><br><span class="line"> ---&gt; 2a697363a870</span><br><span class="line">Step 2/3 : RUN cd /home     &amp;&amp; mkdir myapp     &amp;&amp; cd myapp</span><br><span class="line"> ---&gt; Running in a33b48c39597</span><br><span class="line">Removing intermediate container a33b48c39597</span><br><span class="line"> ---&gt; daebc80cbf9d</span><br><span class="line">Step 3/3 : RUN echo &quot;docker practice&quot; &gt; test1.txt</span><br><span class="line"> ---&gt; Running in 500473ff3363</span><br><span class="line">Removing intermediate container 500473ff3363</span><br><span class="line"> ---&gt; 4a1668a9a53c</span><br><span class="line">Successfully built 4a1668a9a53c</span><br><span class="line">Successfully tagged workfile1:latest</span><br></pre></td></tr></table></figure></p><p>可以看到，构建过程中，出现了两个中间容器<code>a33b48c39597</code>和<code>500473ff3363</code>，所以这两个RUN，其实运行的是不一样的容器，最终结果，启动容器后在<code>/home/myapp</code>下可能就找不到<code>test1.txt</code>，验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myworkfile]# docker run -it workfile1 bash</span><br><span class="line">root@3a7bbb6da9a2:/# cd /home/</span><br><span class="line">root@3a7bbb6da9a2:/home# ls</span><br><span class="line">myapp</span><br><span class="line">root@3a7bbb6da9a2:/home# cd myapp/</span><br><span class="line">root@3a7bbb6da9a2:/home/myapp# ls</span><br><span class="line">root@3a7bbb6da9a2:/home/myapp#</span><br></pre></td></tr></table></figure></p><p>没有找到test1.txt</p><p>使用WORKDIR:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">WORKDIR /home/myapp</span><br><span class="line">RUN echo &quot;docker practice&quot; &gt; test2.txt</span><br></pre></td></tr></table></figure></p><p>构建镜像，运行容器，查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myworkfile2]# docker build -t workfile2 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/3 : FROM ubuntu:16.04</span><br><span class="line"> ---&gt; 2a697363a870</span><br><span class="line">Step 2/3 : WORKDIR /home/myapp</span><br><span class="line"> ---&gt; Running in a64c73b81fcb</span><br><span class="line">Removing intermediate container a64c73b81fcb</span><br><span class="line"> ---&gt; c7868d92cec6</span><br><span class="line">Step 3/3 : RUN echo &quot;docker practice&quot; &gt; test2.txt</span><br><span class="line"> ---&gt; Running in f18afb589fee</span><br><span class="line">Removing intermediate container f18afb589fee</span><br><span class="line"> ---&gt; 8733481c9491</span><br><span class="line">Successfully built 8733481c9491</span><br><span class="line">Successfully tagged workfile2:latest</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myworkfile2]# docker run -it workfile2 bash</span><br><span class="line">root@8bc345cf4fe7:/home/myapp# ls</span><br><span class="line">test2.txt</span><br><span class="line">root@8bc345cf4fe7:/home/myapp# cat test2.txt </span><br><span class="line">docker practic</span><br></pre></td></tr></table></figure><p>看到在<code>/home/myapp</code>下有<code>test2.txt</code>，并且内容是我们指定的。</p><p>Ps 在Dockerfile中，这边只使用<code>WORKDIR /home/myapp</code>并没有创建该目录，但是，后面执行就是在该目录下，这是因为<code>WORKDIR</code>会帮你建立目录</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>和<code>WORKDIR</code>类似，指定之后执行<code>RUN</code>、<code>COPY</code>等命令的用户；</p><p>示例一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">USER kyle</span><br><span class="line">RUN echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure></p><p>构建镜像:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser2]# docker build -t myuser2 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/3 : FROM ubuntu:16.04</span><br><span class="line"> ---&gt; 2a697363a870</span><br><span class="line">Step 2/3 : USER kyle</span><br><span class="line"> ---&gt; Running in b9af960d2702</span><br><span class="line">Removing intermediate container b9af960d2702</span><br><span class="line"> ---&gt; ba5592dfdba1</span><br><span class="line">Step 3/3 : RUN echo &quot;Hello world&quot;</span><br><span class="line"> ---&gt; Running in d93f1b59934c</span><br><span class="line">unable to find user kyle: no matching entries in passwd file</span><br></pre></td></tr></table></figure></p><p>发现报错，kyle该用户不存在，镜像<code>myuser2</code>构建不成功</p><p>示例二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser1]# cat Dockerfile </span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN groupadd -r tests &amp;&amp; useradd -r -g tests kyle</span><br><span class="line">USER kyle</span><br><span class="line">RUN echo &quot;Hello World&quot;</span><br></pre></td></tr></table></figure></p><p>构建镜像，运行容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser1]# docker build -t myuser1 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM ubuntu:16.04</span><br><span class="line"> ---&gt; 2a697363a870</span><br><span class="line">Step 2/4 : RUN groupadd -r tests &amp;&amp; useradd -r -g tests kyle</span><br><span class="line"> ---&gt; Running in 95030508e783</span><br><span class="line">Removing intermediate container 95030508e783</span><br><span class="line"> ---&gt; 8910cd5c0ee0</span><br><span class="line">Step 3/4 : USER kyle</span><br><span class="line"> ---&gt; Running in 5ca75c068a8b</span><br><span class="line">Removing intermediate container 5ca75c068a8b</span><br><span class="line"> ---&gt; 17e120181a8a</span><br><span class="line">Step 4/4 : RUN echo &quot;Hello World&quot;</span><br><span class="line"> ---&gt; Running in 022b81376556</span><br><span class="line">Hello World</span><br><span class="line">Removing intermediate container 022b81376556</span><br><span class="line"> ---&gt; 73527faf6379</span><br><span class="line">Successfully built 73527faf6379</span><br><span class="line">Successfully tagged myuser1:latest</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser1]# docker run -it myuser1 bash</span><br><span class="line">kyle@55b05690325a:/$ whoami</span><br><span class="line">kyle</span><br></pre></td></tr></table></figure><p>成功构建镜像，切换用户。</p><p>这两个示例可以看出，使用<code>USER</code>之前，必须创建好用户，也就是<strong><code>USER</code>不会帮你建用户，只是切换用户</strong></p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>指定制作作者信息，格式：<code>MAINTAINER &lt;name&gt;</code>，例如<code>MAINTAINER kyle kyle@xxx.com</code></p><p>以上，就是Dockerfile一些常用的指令，基本是借鉴的<a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">《docker practice》</a>…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（三）&lt;/p&gt;
&lt;p&gt;Dockerfile简介二&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客配置https</title>
    <link href="http://tokyle.com/2019/06/11/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AEhttps/"/>
    <id>http://tokyle.com/2019/06/11/hexo博客配置https/</id>
    <published>2019-06-11T09:30:35.000Z</published>
    <updated>2019-06-11T09:37:59.043Z</updated>
    
    <content type="html"><![CDATA[<p>hexo博客配置https</p><a id="more"></a><p>整天被chrome提醒不安全，简直了，实在忍不下去了，给博客加个s</p><p>方法很简单，到<a href="https://dash.cloudflare.com/login" target="_blank" rel="noopener">CloudFlare</a>解析域名，开启CDN强制http转https，修改DNS即可</p><p>原DNS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dns23.hichina.com</span><br><span class="line"></span><br><span class="line">dns24.hichina.com</span><br></pre></td></tr></table></figure></p><p>修改后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cortney.ns.cloudflare.com</span><br><span class="line"></span><br><span class="line">lloyd.ns.cloudflare.com</span><br></pre></td></tr></table></figure></p><p><code>CloudFlare</code>注册以后配置很简单，基本输入自己域名（tokyle.com）下一步下一步就结束了</p><p>就最后有一步配置DNS:<code>DNS Manage your Domain Name System (DNS) settings</code>时候，CNAME配置自己的域名，然后到对应的域名提供商（阿里云）去修改DNS解析</p><p>成功之后，CloudFlare会邮件给你，就可以愉快的https了：</p><blockquote><p><a href="https://tokyle.com">https://tokyle.com</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo博客配置https&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://tokyle.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Hexo" scheme="http://tokyle.com/tags/Hexo/"/>
    
      <category term="https" scheme="http://tokyle.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（二）</title>
    <link href="http://tokyle.com/2019/06/11/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/11/docker简单使用（二）/</id>
    <published>2019-06-11T08:06:36.000Z</published>
    <updated>2019-06-11T08:07:36.209Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（二）</p><p>Dockerfile简介一<br><a id="more"></a></p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile是一个包含一条条指令的文本文件，其中每一条指令都构建一层（每一条指令的内存，就是描述该层应当如何构建）（docker镜像采用联合文件系统）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</span><br></pre></td></tr></table></figure><p>Dockerfile使用示例，建立一个空白文件夹，进去文件夹，创建Dockerfile，编辑Dockerfile，编写指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir nginxtest</span><br><span class="line"></span><br><span class="line">cd nginxtest</span><br><span class="line"></span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure></p><p>Dockerfile内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></p><p>在当前文件夹，构建镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginxtest]# docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"> ---&gt; 62c261073ecf</span><br><span class="line">Step 2/2 : RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running in c20926fff810</span><br><span class="line">Removing intermediate container c20926fff810</span><br><span class="line"> ---&gt; 6ee9e7b88db2</span><br><span class="line">Successfully built 6ee9e7b88db2</span><br><span class="line">Successfully tagged nginx:v3</span><br></pre></td></tr></table></figure></p><p>注意docker build最后有个<code>.</code>表示镜像构建的上下文（Context）</p><h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h3><p>说实话，网上全是抄的一模一样的，全部来去《docker practice》，我也说不好自己理解的是对是错。。</p><p>首先，我也抄一下，docker其实是C/S架构，在执行docker build的时候，其实是有和server端（Docker引擎，服务端守护进程）进行交互。<br>Docker运行时，Docker引擎提供一组REST API，docker命令这样的客户端，就是通过这组API与Docker引擎交互，从而完成各种功能。<br>因此，在进行docker build的时候，看起来像是在本地进行构建，实际上，是先将上下文定义的路径下构建需要的包上传到Docker引擎，在Docker引擎处（服务端）完成构建。之前进行构建示例时候，有一行可以看出，和server进行了交互：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon  2.048kB</span><br></pre></td></tr></table></figure></p><p>在Dockerfile中经常会需要用到COPY，服务器在执行构建的时候，就需要知道copy的文件的地址，也就是上下文路径，需要注意的是，Docker的镜像构建上下文，即不是docker build执行的路径，也不是Dockerfile当前所在的目录。默认情况下，是建议创建一个空文件夹，然后将构建需要的文件和Dockerfile都放在该文件夹下，这样理所当然的Dockerfile所在路径就是上下文路径。<br>（说实话，这个上下文，有点晕，不是很理解，我只能理解成是构建需要的文件所在的路径为上下文；也就是为什么要创建一个空文件夹，将构建需要的文件和Dockerfile放进该文件夹的原因）<br>一定要记住，<strong>千万不要把Dockerfile放在根目录，不然会打包整个硬盘</strong></p><p>一些Dockerfile指令示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY ./package.json /etc/</span><br><span class="line">COPY pachage.json /etc/</span><br></pre></td></tr></table></figure></p><p>上述两句效果是一样的，都是讲上下文下的<code>package.json</code>拷贝到镜像里面的<code>/etc/</code>下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY /usr/local/nginx/nginx.conf /etc/nginx/</span><br></pre></td></tr></table></figure><p>上面这条，会无法工作，因为<code>/usr/local/nginx/nginx.conf</code>已经超出了上下文范文，服务端无法获取该文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /usr/kyle/dockertest/a/Dockerfile .</span><br></pre></td></tr></table></figure></p><p>当Dockerfile不在构建上下文的根目录下，可以-f指定该文件位置（当前执行docker build在构建上下文下，可以理解为，当前有个空文件夹，里面是构建需要的文件，但是Dockerfile不在当前文件夹下，可以通过-f指定）</p><h4 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h4><p>现在上下文中有不想上传到服务端的文件，就需要使用<code>.dockerignore</code>，例如当前文件夹下有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mynginx]# ls -al</span><br><span class="line">总用量 20</span><br><span class="line">drwxr-xr-x  2 root root  96 6月  11 15:23 .</span><br><span class="line">drwxr-xr-x. 6 root root 147 6月  11 11:07 ..</span><br><span class="line">-rw-r--r--  1 root root  99 6月  11 15:22 Dockerfile</span><br><span class="line">-rw-r--r--  1 root root  10 6月  11 15:23 .dockerignore</span><br><span class="line">-rw-r--r--  1 root root  33 6月  11 15:20 text1.txt</span><br><span class="line">-rw-r--r--  1 root root  37 6月  11 15:20 text2.txt</span><br><span class="line">-rw-r--r--  1 root root  19 6月  11 15:22 text3.txt</span><br></pre></td></tr></table></figure></p><p>不想把text3.txt上传到server，其中Dockerfile内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">COPY text* /home/</span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></p><p>这样，只需要编辑<code>.dockerignore</code>，将text3.txt添加进去，然后构建镜像即可<br>可以起容器，进去验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mynginx]# docker run --name web2 -d -p 8070:80 nginx:v4</span><br><span class="line">76527bd2b0f601e4fa844b9ed3afc4f29da65ee1d202fca6ee6c81380591ad0a</span><br><span class="line">[root@localhost mynginx]# </span><br><span class="line">[root@localhost mynginx]# docker exec -it web2 bash</span><br><span class="line">root@76527bd2b0f6:/# cd /home</span><br><span class="line">root@76527bd2b0f6:/home# ls</span><br><span class="line">text1.txt  text2.txt</span><br></pre></td></tr></table></figure></p><p>可以看到，已经忽略了text3.txt</p><p>tips：<strong>删除镜像</strong>：<code>docker rmi imageid</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mynginx]# docker rmi a59be9875db4</span><br><span class="line">Untagged: nginx:v4</span><br><span class="line">Deleted: sha256:a59be9875db4025dcdab5a26c239302eec9bea47427b04eaa02e2111a800d2ec</span><br><span class="line">Deleted: sha256:7cc4283ef786efa1f9e2885533d3c3eb815a273548f5e7bbfda777726173a7b9</span><br><span class="line">Deleted: sha256:9e87263adf6572244788519ce5c9338c3e70b6e62cc6f1092e9b257a487ecb3c</span><br><span class="line">Deleted: sha256:79b76358156ea32a59800f6d4600a8ce79cc3798cd0ddfcad3362a014f96b397</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（二）&lt;/p&gt;
&lt;p&gt;Dockerfile简介一&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（一）</title>
    <link href="http://tokyle.com/2019/06/10/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/10/docker简单使用（一）/</id>
    <published>2019-06-11T02:14:21.000Z</published>
    <updated>2019-06-11T02:15:35.700Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（一）</p><a id="more"></a><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>docker获取镜像很简单，<code>docker pull image:tag</code>即可，不加tag默认获取最新<code>latest</code><br>例如，获取Ubuntu和nginx：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu#获取latest</span><br><span class="line"></span><br><span class="line">docker pull ubuntu:16.04#获取16.04版本ubuntu</span><br><span class="line"></span><br><span class="line">docker pull nginx#获取latest版nginx</span><br></pre></td></tr></table></figure></p><h4 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h4><p>获取完镜像之后，可以通过<code>dokcer images</code>来查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                 latest              62c261073ecf        5 days ago          109MB</span><br><span class="line">ubuntu                16.04               2a697363a870        3 weeks ago         119MB</span><br><span class="line">ubuntu                latest              7698f282e524        3 weeks ago         69.9MB</span><br><span class="line">hello-world           latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line">ngrinder/controller   latest              e7f8d86685cd        3 years ago         246MB</span><br></pre></td></tr></table></figure></p><p>镜像的运行，以ubuntu:16.04为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu:16.04</span><br></pre></td></tr></table></figure></p><p>可以通过<code>docker ps -a</code>来查看当前运行的镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker  ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS                  NAMES</span><br><span class="line">385364730b09        ubuntu:16.04        &quot;/bin/bash&quot;              18 seconds ago      Up 16 seconds                                         nervous_jones</span><br></pre></td></tr></table></figure></p><p>其中<code>-it</code>表示以交互式方式运行镜像，这样，就可以进入交互式终端（ubuntu），来进行一些操作，例如查看当前系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@385364730b09:/# cat /etc/os-release</span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION=&quot;16.04.6 LTS (Xenial Xerus)&quot;</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 16.04.6 LTS&quot;</span><br><span class="line">VERSION_ID=&quot;16.04&quot;</span><br><span class="line">HOME_URL=&quot;http://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br></pre></td></tr></table></figure></p><p>使用<code>exit</code>退出容器</p><p>查看当前容器状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS                  NAMES</span><br><span class="line">385364730b09        ubuntu:16.04        &quot;/bin/bash&quot;              2 minutes ago       Exited (0) 4 seconds ago                              nervous_jones</span><br></pre></td></tr></table></figure></p><p>可以看见当前STATUS状态从<code>Up xxx</code>变成了<code>Exited</code>，容器以及被关闭，如果该容器只是用来调试错误，在关闭之后可以进行删除操作：<code>docker rm 385364730b09</code>(Container id)</p><p>或者在启动镜像时候就直接指定关闭即删除容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm ubuntu:16.04</span><br></pre></td></tr></table></figure></p><h4 id="运行webserver"><a href="#运行webserver" class="headerlink" title="运行webserver"></a>运行webserver</h4><p>像类似nginx这样的webserver，运行时候，需要指定端口，可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web1 -d -p 8088:80 nginx</span><br></pre></td></tr></table></figure></p><p>以nginx镜像启动名为web1的容器，端口从80映射到8088，这样，在浏览器中可以使用<strong><a href="http://ip:8088" target="_blank" rel="noopener">http://ip:8088</a></strong>打开nginx欢迎页面。</p><h4 id="commit保存新镜像"><a href="#commit保存新镜像" class="headerlink" title="commit保存新镜像"></a>commit保存新镜像</h4><p>前面已经启动了nginx的镜像，并且以8088端口运行，现在，修改nginx的欢迎页面来生成一个新的镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it web1 bash</span><br></pre></td></tr></table></figure></p><p>进入容器之后，修改默认页：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p><p>刷新浏览器页面即可，当前欢迎页已被修改<br>修改了容器的文件，也就是改动了容器的存储层，可以通过<code>docker diff web1</code>来查看具体改动</p><p>以上已经完成了修改nginx默认页，现在需要将修改保存成新的镜像，这样后面就可以直接使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker commit \</span><br><span class="line">&gt; --author &quot;kyle&quot; \</span><br><span class="line">&gt; --message &quot;change the default page&quot; \</span><br><span class="line">&gt; web1 \</span><br><span class="line">&gt; nginx:v2</span><br><span class="line">sha256:f531cfc896d61fd557748ddabb1ce2233e57f4e88e6cf49502e4c3e03de77eff</span><br></pre></td></tr></table></figure></p><p>然后使用docker images查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                 v2                  f531cfc896d6        12 minutes ago      109MB</span><br><span class="line">nginx                 latest              62c261073ecf        6 days ago          109MB</span><br><span class="line">ubuntu                16.04               2a697363a870        3 weeks ago         119MB</span><br><span class="line">ubuntu                latest              7698f282e524        3 weeks ago         69.9MB</span><br><span class="line">hello-world           latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line">ngrinder/controller   latest              e7f8d86685cd        3 years ago         246MB</span><br></pre></td></tr></table></figure></p><p>通过<code>docker history</code>查看镜像的历史记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker history nginx:v2</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">f531cfc896d6        15 minutes ago      nginx -g daemon off;                            106B                change the default page</span><br><span class="line">62c261073ecf        6 days ago          /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B                  </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c #(nop)  STOPSIGNAL SIGTERM           0B                  </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c #(nop)  EXPOSE 80                    0B                  </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c ln -sf /dev/stdout /var/log/nginx…   22B                 </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c set -x     &amp;&amp; addgroup --system -…   54MB                </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c #(nop)  ENV PKG_RELEASE=1~stretch    0B                  </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c #(nop)  ENV NJS_VERSION=0.3.2        0B                  </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c #(nop)  ENV NGINX_VERSION=1.17.0     0B                  </span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B                  </span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B                  </span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop) ADD file:fcb9328ea4c115670…   55.3MB</span><br></pre></td></tr></table></figure></p><p><strong>备注：</strong> docker commit要慎用，该操作，即使是简单的修改一个默认页面，也会同时添加或改动很多文件，如果是安装软件包、编译构建，那会有大量无关内容被添加进来，不小心清理会导致镜像极为臃肿；并且，docker commit除了制作镜像的人，其他没有人知道执行过什么命令，无法保证下一次可以生成一个一模一样的镜像（以上，来自docker practice）</p><p>关于docker镜像的制作，最优良的方式是写<code>dockerfile</code> 这个后面再说</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（一）&lt;/p&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>几个测试问题思考</title>
    <link href="http://tokyle.com/2019/05/29/%E5%87%A0%E4%B8%AA%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83/"/>
    <id>http://tokyle.com/2019/05/29/几个测试问题思考/</id>
    <published>2019-05-29T09:07:26.000Z</published>
    <updated>2019-05-29T09:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>几个测试问题思考</p><a id="more"></a><p>翻到了关于测试职业生涯的文章，里面有提到几个问题，自己想了想，挺震撼的，之前真没仔细考虑过</p><h3 id="如果测试时间不够，怎么办"><a href="#如果测试时间不够，怎么办" class="headerlink" title="如果测试时间不够，怎么办"></a>如果测试时间不够，怎么办</h3><p>或者可以延伸为，<strong>如果测试时间不够，肯定不能够全部覆盖的进行测试，是否可以只测试客户关心的，比较常用的功能？</strong></p><p>想了挺久，结合网友的讨论，我给出的答案是：<br>作为测试，碰到时间紧张，测试资源欠缺，我们所唯一能做的就是上报公司，让公司协调人工和资源做延期处理。这样做，公司可能会因为不能如期交付而受到一定的经济损失，但交付一个合格的产品给客户，绝对不会有信誉上的损失（即使做了常用功能的测试，也不能保障产品就已经达到的交付标准，实在是中彩票的事情），从长远来看，会有更多的收益；</p><p>作为测试，我们没有任何权利自己做风险处理，“测客户关心的，测主要功能”都是错误的测试行为；</p><p>作为测试，坚守自己的职业道德底线，只做职责范围内和力所能及的事情；</p><p>最后，一个大话，作为测试，不仅需要对支付你工资的老板负责，也请为你手中的产品负责，为客户支付的金钱负责。</p><h3 id="如果让你测试一个完全不熟悉的系统，怎么办"><a href="#如果让你测试一个完全不熟悉的系统，怎么办" class="headerlink" title="如果让你测试一个完全不熟悉的系统，怎么办"></a>如果让你测试一个完全不熟悉的系统，怎么办</h3><p>前提当然是可能没有需求说明书，甚至没有产品架构图<br>看到testerhome上一个回答，很有启发性<br>没有标准答案，参考如下：</p><ol><li><p>先去直接操作和观察被测物。（比直接奔向需求要加分很多，想一下，你实际工作中，快速理解一个东西靠的是什么？肯定不是先读文档，且不说这些文档是不是能够正确的描述被测物）</p></li><li><p>其他信息来源：同类产品，说明书，直接操作、观察被测物，原有版本，找产品经理，找开发，找销售，运维，客服，找用户，公司知识库，历史邮件，会议纪要，原来的各种文档，代码，google，相关法规，行业标准。。。</p></li><li><p>如果项目进度很赶，会先上手操作，参考能找到的一切文档及信息源，通过迭代，一边学一边加深理解，一边给出质量反馈；</p></li><li><p>思考是什么原因造成这样的局面：没有需求文档，没有架构图，开发很赶没空搭理。怎么解决：推动知识库建设和必要的文档输出，也是很重要的。</p></li></ol><h3 id="怎么优化测试工作"><a href="#怎么优化测试工作" class="headerlink" title="怎么优化测试工作"></a>怎么优化测试工作</h3><p>开发提测质量不高。测试的头几天，很多主流程都走不通，导致测试总是在等待，或者是跟着开发一起联调。而这段时间，已经被习惯性的认为是测试时间了，因为：提测了</p><p>项目抱怨，测试时间过长，如何缩短测试时间</p><p>先分析测试时间过长的原因，可能是：</p><ol><li><p>测试环境不可用，测试环境被占用</p></li><li><p>开发提测质量不高，主流程都走不通</p></li></ol><p>解决办法：<br>关于环境问题，可能可以实施：</p><ol><li><p>监控环境使用率，可用率（时间占比）；</p></li><li><p>规范部署，部署时间，操作人，checklist；</p></li><li><p>制定规则，权限分明，操作环境的人员，分工；</p></li><li><p>确定部署人员，backup人员，完整可行的部署手册</p></li><li><p>环境分组，分版本操作（更新devops技能，docker容器化进行环境隔离） </p></li><li><p>等等… </p></li></ol><p>关于提测质量</p><p>测试可以：</p><ol><li><p>有明确的测试计划，并让所有干系人都有明确的预期</p></li><li><p>测试依据风险测试，最大的风险得到最快的cover，科学分配时间，明显缩短bug反馈时间弧</p></li><li><p>bug严格管理，所有重要bug都及时修复</p></li><li><p>良好的沟通和汇报机制，每天让团队主要干系人清晰的知道，距离发布还差多远</p></li><li><p>外部资源联调非常早的进行，不会让它在测试后期成为测试blocker。</p></li></ol><p>要求开发可以：</p><ol><li><p>根据测试提供冒烟用例，开发必须完成一定程度的自测才能提测。</p></li><li><p>测试和开发做自动化同期共建，在开发过程中，核心功能就被自动化用例保护起来了。</p></li><li><p>开发切分feature提测，而不是攒一个大招一下子提一坨</p></li><li><p>代码Codereview变成团队常规活动，QA在早期跟进核心代码，把问题坑杀在萌芽阶段</p></li></ol><p>结合新的理念，测试左移：提前参与；测试右移：生产监控体系；全面保障产品质量，并且提高测试效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个测试问题思考&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://tokyle.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="lives" scheme="http://tokyle.com/tags/lives/"/>
    
  </entry>
  
  <entry>
    <title>闲谈测试理论</title>
    <link href="http://tokyle.com/2019/05/28/%E9%97%B2%E8%B0%88%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    <id>http://tokyle.com/2019/05/28/闲谈测试理论/</id>
    <published>2019-05-28T09:37:16.000Z</published>
    <updated>2019-05-28T09:37:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>闲谈测试理论</p><a id="more"></a><h3 id="测试理念"><a href="#测试理念" class="headerlink" title="测试理念"></a>测试理念</h3><p>也是个人的测试坚持吧，有很多，最在意的几条</p><p><strong>不为进度牺牲质量</strong></p><p><strong>软件测试，绝对不存在随便点点</strong></p><p><strong>测试人员要全力关注的是测试设计</strong></p><p><strong>测试工程师，是产品的第一批用户，关注用户满意度</strong></p><h3 id="测试工作"><a href="#测试工作" class="headerlink" title="测试工作"></a>测试工作</h3><h4 id="从需求出发"><a href="#从需求出发" class="headerlink" title="从需求出发"></a>从需求出发</h4><p>软件产品的设计、研发、测试、投产，一定是为了满足一定的需求，PRD（产品需求文档）所描述的产品需求，是切研发、测试开展的基础。或许现在很多公司号称敏捷开发， 没有PRD，那也一定会在类似wiki上有相应的记载，如果这个也没有，那产品最终的质量是很值得怀疑的，毕竟一点需求痕迹都没有，那测试人员的测试根据，就只是开发实现了，比起PO的需求，已经产生了很大的偏差。</p><p>测试人员进行软件测试必须从需求出发。首先要全面了解需求，包括其背景、关联性、用户特点等；其次要深入挖掘隐含的需求和关联，包括某个需求隐含了 对于系统现有功能的修改等等。 我们只有在全面、深入了解需求的基础上，才能设计全面、有效的测试用例来进行测试，以满足对于软件产品满足需求的基本质量保证。</p><h4 id="测试设计"><a href="#测试设计" class="headerlink" title="测试设计"></a>测试设计</h4><p>测试活动，最应该关注的是测试设计，而不是最后冷冰冰的执行了多少多少用例，提交了多少多少bug。</p><p>测试设计的基础是对于需求的全面理解，并且在需求的基础上，对于需求实现的设计进行一定的了解；很多测试人员进行测试活动的依据都是需求文档，而忽略了开发的逻辑设计这一块；如果可以进行一定的开发设计分析的话，可以帮助我们测试人员更加全面的进行质量验证（有些时候，开发是可以实现需求，但是会出现数组溢出等问题，这样的问题，在其他地方可能就会引起重大的bug）</p><p>个人觉得，关注测试设计，才是关注了软件测试之道</p><h4 id="测试目标"><a href="#测试目标" class="headerlink" title="测试目标"></a>测试目标</h4><p>需要明确的是，软件测试，是在生命周期的接近最末端，单单靠测试，是无法保证软件质量的，测试人员，是软件质量的验证者，并不是保障，软件质量需要整个生命周期，整个团队一起努力。</p><p>软件测试并不能保证测试活动结束之后，产品没有bug，这是不现实的，没有一个软件产品可以号称自己没有bug，同样，这也不是测试的目标。</p><p>引用网上看到的一句话：<br><strong>测试活动-是一个运用测试的思维和各种测试理论及方法，将所测试的软件产品的每一个功能都改变成一组特定的输入和一组特定的输出一一确定对应的形式，形成测试用例，然后待开发人员提交测试后，在测试环境部署被测程序，根据测试用例进行主动测试的过程。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闲谈测试理论&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://tokyle.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="lives" scheme="http://tokyle.com/tags/lives/"/>
    
  </entry>
  
  <entry>
    <title>所谓测试新时代</title>
    <link href="http://tokyle.com/2019/05/27/%E6%89%80%E8%B0%93%E6%B5%8B%E8%AF%95%E6%96%B0%E6%97%B6%E4%BB%A3/"/>
    <id>http://tokyle.com/2019/05/27/所谓测试新时代/</id>
    <published>2019-05-27T08:57:56.000Z</published>
    <updated>2019-05-27T08:59:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>所谓测试新时代</p><a id="more"></a><h3 id="2019-软件测试"><a href="#2019-软件测试" class="headerlink" title="2019 软件测试"></a>2019 软件测试</h3><p>翻到了<code>World Quality Report 2018-19</code>看了好几项，也看了testerhome，软件质量报告等优秀公众号的文章，世界的确在变。</p><p>2019甚至之后很多年，国内的软件测试和质量保障人员的职责，已经不是单纯的找bug，现在我们需要做的，是客户满意度和业务成果的推动者。<br>刚入行时候，就一直挂在嘴边的一句话，软件测试，是要站在客户角度看问题，但是随着节奏越来越快，“涉世”越来越深，逐渐的，也就成了，找到个bug，提交各jira，结束，曾几何时，我们就迷失了自己；现在<code>World Quality Report 2018-19</code>再次提出了，<strong>客户满意度</strong>这个词，也是对我们已经迷茫的测试人员一个警醒。</p><h4 id="2019软件测试的趋势"><a href="#2019软件测试的趋势" class="headerlink" title="2019软件测试的趋势"></a>2019软件测试的趋势</h4><h5 id="AI在质量保障和测试中的作用"><a href="#AI在质量保障和测试中的作用" class="headerlink" title="AI在质量保障和测试中的作用"></a>AI在质量保障和测试中的作用</h5><p>随着过去一年甚至几年的AI大潮，AI技术在软件测试中越来越有应用市场，对于自动化的保障、对本身的AI产品的测试、使用AI进行质量预测等等，说实话，是个新技术，也是未来的一个趋势，但是目前该方案还没有那么的普及，很多公司，自身都没有响应的人工智能开发，所以，至少对我来说，是个值得参考的方向，但当前阶段，我不会去过多关注。</p><h5 id="敏捷以及devops"><a href="#敏捷以及devops" class="headerlink" title="敏捷以及devops"></a>敏捷以及devops</h5><p>这个，至少在我现在在的公司，是大谈特谈，从最高层开始，大力推行所谓敏捷开发，敏捷团队，说实话，一个小而优的团队，进行快速迭代对于产品来说，肯定是好的，同时配以devops，辅助CI\CD，全自动化回滚，测试等，可以想象，这样的团队，日常开发、测试、发布的效率有多高。但是实际上呢，从我现在公司的状况来看，一味的牺牲质量去追求速度，为了敏捷实施敏捷，到头来是留下了一堆祸根，客户生产问题接踵而至，整个产线疲于应付客户问题，无心关注新的功能点的设计，质量控制，继续往后，新的功能点进行快速迭代上线，缺乏有效的测试，更加增加了祸根数量，为后续的生产问题集中爆发写下了引言，整个，已经形成了恶性循环。</p><p>同时，敏捷团队和devops的转型，已经打乱了原来的QA团队，所有人分配到了不同的产线，这样使得跨项目的合作共享变成尤其困难。这点值得吐槽的更多，算了，不说了。</p><h5 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h5><p>这个已经不是新鲜事了，几乎所有公司都在追求自动化。也用现在的公司来举例子吧，当前实现的自动化</p><ol><li>产品重构多，自动化脚本几乎每次都会随着产品新迭代进行更新，没有一个可以适应多版本的自动化方案；</li><li>自动化测试环境以及自动化测试数据，准备异常繁琐，大多时间是消耗在环境排查及数据准备上；</li><li>自动化技术及理念不推陈出新，并没有思考过怎么样进行更高效的自动化覆盖，一味的沉溺于维护当前脚本；</li></ol><h5 id="测试环境和成本"><a href="#测试环境和成本" class="headerlink" title="测试环境和成本"></a>测试环境和成本</h5><p>关于测试环境和测试数据，很多公司做法不一样，但是同样的，对于测试来说，很多时候，问题是出现在测试环境上，很多时间是消耗在准备测试数据上，如何进行快速的测试环境部署，以及如何保障测试数据复用真的是衡量一个企业测试团队成熟度的一项指标。</p><h4 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h4><h5 id="以智能的、分阶段的方式提升基础自动化和智能测试自动化水平"><a href="#以智能的、分阶段的方式提升基础自动化和智能测试自动化水平" class="headerlink" title="以智能的、分阶段的方式提升基础自动化和智能测试自动化水平"></a>以智能的、分阶段的方式提升基础自动化和智能测试自动化水平</h5><p>未来，自动化肯定是测试的必备技能，团队的自动化测试水平，很直接的会影响到后续一系列开展，是真的可以决定团队是否能真正开展敏捷的关键。</p><p><code>World Quality Report 2018-19</code>给的建议如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 优化测试</span><br><span class="line">2，实施基础的自动化测试</span><br><span class="line">3，采用智能的、自适应的测试自动化方案让自动化变得更加“智能”</span><br></pre></td></tr></table></figure></p><h5 id="以非孤立的方式实施测试数据和测试环境的管理"><a href="#以非孤立的方式实施测试数据和测试环境的管理" class="headerlink" title="以非孤立的方式实施测试数据和测试环境的管理"></a>以非孤立的方式实施测试数据和测试环境的管理</h5><p>企业要开始生命周期的自动化，把测试自动化和数据、环境的准备工作一起开展，不要分离开来。另外，要采用更加智能的方式来管理测试环境和数据。</p><h5 id="构建超出测试开发（SDET）之外的质量工程技能"><a href="#构建超出测试开发（SDET）之外的质量工程技能" class="headerlink" title="构建超出测试开发（SDET）之外的质量工程技能"></a>构建超出测试开发（SDET）之外的质量工程技能</h5><p>这项，原谅才疏学浅，暂时get不到，抄录一下。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">敏捷、DevOps、云、IoT、区块链和AI这些新趋势的发展，以及更加自动的、集成的质量保障方法的需求，企业需要关注新的质量技能。</span><br><span class="line"></span><br><span class="line">推荐以下方式做好质量保障能力建设：</span><br><span class="line"></span><br><span class="line">1、第一优先级是吸引敏捷测试专家，需要具备功能自动化技能和领域测试技能，自动化测试将是每个质量保障人员的必备技能；</span><br><span class="line"></span><br><span class="line">2、第二优先级是吸引 SDET ，他们的必备技能要求有高级自动化测试、白盒测试、开发和平台构建能力，同时最好还有 AI 应用的基础算法应用能力和自然语言处理技能；</span><br><span class="line"></span><br><span class="line">3、第三优先级是吸引拥有一些特定 QA 技能集的人员，比如安全等非功能测试、测试环境和数据的管理技能等；</span><br><span class="line"></span><br><span class="line">4、第四优先级是吸引高级 QA 专家，需要有AI架构技能，以构建能够执行重复、智能任务的“智能资产”，这些技能由深度机器学习概念和算法组成，比如决策树、分类器、神经网络、高级统计学和数据优化技能。</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1，未来，我们需要更加关注客户满意度，追求速度，忽视客户满意度，迟早药丸；<br>2，低水平的自动化测试，测试数据及测试环境的管理已经影响到整个敏捷的实施；加强自动化培训，更加规范科学的进行测试数据及环境的管理，才能更好保障QA实施；<br>3，测试人员，需要更多的必备技能，来应对未来的挑战；这点上，个人还是坚持，测试人员需要明了并坚定自己的测试理念。以此为根基，进行测试技术的扩展，才是可行的路。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote><p><a href="https://mp.weixin.qq.com/s/voKNIhVOPLrjgQhDUhte9w" target="_blank" rel="noopener">2019 软件测试行业 5 大关键趋势与应对策略</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓测试新时代&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://tokyle.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="lives" scheme="http://tokyle.com/tags/lives/"/>
    
  </entry>
  
  <entry>
    <title>测试 有惑</title>
    <link href="http://tokyle.com/2019/05/27/%E6%B5%8B%E8%AF%95-%E6%9C%89%E6%83%91/"/>
    <id>http://tokyle.com/2019/05/27/测试-有惑/</id>
    <published>2019-05-27T08:09:13.000Z</published>
    <updated>2019-05-27T08:10:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>测试有惑</p><a id="more"></a><p>最近因为一些事情，一度要转devops，一个我们这样的小互联网环境下还比较不常用的词汇；同时也遇上要手工造200多个excel这样的无语需求，烦躁之际，看到几篇文章，静下来好好想想，我现在的软件测试，是不是已经迷茫了。</p><h3 id="测试有惑"><a href="#测试有惑" class="headerlink" title="测试有惑"></a>测试有惑</h3><p>最近挺长时间，身边充斥着新兴技术，“大数据”、“容器化”、“微服务”、“service mesh”、“AI”等等，很长一段时间，我也像绝大多数人一样，追在后面，无尽的翻阅着“大数据下如何进行软件测试”、“如何测试分布式系统”、“容器化时代的测试技术”等等诸如此类的文章，渐渐的，从一个测试，学了python，关注了docker，k8s，到如今的servicemesh，istio；渐渐的，也感觉越来越无力，越来越迷茫，我的所作，是不是已经完成偏成了追求工具，追求新鲜，对于软件测试最基本的理论，是不是已经忘记的差不多了。</p><p>看到一篇博客，作者写了一句话，我也问了自己，发现，有点悲哀。</p><p><strong>面对被测对象，你的测试理念是什么</strong>，是否清楚，为何而战。</p><p>技术，永远处于不断重构中，而自己的测试理念，信念，才是作为测试从业者的根基，互联网的世界里，技术上的推陈出新永远比你的学习速度要快，一味的去追求技术，是不是需要担心，有一天，作为没有坚实测试理念的我们，会被技术革了命。</p><p>越来越迷茫，默然做着自己都不知道为什么的测试的我们，是不是可以稍微等一等，停下来重新寻找，或许已经丢失了的，我们的软件测试之道。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试有惑&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://tokyle.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="lives" scheme="http://tokyle.com/tags/lives/"/>
    
  </entry>
  
  <entry>
    <title>excel随机函数</title>
    <link href="http://tokyle.com/2019/05/23/excel%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0/"/>
    <id>http://tokyle.com/2019/05/23/excel随机函数/</id>
    <published>2019-05-24T03:28:33.000Z</published>
    <updated>2019-05-24T03:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>excel随机函数</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>需要给客户一份性能报告，然后有些数据需要稍微修饰下，服务器资源部分，采用的是之前nmon生成的报告，nmon的报告可以通过修改数据，自动生成图像，然后我们就需要在一个数值区间内生成几千个数据，来尽量真实点（o(╥﹏╥)o）（好没下限的感觉）</p><p>例如，现在需要出一个CPU使用率的监控图像，采用nmon和nmon_analyser生成了图像之后，找到cpu sheet页，通过更改User%，Sys%，Wait%以及Idle%来生成需要的数据的监控图像</p><p>现在需要生成一个CPU使用率在76%左右的图像，也就是需要User%的值大约在[74%, 78%]这个区间内，然后需要的是1000个这个区间的随机数，生成随机数的方法很多，这边介绍的excel的函数</p><h3 id="RAND"><a href="#RAND" class="headerlink" title="RAND()"></a>RAND()</h3><p>直接上用法</p><p>如果要生成[0, 10]，单元格内输入<code>=RAND()*10</code>，回车即可，按<code>F9</code>刷新</p><p>如果要生成[0.50]，单元格内输入<code>=RAND()*50</code>，回车即可，按<code>F9</code>刷新</p><p>然后，如果要生成[1, 8]，单元格内输入<code>=RAND()*7+1</code>，回车即可，按<code>F9</code>刷新</p><p>因此，我们的需求可以在单元格内写<code>=RAND()*4+74</code>，回车即可，按<code>F9</code>刷新<br>（1000条数据，直接往下拖即可）</p><p>纯粹是个无聊小技能。。</p><p>以上，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;excel随机函数&lt;/p&gt;
    
    </summary>
    
      <category term="skill" scheme="http://tokyle.com/categories/skill/"/>
    
    
      <category term="excel" scheme="http://tokyle.com/tags/excel/"/>
    
  </entry>
  
  <entry>
    <title>appium使用uiautomator2无法启动app问题</title>
    <link href="http://tokyle.com/2019/05/22/appium%E4%BD%BF%E7%94%A8uiautomator2%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8app%E9%97%AE%E9%A2%98/"/>
    <id>http://tokyle.com/2019/05/22/appium使用uiautomator2无法启动app问题/</id>
    <published>2019-05-23T01:56:07.000Z</published>
    <updated>2019-05-23T02:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>appium使用uiautomator2无法启动app问题</p><a id="more"></a><p>之前有遇到过Android 7之后，使用appium登录进去之后，拿不到元素，page_source获取也超时，找了资料，都说是android 7的原因，解决办法很简单，appium起的时候，加个参数就行了,改成下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">desired_caps = &#123;&#125;</span><br><span class="line">desired_caps[&apos;platformName&apos;] = &apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;] = &apos;8.1.0&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;] = &apos;yanfyang&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;] = &apos;com.kuaikan.comic&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;] = &apos;com.kuaikan.comic.ui.LaunchActivity&apos;</span><br><span class="line">desired_caps[&apos;automationName&apos;] = &apos;uiautomator2&apos;</span><br><span class="line">desired_caps[&apos;noReset&apos;] = True</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;, desired_caps)</span><br></pre></td></tr></table></figure></p><p>增加了一个：<code>desired_caps[&#39;automationName&#39;] = &#39;uiautomator2&#39;</code></p><p>这样直接启动，会有点问题</p><h3 id="Message-An-unknown-server-side-error-occurred-while-processing-the-command-Original-error-Could-not-sign-with-default-certificate"><a href="#Message-An-unknown-server-side-error-occurred-while-processing-the-command-Original-error-Could-not-sign-with-default-certificate" class="headerlink" title="Message: An unknown server-side error occurred while processing the command. Original error: Could not sign with default certificate."></a>Message: An unknown server-side error occurred while processing the command. Original error: Could not sign with default certificate.</h3><p>后面还有更有价值的报错，完整的不记得了，大概是这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files (x86)\Appium\resources\app\node_modules\appium-uiautomator2-server\apks\appium-uiautomator2-server-v3.1.1.apk       Access denied</span><br></pre></td></tr></table></figure></p><p>看到<code>Access denied</code>，首先就检查了下，因为当前电脑是域账号登录的，不是管理员，对那个报错的文件夹，权限只有读，没有写的权限，看样子问题是权限的</p><p><strong>解决办法</strong>：打开appium时候，右键使用管理员权限打开，这样就可以了</p><h3 id="命令行方式管理员运行appium"><a href="#命令行方式管理员运行appium" class="headerlink" title="命令行方式管理员运行appium"></a>命令行方式管理员运行appium</h3><p>linux或者mac好解决，sudo 即可，windows下，查了点资料，有个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runas /user:Administrator Appium.exe</span><br></pre></td></tr></table></figure></p><p>需要进入appium目录下执行</p><p>执行这条命令，会让输入一个administrator的密码，这个密码，可以更改，方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右击我的电脑——管理——本地用户和组——点击用户——选择administrator——右击设置密码</span><br></pre></td></tr></table></figure></p><h4 id="1327-用户帐户限制阻止了此用户进行登录。例如：不允许使用空密码，登录次数的限制，或强制实施的某个策略限制。"><a href="#1327-用户帐户限制阻止了此用户进行登录。例如：不允许使用空密码，登录次数的限制，或强制实施的某个策略限制。" class="headerlink" title="1327: 用户帐户限制阻止了此用户进行登录。例如：不允许使用空密码，登录次数的限制，或强制实施的某个策略限制。"></a>1327: 用户帐户限制阻止了此用户进行登录。例如：不允许使用空密码，登录次数的限制，或强制实施的某个策略限制。</h4><p>输入密码之后，还是会报错上述错误，这个，是由于没有解禁用户造成的，解禁办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右击我的电脑——管理——本地用户和组——点击用户——选择administrator——右击——选择属性——取消勾选  账户已禁用</span><br></pre></td></tr></table></figure></p><p>以上，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium使用uiautomator2无法启动app问题&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://tokyle.com/categories/appium/"/>
    
    
      <category term="appium" scheme="http://tokyle.com/tags/appium/"/>
    
      <category term="uiautomator2" scheme="http://tokyle.com/tags/uiautomator2/"/>
    
  </entry>
  
  <entry>
    <title>jumpserver简单使用</title>
    <link href="http://tokyle.com/2019/05/21/jumpserver%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://tokyle.com/2019/05/21/jumpserver简单使用/</id>
    <published>2019-05-21T07:15:44.000Z</published>
    <updated>2019-05-21T07:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>jumpserver简单使用</p><a id="more"></a><p>Jumpserver搭建完成之后，就可以通过堡垒机跳转到制定的机器了，登录jumpserver：</p><ol><li>要么直接是命令行(xshell 客户端)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@192.168.0.1 2222</span><br></pre></td></tr></table></figure></li></ol><p>回车再输入密码即可（192.168.0.1是jumpserver搭建的服务器的ip）</p><ol><li>使用xshell客户端秘钥进行登录，jumpserver服务器创建登录用户，设置密码，生成公钥和私钥，xshell使用该用户进行登录（具体设置后面会说明）</li></ol><p>jumpserver登录web页面有几块：<br><code>仪表盘</code>、<code>用户管理</code>、<code>资产管理</code>、<code>权限管理</code>、<code>会话管理</code>、<code>作业中心</code>、<code>日志审计</code>、<code>系统设置</code><br>简单介绍一下基本的一些用法</p><h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><p>系统设置里面有几个，基本设置、邮件设置、LDAP设置、终端设置、安全设置</p><p><strong>基本设置</strong>很简单，配置下当前jumpserver web端的url即可，Email主题前缀就是发送的邮件主题前缀，可以自定，没啥好说的;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 修改 url 的&quot;localhost&quot;为你的实际 url 地址, 否则邮件收到的地址将为&quot;localhost&quot; 也无法创建新用户</span><br></pre></td></tr></table></figure><p><strong>邮件设置</strong>，根据实际的邮件配置即可，使用SSL，端口为465，设置完成之后，可以点击“测试连接”试试看能不能成功；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 点击页面上边的&quot;邮件设置&quot;, 进入邮件设置页面</span><br><span class="line"># 默认使用 25 端口, 不勾选 SSL 和 TLS; 如果需要勾选 SSL, 端口需要修改成 465; 如果需要勾选 TLS, 端口需要改成 587</span><br><span class="line"># 不可以同时勾选 SSL 和 TLS</span><br><span class="line"># 配置邮件服务后, 点击页面的&quot;测试连接&quot;按钮, 如果配置正确, Jumpserver 会发送一条测试邮件到您的 SMTP 账号邮箱里面, 确定收到测试邮件后点击保存即可使用</span><br></pre></td></tr></table></figure></p><p><strong>LDAP设置</strong>，统一用户认证，看你需不需要使用域账号了，具体怎么配置可以咨询IT；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 如果不需要使用&quot;ldap&quot;用户登陆 jumpserver, 可以直接跳过, 不需要设置</span><br><span class="line"># 先&quot;测试&quot;通过才能保存</span><br><span class="line"># DN 和 OU 一定要完整(如 &quot;DN:cn=Manage,ou=Jumpserver,dc=jumpserver,ou=org&quot;)</span><br><span class="line"># 注：可借用第三方 gui 工具查看 ldap 用户的属性, 新版本已经支持中文名登录, 即cn=中文也可正常使用</span><br></pre></td></tr></table></figure></p><p><strong>终端设置</strong>，按需勾选，密码认证，密钥认证等；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># &quot;密码认证&quot;和&quot;密钥认证&quot;是 SSH 连接跳板机时所使用的认证方式(都不选会造成无法使用 SSH 方式连接登录跳板机, 不影响 web 登录)</span><br><span class="line"># &quot;Telnet成功正则表达式&quot; telnet设备登陆失败需要设置</span><br><span class="line"># &quot;命令存储&quot;&quot;录像存储&quot;位置设置</span><br><span class="line"></span><br><span class="line"># &quot;命令存储&quot;&quot;录像存储&quot;修改后, 需要在Jumpserver 会话管理-终端管理 修改terminal的配置 录像存储 命令记录, 然后重启 Jumpserver 服务</span><br><span class="line"># 设置后重启 Coco 才能生效</span><br></pre></td></tr></table></figure></p><p><strong>安全设置</strong>，也是按需勾选；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># &quot;MAF二次认证&quot;勾选会开启全局强制&quot;MFA&quot;, 所有 jumpserver 用户必须使用动态口令进行认证登录(即时生效)</span><br><span class="line"># &quot;限制登录失败&quot;和&quot;限制登录时间&quot;设置需要重启 jumpserver 才能生效</span><br><span class="line"># &quot;SSH最大空闲时间&quot;设置需要重启 coco 才能生效</span><br><span class="line"># &quot;密码校验规则&quot;设置立即生效</span><br></pre></td></tr></table></figure></p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>用户管理分用户列表和用户组，顾名思义，jumpserver的用户和组；根据实际需要创建对应的用户，和组，用户分到对应的组即可；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 点击页面左侧&quot;用户列表&quot;菜单下的&quot;用户列表&quot;, 进入用户列表页面</span><br><span class="line"># 点击页面左上角&quot;创建用户&quot;按钮, 进入创建用户页面, (也可以通过右上角导入模版进行用户导入)</span><br><span class="line"># 其中, 用户名即 Jumpserver 登录账号(具有唯一性, 不能重名)。名称为页面右上角用户标识(可重复)</span><br><span class="line"># 成功提交用户信息后, Jumpserver 会发送一条设置&quot;用户密码&quot;的邮件到您填写的用户邮箱</span><br><span class="line"># 点击邮件中的设置密码链接, 设置好密码后, 您就可以用户名和密码登录 Jumpserver 了。</span><br><span class="line"># 用户首次登录 Jumpserver, 会被要求完善用户信息, 按照向导操作即可。</span><br><span class="line">注：MFA 即 Google Authenticator, 使用此软件需要APP时间与浏览器时间同步</span><br></pre></td></tr></table></figure></p><p>关于创建用户及完善用户信息，为了方便后续使用xshell客户端可以使用密钥登录，需要一点注意：</p><ol><li>首先，在jumpserver服务器上创建登录的账号，设置密码，生成公钥和私钥(root账号)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#新增用户</span><br><span class="line">useradd kyle</span><br><span class="line"></span><br><span class="line"># 设置新密码</span><br><span class="line">passwd kyle</span><br><span class="line"></span><br><span class="line"># 生成公钥及私钥（记得过程中输入密钥的密码，后面会用到）</span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>在用户的家目录下（/home/kyle），会有<code>.ssh</code>文件夹（ls -al），里面是生成的公钥和私钥（cd /home/kyle/.ssh &amp;&amp; ls -al），这边用<code>id_rsa_1</code>和<code>id_rsa_1.pub</code>表示，便于识别</p><p>在jumpserver服务器上创建完账号kyle之后，在jumpserver web界面创建用户，用户名使用kyle，邮件自填，点击保存，等着收邮件，邮件会提示改密码，更改了密码之后，会进行完善用户信息，最主要的就是一个密钥，将之前生生成的公钥（id_rsa_1.pub）内容填进去即可(cat，复制)</p><h3 id="资产管理"><a href="#资产管理" class="headerlink" title="资产管理"></a>资产管理</h3><p>资产管理顾名思义就是管理设备的地方</p><h4 id="资产列表"><a href="#资产列表" class="headerlink" title="资产列表"></a>资产列表</h4><p>管理资产的节点，左边是资产树，右击可以进行增删改操作，右侧是该节点下的资产，界面挺简单</p><h4 id="网域列表"><a href="#网域列表" class="headerlink" title="网域列表"></a>网域列表</h4><p>这个功能没用过，看官方文档介绍的，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">网域功能是为了解决部分环境（如：混合云）无法直接连接而新增的功能，原理是通过网关服务器进行跳转登录。 </span><br><span class="line">JMS =&gt; 网域网关 =&gt; 目标资产</span><br></pre></td></tr></table></figure></p><h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4><p>jumpserver的管理用户，可以理解为资产上的root用户，或者是具备all sudo权限的用户；页面直接点创建管理用户，填写资产机器的root账号信息，或者用all sudo权限的账号信息即可（有个添加秘钥的选项，这个可以设置，root在目标机器上生成公钥和私钥，再引过来即可）</p><h4 id="系统用户"><a href="#系统用户" class="headerlink" title="系统用户"></a>系统用户</h4><p>官方解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">系统用户是 Jumpserver跳转登录资产时使用的用户，可以理解为登录资产用户，如 web, sa, dba(`ssh web@some-host`), 而不是使用某个用户的用户名跳转登录服务器(`ssh kyle@some-host`); 简单来说是 用户使用自己的用户名登录Jumpserver, Jumpserver使用系统用户登录资产。 系统用户创建时，如果选择了自动推送 Jumpserver会使用ansible自动推送系统用户到资产中，如果资产(交换机、windows)不支持ansible, 请手动填写账号密码。</span><br></pre></td></tr></table></figure></p><p>以下为官方文档的注意事项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># &quot;系统用户&quot;是 Jumpserver 跳转登录资产时使用的用户, 用户使用该用户登录资产</span><br><span class="line"># &quot;自动生成密码&quot;、&quot;自动推送&quot;、&quot;Sudo&quot;等功能需要对应资产的&quot;管理用户&quot;是且有root权限, 否则自动推送失败</span><br><span class="line"># ssh 协议的 &quot;Sudo&quot; 栏设定用户的 sudo 权限,</span><br><span class="line"># ssh 协议如果创建的&quot;系统用户&quot;已在资产上面存在, &quot;推送&quot;将会覆盖掉原用户的&quot;home&quot;目录权限(注: 替换成700权限)</span><br><span class="line"># ssh 协议的 &quot;ssh私钥&quot; 如果私钥有密码, 请把key的密码填在密码栏上, 目前仅支持 RSA DSA 格式私钥</span><br><span class="line"></span><br><span class="line"># 这里简单举几个 &quot;sudo&quot; 设置例子</span><br><span class="line">Sudo /bin/su  # 当前系统用户可以免sudo密码执行sudo su命令</span><br><span class="line"></span><br><span class="line">Sudo /usr/bin/git, /usr/bin/php, /bin/cat, /bin/more, /bin/less, /usr/bin/tail</span><br><span class="line"># 当前系统用户可以免sudo密码执行git php cat more less tail</span><br><span class="line"></span><br><span class="line">Sudo !/usr/bin/yum  # 当前系统用户不可以执行sudo yum命令</span><br><span class="line"></span><br><span class="line"># 此处的权限应该根据使用用户的需求汇总后定制, 原则上给予最小权限即可</span><br><span class="line"></span><br><span class="line"># &quot;系统用户&quot;创建时, 如果选择了&quot;自动推送&quot; Jumpserver 会使用&quot;Ansible&quot;自动推送系统用户到资产中, &quot;root&quot;用户不支持推送</span><br><span class="line"># 如果资产(交换机、Windows)不支持&quot;Ansible&quot;, 请去掉&quot;自动生成密钥&quot;、&quot;自动推送&quot;勾选。手动填写资产上已有的账号及账号密码</span><br><span class="line"></span><br><span class="line"># 如果想让用户登录资产时自己输入密码, 可以在创建系统用户时选择&quot;手动登录&quot;</span><br></pre></td></tr></table></figure></p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>权限管理下，主要就是<code>资产授权</code>，可以创建授权规则，选择用户或者组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># &quot;名称&quot;, 授权的名称, 不能重复</span><br><span class="line"># &quot;用户&quot;和&quot;用户组&quot;二选一, 不推荐即选择用户又选择用户组</span><br><span class="line"># &quot;资产&quot;和&quot;节点&quot;二选一, 选择节点会包含节点下面的所有资产</span><br><span class="line"># &quot;系统用户&quot;, 及所选的用户或用户组下的用户能通过该系统用户使用所选节点或者节点下的资产</span><br><span class="line"># 用户(组), 资产(节点), 系统用户是一对一的关系, 所以当拥有 Linux、Windows 不同类型资产时, 应该分别给 Linux 资产和 Windows 资产创建授权规则</span><br></pre></td></tr></table></figure></p><h3 id="Jumpserver一些名词解释"><a href="#Jumpserver一些名词解释" class="headerlink" title="Jumpserver一些名词解释"></a>Jumpserver一些名词解释</h3><h4 id="用户管理-1"><a href="#用户管理-1" class="headerlink" title="用户管理"></a>用户管理</h4><ul><li><p>用户组<br>多个用户可以组合成用户组，为了方便进行授权，可以将一个部门或者几个用户组成用户组，在授权中使用组授权，该组中的用户拥有所有授权的主机权限</p></li><li><p>用户<br>用户是授权和登陆的主体，将来为每个员工简历一个账户，用来登录跳板机，将资产授权给改用户</p></li></ul><h4 id="资产管理-1"><a href="#资产管理-1" class="headerlink" title="资产管理"></a>资产管理</h4><ul><li><p>资产<br>资产通常是我们的服务器、网络设备等，将资产授权给用户，用户则会有权限登录资产，执行命令等</p></li><li><p>管理账号<br>添加资产时需要一个管理账号，该账号是该资产上已有的有管理权限的用户，如root，或者是有NOPASSWD:ALL sudo权限的用户，改管理账号用来向资产推送系统用户，为系统用户添加sudo，获取资产的一些信息</p></li></ul><h4 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h4><ul><li>系统用户<br>系统用户是服务器上建立的一些真实存在的可以ssh登陆的用户，如dev,sa,dba等，系统用户可以使用jumpserver推送到服务器上，也可以利用自己公司的工具进行推送，授权时将用户、资产、系统用户关联起来，则表明用户有权限登陆该资产的这个系统用户，例如：用户<strong>小明</strong>以<strong>dev</strong>系统用户登录192.168.0.2资产，简单理解就是，<strong>将某个资产上的某个系统用户映射给这个用户登录</strong></li></ul><h4 id="用户作用："><a href="#用户作用：" class="headerlink" title="用户作用："></a>用户作用：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">登录web（使用用户）</span><br><span class="line"></span><br><span class="line">登陆跳板机（使用用户）</span><br><span class="line"></span><br><span class="line">跳转登陆Client端（使用系统用户）</span><br><span class="line"></span><br><span class="line">系统用户 关联sudo（就是sudo授权），该系统用户就拥有sudo权限</span><br><span class="line"></span><br><span class="line">推送系统用户（使用管理用户，管理用户是Client端上已有的用户并且有sudo权限）</span><br></pre></td></tr></table></figure><p>以上，完~</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><blockquote><p><a href="http://docs.jumpserver.org/zh/docs/quick_start.html" target="_blank" rel="noopener">官方指导文档</a><br><a href="https://www.cnblogs.com/kevingrace/p/5587265.html" target="_blank" rel="noopener">优秀指导文档</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jumpserver简单使用&lt;/p&gt;
    
    </summary>
    
      <category term="Devops" scheme="http://tokyle.com/categories/Devops/"/>
    
    
      <category term="Centos7" scheme="http://tokyle.com/tags/Centos7/"/>
    
      <category term="Jumpserver" scheme="http://tokyle.com/tags/Jumpserver/"/>
    
  </entry>
  
  <entry>
    <title>centos7安装jumpserver堡垒机</title>
    <link href="http://tokyle.com/2019/05/20/centos7%E5%AE%89%E8%A3%85jumpserver%E5%A0%A1%E5%9E%92%E6%9C%BA/"/>
    <id>http://tokyle.com/2019/05/20/centos7安装jumpserver堡垒机/</id>
    <published>2019-05-20T09:11:18.000Z</published>
    <updated>2019-05-21T02:32:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>centos7安装jumpserver堡垒机</p><a id="more"></a><h3 id="Jumpserver"><a href="#Jumpserver" class="headerlink" title="Jumpserver"></a>Jumpserver</h3><p>jumpserver是一款常用的开源堡垒机方案，基于python+django，适合上手，安装需要确保python3环境</p><blockquote><p><a href="http://tokyle.com/%2F2018%2F04%2F20%2FCentos%E4%B8%8B%E5%8D%87%E7%BA%A7python2-7%E5%88%B03-6%2F">centos7下python2和python3共存</a></p></blockquote><h3 id="安装jumpserver"><a href="#安装jumpserver" class="headerlink" title="安装jumpserver"></a>安装jumpserver</h3><h4 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line"></span><br><span class="line">git clone --depth=1 https://github.com/jumpserver/jumpserver.git</span><br></pre></td></tr></table></figure><h4 id="安装RPM包"><a href="#安装RPM包" class="headerlink" title="安装RPM包"></a>安装RPM包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/jumpserver/requirements</span><br><span class="line"></span><br><span class="line">yum -y install `cat rpm_requirements.txt`</span><br></pre></td></tr></table></figure><h4 id="安装python库依赖"><a href="#安装python库依赖" class="headerlink" title="安装python库依赖"></a>安装python库依赖</h4><p><strong>tip: </strong> 安装pip，实际可以使用pip3安装依赖<br>安装pip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装epel扩展源</span><br><span class="line">yum -y install epel-release</span><br><span class="line"></span><br><span class="line"># 安装pip</span><br><span class="line">yum -y install python-pip</span><br><span class="line"></span><br><span class="line"># 清楚cache</span><br><span class="line">yum clean all</span><br></pre></td></tr></table></figure></p><p><strong>安装依赖</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure></p><h4 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h4><p>使用redis作为cache和celery broke<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install redis</span><br><span class="line"></span><br><span class="line">systemctl enable redis</span><br><span class="line"></span><br><span class="line">systemctl start redis</span><br></pre></td></tr></table></figure></p><h4 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h4><p>这边使用的是MySQL，安装教程就不写了，很简单，创建jumpserver库和用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create database jumpserver  character set utf8;</span><br><span class="line"></span><br><span class="line">create user jumpserver@&apos;%&apos; identified by &apos;pwd&apos;;</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;jumpserver&apos;@&apos;%&apos; IDENTIFIED BY &apos;pwd&apos; WITH GRANT OPTION;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure></p><h4 id="修改jumpserver配置文件"><a href="#修改jumpserver配置文件" class="headerlink" title="修改jumpserver配置文件"></a>修改jumpserver配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/jumpserver</span><br><span class="line"></span><br><span class="line">cp config_example.yml config.yml</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 生成随机SECRET_KEY</span><br><span class="line">SECRET_KEY=`cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 50`</span><br><span class="line"></span><br><span class="line">echo &quot;SECRET_KEY=$SECRET_KEY&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line"># 生成随机BOOTSTRAP_TOKEN</span><br><span class="line">BOOTSTRAP_TOKEN=`cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 16`</span><br><span class="line"></span><br><span class="line">echo &quot;BOOTSTRAP_TOKEN=$BOOTSTRAP_TOKEN&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/SECRET_KEY:/SECRET_KEY: $SECRET_KEY/g&quot; /opt/jumpserver/config.yml</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/BOOTSTRAP_TOKEN:/BOOTSTRAP_TOKEN: $BOOTSTRAP_TOKEN/g&quot; /opt/jumpserver/config.yml</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/# DEBUG: true/DEBUG: false/g&quot; /opt/jumpserver/config.yml</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/# LOG_LEVEL: DEBUG/LOG_LEVEL: ERROR/g&quot; /opt/jumpserver/config.yml</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/# SESSION_EXPIRE_AT_BROWSER_CLOSE: false/SESSION_EXPIRE_AT_BROWSER_CLOSE: true/g&quot; /opt/jumpserver/config.yml</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/DB_PASSWORD: /DB_PASSWORD: $DB_PASSWORD/g&quot; /opt/jumpserver/config.yml</span><br></pre></td></tr></table></figure><p>查看SECRET_KEY和BOOTSTRAP_TOKEN<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.bashrc</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">echo -e &quot;\033[31m 你的SECRET_KEY是 $SECRET_KEY \033[0m&quot;</span><br><span class="line">echo -e &quot;\033[31m 你的BOOTSTRAP_TOKEN是 $BOOTSTRAP_TOKEN \033[0m&quot;</span><br></pre></td></tr></table></figure></p><p>人工确认修改没有问题：<code>vim /opt/jumpserver/config.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># SECURITY WARNING: keep the secret key used in production secret!</span><br><span class="line"># 加密秘钥 生产环境中请修改为随机字符串，请勿外泄, 可使用命令生成 </span><br><span class="line"># $ cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 49;echo</span><br><span class="line">SECRET_KEY: </span><br><span class="line"></span><br><span class="line"># SECURITY WARNING: keep the bootstrap token used in production secret!</span><br><span class="line"># 预共享Token coco和guacamole用来注册服务账号，不在使用原来的注册接受机制</span><br><span class="line">BOOTSTRAP_TOKEN: </span><br><span class="line"></span><br><span class="line"># Development env open this, when error occur display the full process track, Production disable it</span><br><span class="line"># DEBUG 模式 开启DEBUG后遇到错误时可以看到更多日志</span><br><span class="line">DEBUG: false</span><br><span class="line"></span><br><span class="line"># DEBUG, INFO, WARNING, ERROR, CRITICAL can set. See https://docs.djangoproject.com/en/1.10/topics/logging/</span><br><span class="line"># 日志级别</span><br><span class="line">LOG_LEVEL: ERROR</span><br><span class="line"># LOG_DIR: </span><br><span class="line"></span><br><span class="line"># Session expiration setting, Default 24 hour, Also set expired on on browser close</span><br><span class="line"># 浏览器Session过期时间，默认24小时, 也可以设置浏览器关闭则过期</span><br><span class="line"># SESSION_COOKIE_AGE: 86400</span><br><span class="line">SESSION_EXPIRE_AT_BROWSER_CLOSE: true</span><br><span class="line"></span><br><span class="line"># Database setting, Support sqlite3, mysql, postgres ....</span><br><span class="line"># 数据库设置</span><br><span class="line"># See https://docs.djangoproject.com/en/1.10/ref/settings/#databases</span><br><span class="line"></span><br><span class="line"># SQLite setting:</span><br><span class="line"># 使用单文件sqlite数据库</span><br><span class="line"># DB_ENGINE: sqlite3</span><br><span class="line"># DB_NAME: </span><br><span class="line"></span><br><span class="line"># MySQL or postgres setting like:</span><br><span class="line"># 使用Mysql作为数据库</span><br><span class="line">DB_ENGINE: mysql</span><br><span class="line">DB_HOST: 127.0.0.1</span><br><span class="line">DB_PORT: 3306</span><br><span class="line">DB_USER: jumpserver</span><br><span class="line">DB_PASSWORD: </span><br><span class="line">DB_NAME: jumpserver</span><br><span class="line"></span><br><span class="line"># When Django start it will bind this host and port</span><br><span class="line"># ./manage.py runserver 127.0.0.1:8080</span><br><span class="line"># 运行时绑定端口</span><br><span class="line">HTTP_BIND_HOST: 0.0.0.0</span><br><span class="line">HTTP_LISTEN_PORT: 8080</span><br><span class="line"></span><br><span class="line"># Use Redis as broker for celery and web socket</span><br><span class="line"># Redis配置</span><br><span class="line">REDIS_HOST: 127.0.0.1</span><br><span class="line">REDIS_PORT: 6379</span><br><span class="line"># REDIS_PASSWORD: </span><br><span class="line"># REDIS_DB_CELERY: 3</span><br><span class="line"># REDIS_DB_CACHE: 4</span><br><span class="line"></span><br><span class="line"># Use OpenID authorization</span><br><span class="line"># 使用OpenID 来进行认证设置</span><br><span class="line"># BASE_SITE_URL: http://localhost:8080</span><br><span class="line"># AUTH_OPENID: false  # True or False</span><br><span class="line"># AUTH_OPENID_SERVER_URL: https://openid-auth-server.com/</span><br><span class="line"># AUTH_OPENID_REALM_NAME: realm-name</span><br><span class="line"># AUTH_OPENID_CLIENT_ID: client-id</span><br><span class="line"># AUTH_OPENID_CLIENT_SECRET: client-secret</span><br><span class="line">#</span><br><span class="line"># Use Radius authorization</span><br><span class="line"># 使用Radius来认证</span><br><span class="line"># AUTH_RADIUS: false</span><br><span class="line"># RADIUS_SERVER: localhost</span><br><span class="line"># RADIUS_PORT: 1812</span><br><span class="line"># RADIUS_SECRET: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># OTP settings</span><br><span class="line"># OTP/MFA 配置</span><br><span class="line"># OTP_VALID_WINDOW: 0</span><br><span class="line"># OTP_ISSUER_NAME: Jumpserver</span><br></pre></td></tr></table></figure></p><h4 id="运行Jumpserver"><a href="#运行Jumpserver" class="headerlink" title="运行Jumpserver"></a>运行Jumpserver</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/jumpserver</span><br><span class="line"></span><br><span class="line"># 后台运行</span><br><span class="line">./jms start all -d</span><br><span class="line"></span><br><span class="line"># 其他命令</span><br><span class="line">./jms start|stop|status all</span><br></pre></td></tr></table></figure><h3 id="安装SSH-Server和-WebSocket-Server：Coco"><a href="#安装SSH-Server和-WebSocket-Server：Coco" class="headerlink" title="安装SSH Server和 WebSocket Server：Coco"></a>安装SSH Server和 WebSocket Server：Coco</h3><h4 id="clone项目"><a href="#clone项目" class="headerlink" title="clone项目"></a>clone项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth=1 https://github.com/jumpserver/coco.git</span><br></pre></td></tr></table></figure><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/coco/requirements</span><br><span class="line"></span><br><span class="line">yum -y install $(cat rpm_requirements.txt)</span><br><span class="line"></span><br><span class="line">pip3 install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/coco/</span><br><span class="line"></span><br><span class="line">cp config_example.yml config.yml</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/BOOTSTRAP_TOKEN: &lt;PleasgeChangeSameWithJumpserver&gt;/BOOTSTRAP_TOKEN: $BOOTSTRAP_TOKEN/g&quot; /opt/coco/config.yml</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/# LOG_LEVEL: INFO/LOG_LEVEL: ERROR/g&quot; /opt/coco/config.yml</span><br></pre></td></tr></table></figure><p><code>vim  /opt/coco/config.yml</code></p><h4 id="启coco"><a href="#启coco" class="headerlink" title="启coco"></a>启coco</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 后台启动</span><br><span class="line">./cocod start -d</span><br><span class="line"></span><br><span class="line"># 更多命令</span><br><span class="line">./cocod start|stop|statu</span><br></pre></td></tr></table></figure><h3 id="安装Web-Terminal-前端-Luna"><a href="#安装Web-Terminal-前端-Luna" class="headerlink" title="安装Web Terminal 前端: Luna"></a>安装Web Terminal 前端: Luna</h3><p>直接下载解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget https://github.com/jumpserver/luna/releases/download/1.4.10/luna.tar.gz</span><br><span class="line"></span><br><span class="line">#如果网络有问题导致下载无法完成可以使用下面地址</span><br><span class="line">wget https://demo.jumpserver.org/download/luna/1.4.10/luna.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf luna.tar.gz</span><br><span class="line">chown -R root:root luna</span><br></pre></td></tr></table></figure></p><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install yum-utils</span><br><span class="line"></span><br><span class="line"># 配置nginx yum源</span><br><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br></pre></td></tr></table></figure></p><p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line">yum install -y nginx</span><br><span class="line"></span><br><span class="line">mv default.conf default.conf_20190520.bak</span><br><span class="line"></span><br><span class="line"># 修改配置</span><br><span class="line">vim /etc/nginx/conf.d/jumpserver.conf</span><br></pre></td></tr></table></figure></p><p>修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;  # 代理端口, 以后将通过此端口进行访问, 不再通过8080端口</span><br><span class="line">    # server_name demo.jumpserver.org;  # 修改成你的域名或者注释掉</span><br><span class="line"></span><br><span class="line">    client_max_body_size 100m;  # 录像及文件上传大小限制</span><br><span class="line"></span><br><span class="line">    location /luna/ &#123;</span><br><span class="line">        try_files $uri / /index.html;</span><br><span class="line">        alias /opt/luna/;  # luna 路径, 如果修改安装目录, 此处需要修改</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /media/ &#123;</span><br><span class="line">        add_header Content-Encoding gzip;</span><br><span class="line">        root /opt/jumpserver/data/;  # 录像位置, 如果修改安装目录, 此处需要修改</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /static/ &#123;</span><br><span class="line">        root /opt/jumpserver/data/;  # 静态资源, 如果修改安装目录, 此处需要修改</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /socket.io/ &#123;</span><br><span class="line">        proxy_pass       http://localhost:5000/socket.io/;  # 如果coco安装在别的服务器, 请填写它的ip</span><br><span class="line">        proxy_buffering off;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        access_log off;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /coco/ &#123;</span><br><span class="line">        proxy_pass       http://localhost:5000/coco/;  # 如果coco安装在别的服务器, 请填写它的ip</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        access_log off;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /guacamole/ &#123;</span><br><span class="line">        proxy_pass       http://localhost:8081/;  # 如果guacamole安装在别的服务器, 请填写它的ip</span><br><span class="line">        proxy_buffering off;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection $http_connection;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        access_log off;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;  # 如果jumpserver安装在别的服务器, 请填写它的ip</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx</span><br><span class="line"></span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><h4 id="访问jumpserver"><a href="#访问jumpserver" class="headerlink" title="访问jumpserver"></a>访问jumpserver</h4><p>nginx启动后，浏览器访问<code>http:ip:nginx配置的端口</code>即可访问，默认账密<code>admin/admin</code></p><h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><p>如果登录客户端是 macOS 或 Linux, 登录语法如下<br>$ ssh -p2222 admin@192.168.244.144<br>$ sftp -P2222 admin@192.168.244.144<br>密码: admin</p><p>如果登录客户端是 Windows, Xshell Terminal 登录语法如下<br>$ ssh admin@192.168.244.144 2222<br>$ sftp admin@192.168.244.144 2222<br>密码: admin<br>如果能登陆代表部署成功</p><p>以上，完~</p><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><blockquote><p><a href="http://docs.jumpserver.org/zh/docs/setup_by_centos.html" target="_blank" rel="noopener">官方安装指导</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;centos7安装jumpserver堡垒机&lt;/p&gt;
    
    </summary>
    
      <category term="Devops" scheme="http://tokyle.com/categories/Devops/"/>
    
    
      <category term="Centos7" scheme="http://tokyle.com/tags/Centos7/"/>
    
      <category term="Jumpserver" scheme="http://tokyle.com/tags/Jumpserver/"/>
    
  </entry>
  
  <entry>
    <title>几个linux命令小技巧</title>
    <link href="http://tokyle.com/2019/05/15/%E5%87%A0%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://tokyle.com/2019/05/15/几个linux命令小技巧/</id>
    <published>2019-05-16T01:36:27.000Z</published>
    <updated>2019-05-16T01:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>一些Linux技巧型命令</p><a id="more"></a><p>可能不是太常用，算是可以提高效率的一点点方式，简单实践了一下。</p><h3 id="光标类"><a href="#光标类" class="headerlink" title="光标类"></a>光标类</h3><p>不同于vi/vim下的<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>上下左右移动，这边介绍的是普通模式下的光标移动。</p><h4 id="删除从行开头到光标处的命令"><a href="#删除从行开头到光标处的命令" class="headerlink" title="删除从行开头到光标处的命令"></a>删除从行开头到光标处的命令</h4><p><code>ctrl + u</code><br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /home/;ll光标处</span><br></pre></td></tr></table></figure></p><p>按下<code>ctrl+u</code>，会将<code>cd /home/;ll</code>该行删除</p><h4 id="删除从光标到结尾处的命令"><a href="#删除从光标到结尾处的命令" class="headerlink" title="删除从光标到结尾处的命令"></a>删除从光标到结尾处的命令</h4><p><code>ctrl + k</code><br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /home/;光标处ll</span><br></pre></td></tr></table></figure></p><p>按下<code>ctrl+k</code>，会将<code>ll</code>删除</p><h4 id="删除一个词（空格隔开的字符串）"><a href="#删除一个词（空格隔开的字符串）" class="headerlink" title="删除一个词（空格隔开的字符串）"></a>删除一个词（空格隔开的字符串）</h4><p><code>ctrl + w</code><br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -al光标处</span><br></pre></td></tr></table></figure></p><p>按下<code>ctrl w</code>，会将<code>-al</code>删除</p><h3 id="资源查看"><a href="#资源查看" class="headerlink" title="资源查看"></a>资源查看</h3><h4 id="各目录子目录占用空间大小"><a href="#各目录子目录占用空间大小" class="headerlink" title="各目录子目录占用空间大小"></a>各目录子目录占用空间大小</h4><p>tips: <strong>-h参数会将结果展示为人类可读的方式，所以结果会加上M、G这样的单位</strong></p><p>查看当前磁盘占用情况，这个都知道<code>df -h</code><br>查看目录各子目录占用空间大小，例如查看<code>/home</code>下各子目录空间大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# du -h --max-depth=1 /home/</span><br><span class="line">91M/home/ngrinder</span><br><span class="line">0/home/docker</span><br><span class="line">143M/home/</span><br></pre></td></tr></table></figure></p><p>查看内存情况：<code>free -h</code></p><h3 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h3><h4 id="获取pid"><a href="#获取pid" class="headerlink" title="获取pid"></a>获取pid</h4><p>很多时候，我们需要查看运行进行的PID，无论是进行分析还是杀进程。。以前的常用做法是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep zabbix_server</span><br></pre></td></tr></table></figure></p><p>这样，拿到<code>zabbix_server</code>这个进程的PID，同时会输出一堆信息，如果我们只想要一个pid，也有办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pgrep zabbix_server</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">pidof zabbix_server</span><br></pre></td></tr></table></figure></p><h4 id="杀进程"><a href="#杀进程" class="headerlink" title="杀进程"></a>杀进程</h4><p>之前杀进程，比较常用的就是<code>ps -ef|grep XX</code>拿到pid，然后kill掉，或者写的复杂点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 `ps -ef | grep zabbix | grep -v grep | awk &apos;&#123;print $2&#125;&apos;`</span><br></pre></td></tr></table></figure></p><p>现在有比较简单的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill zabbix</span><br></pre></td></tr></table></figure></p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="清空文件内容"><a href="#清空文件内容" class="headerlink" title="清空文件内容"></a>清空文件内容</h4><p>之前清空日志文件的内容，一直很头疼，文件太大根本进不去，sed和awk又没那么熟练，现在找到个比较快捷的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;zabbix_server.log</span><br></pre></td></tr></table></figure></p><p>完成清空<br>效果展示：<br>清空前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost zabbix]# ll</span><br><span class="line">total 108</span><br><span class="line">-rw-rw-r-- 1 zabbix zabbix 50071 May 16 08:55 zabbix_server.log</span><br></pre></td></tr></table></figure></p><p>清空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost zabbix]# &gt;zabbix_server.log</span><br><span class="line"></span><br><span class="line">[root@localhost zabbix]# ll</span><br><span class="line">total 56</span><br><span class="line">-rw-rw-r-- 1 zabbix zabbix     0 May 16 08:57 zabbix_server.log</span><br></pre></td></tr></table></figure></p><p>linux是个非常有意思的系统啊，有事没事多多研究<code>grep</code>、<code>sed</code>、<code>awk</code>以及<code>vi/vim</code>啊！</p><p>以上，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些Linux技巧型命令&lt;/p&gt;
    
    </summary>
    
      <category term="skill" scheme="http://tokyle.com/categories/skill/"/>
    
    
      <category term="Linux" scheme="http://tokyle.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>centos7安装docker</title>
    <link href="http://tokyle.com/2019/05/14/centos7%E5%AE%89%E8%A3%85docker/"/>
    <id>http://tokyle.com/2019/05/14/centos7安装docker/</id>
    <published>2019-05-14T06:21:34.000Z</published>
    <updated>2019-05-14T06:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Centos7安装docker</p><a id="more"></a><p>容器化大潮，微服务最后一里路，至少掌握docker的基本使用</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>查看内核版本，大于3.10才能安装</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p><code>更新yum源</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><p><code>卸载旧版本</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker docker-common docker-selinux docker-engine -y</span><br></pre></td></tr></table></figure><p><code>安装需要的安装包</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p><code>配置yum源（防止万里长城，配置阿里yum源）</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><code>查看可选择版本</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p><code>安装最新稳定版（repo中默认开启了stable仓库）</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><p><code>或者指定版本</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce-18.06.3.ce</span><br></pre></td></tr></table></figure><p><code>启动并加自启动</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p><code>验证</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:           18.09.6</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.10.8</span><br><span class="line"> Git commit:        481bc77156</span><br><span class="line"> Built:             Sat May  4 02:34:58 2019</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.6</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.8</span><br><span class="line">  Git commit:       481bc77</span><br><span class="line">  Built:            Sat May  4 02:02:43 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br></pre></td></tr></table></figure></p><p>有client和server表示安装成功</p><p>本篇算是容器化的第一篇，计划后续好好折腾折腾docker和K8S，去年欠下的，要补回来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Centos7安装docker&lt;/p&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="Centos7" scheme="http://tokyle.com/tags/Centos7/"/>
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>修改Linux时间</title>
    <link href="http://tokyle.com/2019/04/28/%E4%BF%AE%E6%94%B9Linux%E6%97%B6%E9%97%B4/"/>
    <id>http://tokyle.com/2019/04/28/修改Linux时间/</id>
    <published>2019-04-28T05:37:01.000Z</published>
    <updated>2019-04-28T05:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>linux修改系统时间</p><a id="more"></a><h3 id="手动修改"><a href="#手动修改" class="headerlink" title="手动修改"></a>手动修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s 04/28/19</span><br></pre></td></tr></table></figure><p>修改日期为：2019/04/28</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s 11:28:00</span><br></pre></td></tr></table></figure><p>修改时间为11:28:00</p><p>或者一次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s &quot;2019-04-28 11:28:00&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock -w</span><br></pre></td></tr></table></figure><p>将时间写入bios避免重启失效</p><h3 id="同步网络时间"><a href="#同步网络时间" class="headerlink" title="同步网络时间"></a>同步网络时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ntp</span><br></pre></td></tr></table></figure><p>ntp常用服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">中国国家授时中心：210.72.145.44</span><br><span class="line">NTP服务器(上海) ：ntp.api.bz</span><br><span class="line">美国：time.nist.gov </span><br><span class="line">复旦：ntp.fudan.edu.cn </span><br><span class="line">微软公司授时主机(美国) ：time.windows.com </span><br><span class="line">台警大授时中心(台湾)：asia.pool.ntp.org</span><br></pre></td></tr></table></figure></p><h4 id="同步时间："><a href="#同步时间：" class="headerlink" title="同步时间："></a>同步时间：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate -dv ntp.api.bz</span><br></pre></td></tr></table></figure><p>同步完成之后，发现时间有点不对，12h误差<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# date</span><br><span class="line">Sun Apr 28 01:20:14 EDT 2019</span><br></pre></td></tr></table></figure></p><p>查了下，<code>EDT</code>是美国东部时间，需要改成北京时间</p><h3 id="时区修改"><a href="#时区修改" class="headerlink" title="时区修改"></a>时区修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/localtime /etc/localtime.bak </span><br><span class="line"></span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime </span><br><span class="line"></span><br><span class="line">date</span><br></pre></td></tr></table></figure><p>完成~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux修改系统时间&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://tokyle.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux" scheme="http://tokyle.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter调用python完成HmacSHA256加密处理</title>
    <link href="http://tokyle.com/2019/04/23/Jmeter%E8%B0%83%E7%94%A8python%E5%AE%8C%E6%88%90HmacSHA256%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86/"/>
    <id>http://tokyle.com/2019/04/23/Jmeter调用python完成HmacSHA256加密处理/</id>
    <published>2019-04-23T07:18:16.000Z</published>
    <updated>2019-04-23T07:24:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Jmeter调用python完成HmacSHA256加密处理</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>同事有个需求，一个获取人员信息的接口，请求头里面需要有一个<code>sign</code>参数，这个参数是几个实时获取的参数最后进行Hmachash256加密之后生成的，具体示例：<br>获取用户接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://192.168.0.1/api/user?userName=20190101&amp;tenant=testtenant</span><br></pre></td></tr></table></figure></p><p>请求头：</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>Authorization</td><td>Bearer ${token}</td></tr><tr><td>content-type</td><td>application/json</td></tr><tr><td>tenant</td><td>testtenant</td></tr><tr><td>timestamp</td><td>当前时间戳</td></tr><tr><td>randoms</td><td>随机数</td></tr><tr><td>sign</td><td>签名</td></tr></tbody></table><p>其中签名生成规则如下：<br><code>tenanttesttenantuserName20190101tenanttesttenanttimestamp当前时间戳randoms随机数</code><br>这一长串再使用指定密码，进行<strong>HmacSHA256</strong>加密，生成的密文即为<code>sign</code></p><blockquote><p><a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">加密工具</a></p></blockquote><h3 id="jmeter方案"><a href="#jmeter方案" class="headerlink" title="jmeter方案"></a>jmeter方案</h3><p>因为后期接口要进行性能测试，所以还是选了jmeter进行性能测试，按照接口描述的先排序再加密，在jmeter中，首先想到的就是通过<code>beanshell</code>外部实现，然后生成对应jar包，在jmeter中引用，然后就有个问题，我java太菜了。。。没办法，折腾python。</p><h4 id="jmeter中使用python脚本"><a href="#jmeter中使用python脚本" class="headerlink" title="jmeter中使用python脚本"></a>jmeter中使用python脚本</h4><p>在jmeter中使用python脚本，搜了下，找到三种方式：<br><strong>1</strong>. 使用Jython包 </p><blockquote><p><a href="https://www.jython.org/downloads.html" target="_blank" rel="noopener">下载地址</a><br>下载 <code>Download Jython 2.7.0 - Standalone Jar</code> 包，放到jmeter/lib/目录下，重启jmeter，就能在<code>sampler</code>中找到<code>JSR223 Sampler</code>，里面就有python，但是，是python2.7，所以，对我没啥用</p></blockquote><p><strong>2</strong>. jmeter-functions-execute-python-script-1.0.jar，网上有个这个包，可以从函数助手那边进去执行python脚本，试了下失败了，就不介绍了，有兴趣可以百度下咋弄</p><p><strong>3</strong>. <strong>OS Process Sampler</strong>，使用这个组件可以执行脚本，后面着重介绍这个，使用了下，很强的组件，理论上，只要你脚本能力强，可以获得各种想要的（终于看到摆脱java的希望了。。）</p><h4 id="OS-Process-Sampler"><a href="#OS-Process-Sampler" class="headerlink" title="OS Process Sampler"></a>OS Process Sampler</h4><p>这个组件可以用来启动一个可执行程序，由于是通过命令行方式启动，所以我们可以用任何语言编写一个测试用的可执行程序(比如Linux的sh脚本)。在该可执行程序中调用我们的接口，并把返回的原始数据输出而交由JMeter做后续解析判断。</p><p>位置：<code>/sampler/OS Process Sampler</code><br>这个组件有几栏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command: 可执行文件（windows系统建议放.bat脚本或exe文件，linux系统放shell；干过windows下放了shell直接报非可执行文件。。）</span><br><span class="line"></span><br><span class="line">working directory：工作目录，默认是jmeterbin 目录，可指定</span><br><span class="line">command parameters：参数，如果脚本需要传参，可在这边传</span><br></pre></td></tr></table></figure></p><p>既然这个组件可以执行bat文件，那我们在bat文件里面再调python文件不就实现了嘛~</p><h3 id="加密实现"><a href="#加密实现" class="headerlink" title="加密实现"></a>加密实现</h3><p>前面说了，思路就是使用<code>OS Process Sampler</code>来调用<code>.bat</code>文件，然后在<code>.bat</code>文件中再调python文件，实现加密，脚本如下：</p><h4 id="jmeter"><a href="#jmeter" class="headerlink" title="jmeter"></a>jmeter</h4><p>OS Process Sampler中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command: oss.bat路径</span><br><span class="line"></span><br><span class="line">working directory：默认</span><br><span class="line">command parameters：secret，userName，tenant（三个传参，方便参数化）</span><br></pre></td></tr></table></figure></p><p>同时，在<code>OS Process Sampler</code>后追加三个正则表达式提取器，分别获取<strong>时间戳</strong>，<strong>随机数</strong>，<strong>签名</strong></p><p>正则表达式提取器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">引用名称：sign</span><br><span class="line">正则表达式：sign:(.+?)&lt;&gt;</span><br><span class="line">模板：$1$</span><br><span class="line">匹配数字: 1</span><br></pre></td></tr></table></figure></p><p>时间戳和随机数相同方式获取</p><h4 id="oss-bat"><a href="#oss-bat" class="headerlink" title="oss.bat"></a>oss.bat</h4><p>oss.bat:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set secret = %1</span><br><span class="line">set userName = %2</span><br><span class="line">set tenant = %3</span><br><span class="line"></span><br><span class="line">python  E:\py_workspace\hashtest\JmeterSSTest.py  %*</span><br></pre></td></tr></table></figure></p><p>Windows批处理文件，首先获取传进去的三个参数，再将这三个参数作为入参传给python脚本</p><h4 id="JmeterSSTest-py"><a href="#JmeterSSTest-py" class="headerlink" title="JmeterSSTest.py"></a>JmeterSSTest.py</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*-coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: kyle</span><br><span class="line">@time: 2019/4/23 12:44</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import hashlib</span><br><span class="line">import hmac</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># 定义传参，按顺序，secret,userName,tenant</span><br><span class="line">secret = sys.argv[1]</span><br><span class="line">userName = sys.argv[2]</span><br><span class="line">tenant = sys.argv[3]</span><br><span class="line"></span><br><span class="line"># 获取当前时间戳</span><br><span class="line">timestamp = int(time.time())</span><br><span class="line"></span><br><span class="line"># 获取随机数</span><br><span class="line">randoms = random.randint(0, 999999999)</span><br><span class="line"></span><br><span class="line"># 获取sign</span><br><span class="line">strsign = str(u&apos;tenant&apos; + str(tenant) + u&apos;userName&apos; + str(userName) + u&apos;tenant&apos; + str(tenant) +</span><br><span class="line">               u&apos;timestamp&apos; + str(timestamp) + u&apos;randoms&apos; + str(randoms))</span><br><span class="line"></span><br><span class="line"># hmacsha256加密</span><br><span class="line">intsign = hmac.new(bytes(str(secret), encoding=&apos;utf-8&apos;), bytes(str(strsign), encoding=&apos;utf-8&apos;),</span><br><span class="line">                    digestmod=hashlib.sha256).digest()</span><br><span class="line"></span><br><span class="line"># 二进制转义</span><br><span class="line">sign = intsign.hex()</span><br><span class="line"></span><br><span class="line">print(u&apos;timestamp&apos; + &apos;:&apos; + str(timestamp) + &apos;&lt;&gt;&apos;)</span><br><span class="line">print(u&apos;randoms&apos; + &apos;:&apos; + str(randoms) + &apos;&lt;&gt;&apos;)</span><br><span class="line">print(u&apos;sign&apos; + &apos;:&apos; + str(sign) + &apos;&lt;&gt;&apos;)</span><br></pre></td></tr></table></figure><p>脚本就不解释了，不难</p><h3 id="完整jmeter结构"><a href="#完整jmeter结构" class="headerlink" title="完整jmeter结构"></a>完整jmeter结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 获取token接口（简单控制器）</span><br><span class="line">-- http信息头管理器</span><br><span class="line">    -- http请求</span><br><span class="line">    -- 响应断言</span><br><span class="line">    --查看结果树</span><br><span class="line">    -- JSON Extractor</span><br><span class="line">-- 加密sign</span><br><span class="line">   -- OS Process Sampler</span><br><span class="line">     -- 正则提取 timestamp</span><br><span class="line">     -- 正则提取 randoms</span><br><span class="line">     -- 正则提取 sign</span><br><span class="line">-- 获取用户接口</span><br><span class="line">   -- http信息头管理器</span><br><span class="line">   -- http请求</span><br><span class="line">   -- 查看结果树</span><br><span class="line">   -- 响应断言</span><br></pre></td></tr></table></figure><p>以上，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jmeter调用python完成HmacSHA256加密处理&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="jmeter" scheme="http://tokyle.com/tags/jmeter/"/>
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
      <category term="HmacSHA256" scheme="http://tokyle.com/tags/HmacSHA256/"/>
    
  </entry>
  
  <entry>
    <title>Android性能测试——内存</title>
    <link href="http://tokyle.com/2019/04/18/Android%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/"/>
    <id>http://tokyle.com/2019/04/18/Android性能测试——内存/</id>
    <published>2019-04-18T09:06:22.000Z</published>
    <updated>2019-04-18T09:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android性能测试——内存</p><a id="more"></a><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>通常情况下我们说的内存都是指手机的RAM，RAM主要包括：</p><ul><li>寄存器：速度最快的存储</li><li>栈（stack）：在jvm中栈用来存储一些对象的引用、局部变量以及计算过程的中间数据，在方法退出后那么这些变量也会被销毁。它的存储比堆快得多，只比CPU里的寄存器慢</li><li>堆（Heap）：用来存储程序中的一些对象，比如你用new关键字创建的对象，它就会被存储在堆内存中，但是这个对象在堆内存中的首地址会存储在栈中；堆中分配的内存，由java虚拟机自动垃圾回收器（GC）来管理。<br>关于GC的，记得之前稍微记过点<a href="http://tokyle.com/%2F2018%2F11%2F02%2FJVM%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%2F">JVM内存性能问题定位</a></li><li>… …</li></ul><h3 id="Dalvik和JVM"><a href="#Dalvik和JVM" class="headerlink" title="Dalvik和JVM"></a>Dalvik和JVM</h3><p>Davlik虚拟机（DVM）是Android系统在java虚拟机（JVM）基础上优化得到的，DVM是基于寄存器的，而JVM是基于栈的，由于寄存器更高效，DVM性能相比JVM要好一点。</p><h3 id="Android中进程的堆内存"><a href="#Android中进程的堆内存" class="headerlink" title="Android中进程的堆内存"></a>Android中进程的堆内存</h3><p>RAM作为进程运行不可或缺的资源，对Android系统性能和稳定性有着决定性影响，RAM的一部分被操作系统留作他用，比如显存等等，当然这个程序员无法干预，我们也不必过多地关注它。进程空间中的heap空间是我们需要重点关注的。heap空间完全由程序员控制，我们使用的C++ new和java new所申请的空间都是heap空间， C/C++申请的内存空间在native heap中，而java申请的内存空间则在dalvik heap中。</p><h3 id="Android的java程序为什么容易OOM"><a href="#Android的java程序为什么容易OOM" class="headerlink" title="Android的java程序为什么容易OOM"></a>Android的java程序为什么容易OOM</h3><p>这个是因为Android系统对dalvik的vmheapsize作了硬性限制，当java进程申请的java空间超过阈值时，就会抛出OOM异常（这个阈值可以是48M、24M、16M等，视机型而定），可以通过adb shell getprop | grep dalvik.vm.heapgrowthlimit查看此值。也就是说，程序发生OMM并不表示RAM不足，而是因为程序申请的java heap对象超过了dalvik vmheapgrowthlimit。也就是说，在RAM充足的情况下，也可能发生OOM。</p><p>这样的设计似乎有些不合理，但是Google为什么这样做呢？这样设计的目的是为了让Android系统能同时让比较多的进程常驻内存，这样程序启动时就不用每次都重新加载到内存，能够给用户更快的响应。迫使每个应用程序使用较小的内存，移动设备非常有限的RAM就能使比较多的app常驻其中。但是有一些大型应用程序是无法忍受vmheapgrowthlimit的限制的</p><p>实际上<code>dalvik.vm.heapgrowthlimit</code>和<code>dalvik.vm.heapsize</code>都是java虚拟机的最大内存限制，应用如果不想在dalvikheap达到heapgrowthlimit限制的时候出现OOM，需要在Manifest中的application标签中声明<code>android:largeHeap=“true”</code>，声明后应用dalvik heap达到heapsize的时候才会出现OOM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; adb shell getprop | grep dalvik.vm.heapgrowthlimit</span><br><span class="line">[dalvik.vm.heapgrowthlimit]: [192m]</span><br><span class="line"></span><br><span class="line">&#123;lamb&#125; adb shell getprop | grep dalvik.vm.heapsize</span><br><span class="line">[dalvik.vm.heapsize]: [512m]</span><br></pre></td></tr></table></figure><h3 id="Android内存采集"><a href="#Android内存采集" class="headerlink" title="Android内存采集"></a>Android内存采集</h3><p><strong>dumpsys</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; adb shell dumpsys meminfo com.kuaikan.comic                                                                 </span><br><span class="line">Applications Memory Usage (in Kilobytes):                                                                          </span><br><span class="line">Uptime: 467997959 Realtime: 2137774428                                                                             </span><br><span class="line">** MEMINFO in pid 15956 [com.kuaikan.comic] **                                                                     </span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap                                       </span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free                                       </span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------                                       </span><br><span class="line">  Native Heap    98778    98668       64      406   127872   120081     7790                                       </span><br><span class="line">  Dalvik Heap     8247     8204       24       52    20111     7823    12288                                       </span><br><span class="line"> Dalvik Other     2505     2496        4        2                                                                  </span><br><span class="line">        Stack     2464     2464        0        0  </span><br><span class="line">       Ashmem      258      256        0        0   </span><br><span class="line">      Gfx dev    24048    23372      676        0  </span><br><span class="line">    Other dev       45        8       28        0  </span><br><span class="line">     .so mmap     4157     2036      716       26  </span><br><span class="line">    .jar mmap        8        8        0        0  </span><br><span class="line">    .apk mmap     9900     9676      160        0  </span><br><span class="line">    .dex mmap    20863    17524     2380        0  </span><br><span class="line">    .oat mmap     2731        0      384        0  </span><br><span class="line">    .art mmap     8290     6736      148       12   </span><br><span class="line">   Other mmap       29        4        0        0                                                                  </span><br><span class="line">   EGL mtrack    38636    38636        0        0                                                                  </span><br><span class="line">    GL mtrack     5480     5480        0        0   </span><br><span class="line">      Unknown     6031     6016        0        3  </span><br><span class="line">        TOTAL   232971   221584     4584      501   147983   127904    20078  </span><br><span class="line"> App Summary                                                                                                       </span><br><span class="line">                       Pss(KB)   </span><br><span class="line">                        ------    </span><br><span class="line">           Java Heap:    15088   </span><br><span class="line">         Native Heap:    98668    </span><br><span class="line">                Code:    32884   </span><br><span class="line">               Stack:     2464    </span><br><span class="line">            Graphics:    68164   </span><br><span class="line">       Private Other:     8900   </span><br><span class="line">              System:     6803     </span><br><span class="line">               TOTAL:   232971       TOTAL SWAP PSS:      501   </span><br><span class="line"> Objects                                                                                                           </span><br><span class="line">               Views:      927         ViewRootImpl:        2  </span><br><span class="line">         AppContexts:       11           Activities:        1   </span><br><span class="line">              Assets:        8        AssetManagers:        5    </span><br><span class="line">       Local Binders:       89        Proxy Binders:       42    </span><br><span class="line">       Parcel memory:       56         Parcel count:      226   </span><br><span class="line">    Death Recipients:        5      OpenSSL Sockets:       10  </span><br><span class="line">            WebViews:        0       </span><br><span class="line"> SQL                                                                                                               </span><br><span class="line">         MEMORY_USED:     3886    </span><br><span class="line">  PAGECACHE_OVERFLOW:     1026          MALLOC_SIZE:      309</span><br><span class="line"> DATABASES                                                                                                      </span><br><span class="line">      pgsz     dbsz   Lookaside(b)          cache  Dbname </span><br><span class="line">         4       52            109       54/31/17  /data/user/0/com.kuaikan.comic/databases/bugly_db_    </span><br><span class="line">         4      100             76        83/57/9  /data/user/0/com.kuaikan.comic/databases/kkmh-room.db      </span><br><span class="line">         4       12                         0/0/0    (attached) temp   </span><br><span class="line">         4      100            109      147/26/14  /data/user/0/com.kuaikan.comic/databases/kkmh-room.db (1)       </span><br><span class="line">         4       20             24         1/16/2  /data/user/0/com.kuaikan.comic/databases/ThrowalbeLog.db        </span><br><span class="line">         4      564             88       52/43/25  /data/user/0/com.kuaikan.comic/databases/kkmh.db    </span><br><span class="line">         4       20            109      185/24/10  /data/user/0/com.kuaikan.comic/databases/btechainh.db           </span><br><span class="line">         4       20             45         6/19/5  /data/user/0/com.kuaikan.comic/databases/sharesdk.db            </span><br><span class="line">         4       20             52        23/24/6  /data/user/0/com.kuaikan.comic/databases/aa_in_techain.db       </span><br><span class="line">         4       36             92      106/41/25  /data/user/0/com.kuaikan.comic/databases/techain_d.db           </span><br><span class="line">         4       52             47         2/17/3  /data/user/0/com.kuaikan.comic/databases/volcano_ac_techain.db  </span><br><span class="line">         4       20             29         1/16/2  /data/user/0/com.kuaikan.comic/databases/tracker.db   </span><br><span class="line">         4       60             97         3/21/5  /data/user/0/com.kuaikan.comic/databases/tes_db     </span><br><span class="line">         4       16             52        12/17/5  /storage/emulated/0/Mob/comm/dbs/.dh </span><br><span class="line">         4       20             65        16/19/5  /data/user/0/com.kuaikan.comic/databases/x24_techain_typhoon.db </span><br><span class="line">         4       76             38        54/17/3  /data/user/0/com.kuaikan.comic/databases/com.kuaikan.comic      </span><br><span class="line">         4       28             50         5/18/4  /data/user/0/com.kuaikan.comic/databases/tcyrtsdb.db            </span><br><span class="line">         4       44             80        10/21/7  /data/user/0/com.kuaikan.comic/databases/beacon_tbs_db   </span><br><span class="line">         4       20             26         1/16/2  /data/user/0/com.kuaikan.comic/databases/kk-push </span><br><span class="line"> Asset Allocations                                                                            </span><br><span class="line">    zip:/data/user/0/com.tencent.mm/app_tbs/core_share/res.apk:/resources.arsc: 97K</span><br></pre></td></tr></table></figure><h4 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h4><ul><li><p>私有内存(Dirty and Clean)<br>进程独占内存。也就是进程销毁时可以回收的内存容量。通常private Dirty内存是最重要的部分，因为只被自己进程使用。Dirty内存是已经被修改的内存页，因此必须常驻内存（因为没有swap）；Clean内存是已经映射持久文件使用的内存页（例如正在被执行的代码），因此一段时间不使用的话就可以置换出去。</p></li><li><p>实际使用内存(PSS)<br>将跨进程共享页也加入进来， 进行按比例计算PSS。这样能够比较准确的表示<strong>进程占用的实际物理内存</strong></p></li><li><p>Native Heap Alloc<br>JNI层的内存分配</p></li><li><p>Dalvik Heap Alloc<br>Java层的内存分配</p></li></ul><p>这两个值一直增长，应用程序可能出现了内存泄漏</p><h3 id="测试Android内存"><a href="#测试Android内存" class="headerlink" title="测试Android内存"></a>测试Android内存</h3><p><strong>1.</strong> monkey压力测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p com.kuaikan.comic --ignore-crashes --ignore-timeouts --ignore-security-exceptions  --ignore-native-crashes --pct-touch 70 --pct-motion 25 --pct-majornav 5 -v -v -v --throttle 300 100000</span><br></pre></td></tr></table></figure><p><strong>2.</strong> adb shell dumpsys meminfo监控内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.kuaikan.comic</span><br></pre></td></tr></table></figure><p>如发现内存过大，保存<strong>HPROF文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am dumpheap com.kuaikan.comic /data/local/tmp/1.hprof</span><br></pre></td></tr></table></figure></p><p><strong>3.</strong> 格式化<br><code>D:\dev\android\android-sdk-windows\platform-tools</code>下有个<strong>hprof-conv.exe</strong>工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hprof-conv 1.hprof 2.hprof</span><br></pre></td></tr></table></figure></p><p><strong>4.</strong> 用MAT分析<br><a href="https://pan.baidu.com/s/1mF70g1IyS8wYIuXaNx7vaQ" target="_blank" rel="noopener">MAT度娘盘地址（提取码：jidc）</a></p><h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><h4 id="Android沙盒"><a href="#Android沙盒" class="headerlink" title="Android沙盒"></a>Android沙盒</h4><p>由于Android是建立在Linux系统之上的，所以Android系统继承了Linux的 类Unix继承进程隔离机制与最小权限原则，并且在原有Linux的进程管理基础上对UID的使用做了改进，形成了Android应用的”沙箱“机制。</p><p>普通的Linux中启动的应用通常和登陆用户相关联，同一用户的UID相同。但是Android中给不同的应用都赋予了不同的UID，这样不同的应用将不能相互访问资源。对应用而言，这样会更加封闭，安全。</p><p>在Android系统中，应用（通常）都在一个独立的沙箱中运行，即每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。Dalvik经过优化，允许在有限的内存中同时高效地运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行。Android这种基于Linux的进程“沙箱”机制，是整个安全设计的基础之一。</p><p>简单点说就是在Android的世界中每一个应用相当与一个Linux中的用户，他们相互独立，不能相互共享与访问，（这也就解释了Android系统中为什么需要进程间通信），正是由于沙盒机制的存在最大程度的保护了应用之间的安全，但是也带来了每一个应用所分配的内存大小是有限制的问题。</p><h4 id="获取当前页面activity"><a href="#获取当前页面activity" class="headerlink" title="获取当前页面activity"></a>获取当前页面activity</h4><p>通过<code>adb shell dumpsys window |findstr mCurrent</code>，捕获当前页面的activity<br>通过<code>adb shell dumpsys activity|findstr &quot;realActivity&quot;</code>, 捕获到当前页面的activity</p><h4 id="频繁GC的可能原因"><a href="#频繁GC的可能原因" class="headerlink" title="频繁GC的可能原因"></a>频繁GC的可能原因</h4><ol><li><p>Memory Churn（内存抖动），内存抖动是因为大量的对象被创建又在短时间内马上被释放</p></li><li><p>瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加 Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。</p></li></ol><h3 id="优秀Android博客"><a href="#优秀Android博客" class="headerlink" title="优秀Android博客"></a>优秀Android博客</h3><blockquote><p><a href="https://www.jianshu.com/p/2bceb820b435?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">Android性能优化-详解内存优化来龙去脉</a><br><a href="https://www.jianshu.com/p/0df5ad0d2e6a" target="_blank" rel="noopener">Android性能优化&amp;内存篇</a><br><a href="https://blog.csdn.net/carson_ho/article/details/79549417" target="_blank" rel="noopener">一份详细&amp;全面内存优化指南</a></p></blockquote><p>以上，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android性能测试——内存&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Android" scheme="http://tokyle.com/tags/Android/"/>
    
      <category term="adb" scheme="http://tokyle.com/tags/adb/"/>
    
  </entry>
  
</feed>
