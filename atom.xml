<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>它夏了夏天</title>
  
  <subtitle>生命中有一种遇见，就让它美如行云流水，然后一生去回味。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tokyle.com/"/>
  <updated>2019-07-05T06:12:24.614Z</updated>
  <id>http://tokyle.com/</id>
  
  <author>
    <name>Kyle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python3 MD5加密</title>
    <link href="http://tokyle.com/2019/07/05/python3-MD5%E5%8A%A0%E5%AF%86/"/>
    <id>http://tokyle.com/2019/07/05/python3-MD5加密/</id>
    <published>2019-07-05T06:11:31.000Z</published>
    <updated>2019-07-05T06:12:24.614Z</updated>
    
    <content type="html"><![CDATA[<p>python3 MD5加密</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*-coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: kyle</span><br><span class="line">@time: 2019/7/5 13:09</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"># ZHTTest_f9768ce9e3acd3a743724c8128692d5d_1561529340474_&#123;&quot;searchText&quot;:&quot;吴凯&quot;&#125;</span><br><span class="line"># cd63c0e512a99aeabc73d1e6b9f26cbe</span><br><span class="line"></span><br><span class="line"># m = hashlib.md5(&apos;ZHTTest_f9768ce9e3acd3a743724c8128692d5d_1561529340474_&#123;&quot;searchText&quot;:&quot;吴凯&quot;&#125;&apos;.</span><br><span class="line">#                 encode(encoding=&apos;utf-8&apos;)).hexdigest()</span><br><span class="line"></span><br><span class="line"># 生成13位时间戳</span><br><span class="line">timestamp = int(time.time()*1000)</span><br><span class="line">strs= &apos;ZHTTest_f9768ce9e3acd3a743724c8128692d5d_&apos;</span><br><span class="line"></span><br><span class="line">md5str = strs + str(timestamp) + &apos;_&#123;&quot;searchText&quot;:&quot;吴凯&quot;&#125;&apos;</span><br><span class="line"># print(md5str)</span><br><span class="line"></span><br><span class="line"># 加密</span><br><span class="line">m = hashlib.md5(md5str.encode(encoding=&apos;utf-8&apos;)).hexdigest()</span><br><span class="line"></span><br><span class="line">print(&quot;md5sss:&quot; + m +&quot;&lt;&gt;&quot;)</span><br></pre></td></tr></table></figure><p>在windows下放在英文文件路径下，再创建一个.bat脚本：<code>python xxx.python</code><br>配合Jmeter的<code>OS Process Sampler</code>完成jmeter调用python实现MD5加密，之前写过HmacSHA256加密的</p><blockquote><p><a href="https://tokyle.com/2019/04/23/Jmeter%E8%B0%83%E7%94%A8python%E5%AE%8C%E6%88%90HmacSHA256%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86/">Jmeter调用python完成HmacSHA256加密处理</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python3 MD5加密&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Jmeter" scheme="http://tokyle.com/tags/Jmeter/"/>
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
      <category term="MD5" scheme="http://tokyle.com/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>一些测试杂说</title>
    <link href="http://tokyle.com/2019/07/04/%E4%B8%80%E4%BA%9B%E6%B5%8B%E8%AF%95%E6%9D%82%E8%AF%B4/"/>
    <id>http://tokyle.com/2019/07/04/一些测试杂说/</id>
    <published>2019-07-04T07:00:09.000Z</published>
    <updated>2019-07-04T07:01:00.237Z</updated>
    
    <content type="html"><![CDATA[<p>一些测试杂说</p><a id="more"></a><h3 id="序-软件质量模型"><a href="#序-软件质量模型" class="headerlink" title="序.软件质量模型"></a>序.软件质量模型</h3><p>这段时间越来越不安定，越来越不理解自己当前的工作到底是为了什么，测试人员的产出只是作为一个参考，完全不是准出条件之一，越来越乱和浮躁的环境，充斥着无奈。</p><p>不谈现在的环境，想想测试本身，看看外面的测试现状。</p><p>首先，插个或许觉得不相关的：<code>软件产品质量模型</code>：</p><p>软件产品质量模型六大属性：</p><table><thead><tr><th>Item</th><th>子属性</th></tr></thead><tbody><tr><td>功能性</td><td>适合性、准确性、安全性、功能性的顺从性等</td></tr><tr><td>可靠性</td><td>成熟性、容错性、可恢复性、可靠性的顺从性等</td></tr><tr><td>易用性</td><td>易理解性、易学性、易操作性、易用性的依从性等</td></tr><tr><td>效率</td><td>时间特性、资源利用率、效率的依从性</td></tr><tr><td>可维护性</td><td>可分析性、可修改性、稳定性、可测试性、可维护性的依从性</td></tr><tr><td>可移植性</td><td>适应性、可安装性、共存性、易替换性、可移植性的依从性</td></tr></tbody></table><p>功能性的顺从性（Functionality Compliance）：软件产品符合和该功能相关的标准、规范、规则或特定的能力（如对于一款计算器，计算规则要和数学中相关规则保持一致）</p><p>可靠性的顺从性（Reliability Compliance）：软件产品遵循与可靠性相关的标准、约定或规定的能力（如对于通信类产品，系统的故障率不能高干多少、故障恢复时间不能长于多少等）</p><p>易用性的依从性(Usability Compliance)：软件产品遵循与易用性相关的标准、约定、风格指南（style guide）或法规的能力（如对Windows的计算器来说，在界面设计上模仿实体计算器是易用性依从性的一个体现）</p><p>效率依从性（Efficiency Compliance）： 软件产品遵循与效率相关的标准或约定的能力（如对系统资源的占有率又不能高于多少）</p><p>可维护性的依从性(Maintainability Compliance)：软件产品遵循与维护相关的标准或约定的能力（如软件出现故障时会弹出“XXX遇到问题要关闭”之类的提示）</p><p>可移植性的依从性（Portability Compliance）： 软件产品遵循与可移植性相关的标准或约定的能力（如产品不是针对某款特定的操作系统开发的，需要支持Windows所有操作系统）</p><h3 id="软件测试初衷"><a href="#软件测试初衷" class="headerlink" title="软件测试初衷"></a>软件测试初衷</h3><p>回想软件测试这个活动存在的理由和意义是什么。最简单粗暴的，测试是为了发现bug，人都有思维定式，自己写的逻辑，自己去发现问题，不是很容易，同时，人精力也有限，让开发人员既负责产品研发，又负责质量控制，不是很切实际，因此，测试人员的最重要使命就是把关，产品质量关，确保最终交付给客户的是相对满意的产品（关于质量，不是单纯的靠测试人员就可以保证的，理性的应该知道，产品质量是需要整个团队，整个软件生命周期共同设计，保证）</p><p>关于bug，很明显，bug不是测试人员造成的，很多开发不知道怎么的，就觉得，bug是测试人员造成的，怕不是失了智，这样的开发，建议转行，遇到这样开发的测试，建议深呼吸，抑制住锤人的冲动。bug可能是程序员写出来的，不符合需求的实现。也可能是产品经理错误的想法或者错误概念造成和客户期望不符的需求。当然，是人就都可能犯错误，测试需要关注的，是怎么预防错误的发生，针对需求开始就可能出现的质量问题，最简单的，现在已经盛行的，测试左移，全流程测试，从需求层面就开始介入测试，这也是测试的最佳实践之一，很不幸，国内当前，至少在苏州的大多数，很难。</p><p>同样的，就按我现在所在公司来说，听到的很多抱怨都是测不下去，原因是需求变来变去，产品无法准确把握和设计需求，造成开发过程甚至已经提测之后，进行不停的“需求变更”，美其名曰敏捷开发提倡拥抱变化，变更是正常的，实际上变化的自始至终都不是客户的需求，而是产品经理自己的需求，这可能是产品经理自身能力不够，也可能是没有对需求本身进行质量控制，大家都知道的，变更越往后，成本越高，作为质量控制人员，要防止最终的不可控，我们更应该从需求就开始接入，控制质量，控制成本。</p><h3 id="当前测试现状"><a href="#当前测试现状" class="headerlink" title="当前测试现状"></a>当前测试现状</h3><p>只从“术”的角度看当前软件测试技术发展<br>当前测试大环境下：</p><ul><li>大量公司关注自动化，提倡自动化实施</li><li>大力开展CI/CD、Devops</li><li>多数公司都建立有自己的测试平台</li><li>关注APM，链路监控</li><li>使用大量开源工具辅助测试</li><li>… …</li></ul><p>同时，可能存在的问题：</p><ul><li>公司并没有质量文化，没有关注质量的基因</li><li>公司没有自己的质量标准，也没有缺陷预防</li><li>过于追求“术”，对于测试行为本身的思考几乎没有</li><li>面对新的软件开发模式，敏捷、微服务、Service Mesh、Serverless手足无措</li><li>热衷于招聘测试开发和所谓资深测试，重复造轮子，和市场脱节（苏州oracle的部分资深）</li><li>… …<br>（提个搞笑的，招了一堆资深人员，做手工测试）</li></ul><h3 id="可能的未来"><a href="#可能的未来" class="headerlink" title="可能的未来"></a>可能的未来</h3><p>对于现状，说说可能的未来，首先，当前市场上，去翻的看看，招聘的职位，基本都是“测试开发”，说实话，很多时候，花大代价招进来的测试开发，做的是不是就是维护已有自动化框架的事情，或者是一些小的团队，招测试开发是为了开展自动化，我还是那句话，是不是有考虑好真的需要开展自动化了。自动化做到什么程序是自己满意的。单纯的开发自动化框架，不接触业务的测试开发，最终的产出真的是可以解决当前问题的。其实，是可以先冷静的想想的。毕竟，自动化，说到底，也是在已知测试结果的情况下进行的自动验证，现实中很多情况，是自动化做不到的，在没有能力做到自动生成测试用例，自动生成测试数据情况下，还是不用过于追求它。当然，当前已经有AI在测试上的实施，AI可以帮助我们自动生成测试用例、测试数据，模拟用户操作，帮助我们提高测试效率和测试覆盖率，但是AI基础是大数据，这边的数据，还是需要人工进行探索式测试得到。未来可能会出现这样的场景，首先人工进行业务分析，需求评审，功能拆分，探索式测试，产出数据供AI进行模型训练，然后AI会帮助进行以前的自动化部分，甚至是自动化没有涉及到的，AI会自动帮你扩充，自动化没有覆盖的，AI会帮助覆盖。</p><p>看过一个关于测试的公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试 = 检测 + 试验</span><br><span class="line"></span><br><span class="line">测试 = 已知的检测 + 未知的试验</span><br><span class="line"></span><br><span class="line">测试 = 基于确定性模型/明确的预言（test oracle）的自动化测试 + 基于AI搜索/基于工具随机/模糊模型/人工的探索式测试</span><br></pre></td></tr></table></figure></p><p>理想情况下，人工负责分析，建模性工作，其他交给AI和自动化进行机械重复性劳动</p><p>以上基本都是关于测试“术”的未来，关于测试“道”，说到底，其实自始至终都是一样的，软件测试人员，存在的原因是保障产品质量，最终提交客户的是客户满意的产品，你所要负责的，是产品的质量保障，不是测试代码，不是测试工具，不是你的领导布置的任务你有了框架产出，所有的一切“旁门”的努力，根本原因是为了保障质量，提高效率的保障质量。</p><p>最后，希望自己能在技术挣扎中，不忘了，自己做测试的原因。</p><p>通篇胡言乱语，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些测试杂说&lt;/p&gt;
    
    </summary>
    
      <category term="测试之道" scheme="http://tokyle.com/categories/%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="lives" scheme="http://tokyle.com/tags/lives/"/>
    
  </entry>
  
  <entry>
    <title>Centos7搭建wordpress博客</title>
    <link href="http://tokyle.com/2019/07/03/Centos7%E6%90%AD%E5%BB%BAwordpress%E5%8D%9A%E5%AE%A2/"/>
    <id>http://tokyle.com/2019/07/03/Centos7搭建wordpress博客/</id>
    <published>2019-07-03T07:35:50.000Z</published>
    <updated>2019-07-03T07:37:14.598Z</updated>
    
    <content type="html"><![CDATA[<p>Centos7搭建wordpress博客</p><a id="more"></a><p>其实，也不是想换成wordpress，就是想看看搭起来怎么样</p><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>当前最新版本是5.2.2，但是没有汉化包，折腾半天，英语还是看的费劲，当然，全英文无压力可以用和这个，看了下汉化进度，简体中文0%，繁体中文100%，所以不介意的话，可以用台湾同胞制作的繁体中文汉化包：</p><blockquote><p><a href="https://wordpress.org/download/" target="_blank" rel="noopener">官网5.22下载</a><br><a href="https://make.wordpress.org/polyglots/teams/?locale=zh_TW" target="_blank" rel="noopener">繁体中文汉化包</a></p></blockquote><p>汉化包下载完了之后，先进入wordpress的<code>wp-content</code>文件夹，创建一个<code>languages</code>文件夹，然后将汉化包解压到这个文件夹，然后浏览器刷新页面即可</p><p>当前简体中文版汉化的最高版本是<strong>5.0.4</strong>，下载地址：</p><blockquote><p><a href="https://cn.wordpress.org/download/releases/" target="_blank" rel="noopener">简体中文汉化版</a></p></blockquote><h3 id="httpd"><a href="#httpd" class="headerlink" title="httpd"></a>httpd</h3><p>安装httpd很简单<code>yum install httpd</code>，启动：<code>systemctl start httpd</code></p><p>将上一步下载好的安装包，解压到httpd目录下：<code>/var/www/html</code>，重命名文件夹，更改属主和属组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf wordpress-5.2.2.tar.gz -C /var/www/html</span><br><span class="line"></span><br><span class="line">mv wordpress blog</span><br><span class="line"></span><br><span class="line">chown -R root:root blog</span><br></pre></td></tr></table></figure></p><p>并且，由于多加了一层<code>blog</code>，需要更改httpd的配置文件，修改路径：<br><code>vim /etc/httpd/conf/httpd.conf</code><br>将<code>DocumentRoot</code>和<code>Directory</code>改为<code>/var/www/html/blog</code></p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>安装MySQL就不说了，装好之后，进控制台，建库和用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database wordpress character set utf8;</span><br><span class="line">create user wordpress@&apos;%&apos; identified by &apos;test@1234&apos;;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;wordpress&apos;@&apos;%&apos; IDENTIFIED BY &apos;test@1234&apos; WITH GRANT OPTION;</span><br><span class="line">flush privileges;</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure></p><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><p>使用<code>yum install php</code>安装的php版本是5.6有点低，wordpress5.2.2不支持，最好是安装<strong>PHP7</strong><br>卸载原来版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove php*</span><br></pre></td></tr></table></figure></p><p>更改RPM源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm</span><br><span class="line">rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</span><br></pre></td></tr></table></figure></p><p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install php71w php71w-cli php71w-common php71w-devel php71w-embedded php71w-fpm php71w-gd php71w-mbstring php71w-mysqlnd php71w-opcache php71w-pdo php71w-xml php71w-ldap php71w-mcrypt</span><br></pre></td></tr></table></figure></p><p>验证：<code>php -v</code></p><h3 id="配置wordpress"><a href="#配置wordpress" class="headerlink" title="配置wordpress"></a>配置wordpress</h3><p>修改数据库配置：</p><p>进入blog文件夹（之前重命名的），重命名wp-config-sample.php为wp-config.php，添加数据库信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv wp-config-sample.php wp-config.php</span><br><span class="line">vim wp-config.php</span><br></pre></td></tr></table></figure></p><p>修改对应数据库信息，并且访问<code>https://api.wordpress.org/secret-key/1.1/salt/</code>获取Authentication Unique Keys，并且粘贴进来。</p><p>编辑完成之后，重启httpd:<code>systemctl restart httpd</code><br>浏览器输入IP，开始使用wordpress</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Centos7搭建wordpress博客&lt;/p&gt;
    
    </summary>
    
      <category term="skill" scheme="http://tokyle.com/categories/skill/"/>
    
    
      <category term="wordpress" scheme="http://tokyle.com/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter生成Report Dashboard</title>
    <link href="http://tokyle.com/2019/07/02/Jmeter%E7%94%9F%E6%88%90Report-Dashboard/"/>
    <id>http://tokyle.com/2019/07/02/Jmeter生成Report-Dashboard/</id>
    <published>2019-07-03T01:51:12.000Z</published>
    <updated>2019-07-03T02:02:28.280Z</updated>
    
    <content type="html"><![CDATA[<p>Jmeter生成Report Dashboard</p><a id="more"></a><h3 id="Report-Dashboard"><a href="#Report-Dashboard" class="headerlink" title="Report Dashboard"></a>Report Dashboard</h3><p>Jmeter最后生成的测试结果报告一直是被吐槽的，今天翻官方教程时候，发现，人家报告根本就很好看啊，自己不会用。。</p><blockquote><p><a href="https://jmeter.apache.org/usermanual/generating-dashboard.html#top" target="_blank" rel="noopener">Generating Report Dashboard</a></p></blockquote><p>生成方法很简单，命令行运行jmeter脚本即可，格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmeter -n -t &lt;test JMX file&gt; -l &lt;test log file&gt; -e -o &lt;Path to output folder&gt;</span><br></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmeter -n -t 111.jmx -l report\01-result.csv -e -o report\01-Dashboard</span><br></pre></td></tr></table></figure></p><p>运行完成之后，会在report文件夹下，生成一个<code>01-Dashboard</code>文件夹，浏览器打开<code>index.html</code>就是一个很完整的<strong>Report Dashboard</strong></p><p>效果图：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4mecnxu8xj21h30phmyo.jpg" alt="dashboard"></p><p>响应时间图<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4medfxay2j21gz0q60uk.jpg" alt></p><p>另一种生成dashboard的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generation from an existing sample CSV log file（从结果csv文件产生）</span><br><span class="line">jmeter -g &lt;log file&gt; -o &lt;Path to output folder&gt;</span><br></pre></td></tr></table></figure></p><p>这是在已经执行完测试，生成了csv的测试结果</p><h3 id="Jmeter几条常用命令"><a href="#Jmeter几条常用命令" class="headerlink" title="Jmeter几条常用命令"></a>Jmeter几条常用命令</h3><p>算是自己平时可能用的比较多的：</p><h4 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h4><p>jmeter命令行模式（脚本和jmeter.bat在一个目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmeter -n -t test1.jmx  -r -l report\01-result.csv -j report\01-log.log（分布式）</span><br><span class="line"></span><br><span class="line">jmeter -n -t APP.jmx   -l report\01-result.csv -j report\01-log.log（单台）</span><br></pre></td></tr></table></figure></p><p>顺便记点不相关的：<br>iostat安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y sysstat</span><br></pre></td></tr></table></figure></p><p>htop安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line"></span><br><span class="line">yum install htop</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jmeter生成Report Dashboard&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Jmeter" scheme="http://tokyle.com/tags/Jmeter/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter使用Grafana展示</title>
    <link href="http://tokyle.com/2019/06/27/Jmeter%E4%BD%BF%E7%94%A8Grafana%E5%B1%95%E7%A4%BA/"/>
    <id>http://tokyle.com/2019/06/27/Jmeter使用Grafana展示/</id>
    <published>2019-06-27T06:31:09.000Z</published>
    <updated>2019-06-27T06:44:36.149Z</updated>
    
    <content type="html"><![CDATA[<p>Jmeter使用Grafana展示</p><a id="more"></a><p>之前写过一个Jmeter + Influxdb + Grafana实时展示测试结果：</p><blockquote><p><a href="https://tokyle.com/2018/09/27/%E4%BD%BF%E7%94%A8Grafana%E5%B1%95%E7%A4%BAJmeter%E6%95%B0%E6%8D%AE/">使用Grafana展示Jmeter数据</a></p></blockquote><p>之前使用的<code>Backend Listener</code>选择的是<code>org.apache.jmeter.visualizers.backend.graphite.TextGraphiteMetricsSender</code></p><p>现在直接使用<code>org.apache.jmeter.visualizers.backend.influxdb.HttpMetricsSender</code>更简单一点</p><h3 id="安装influxdb"><a href="#安装influxdb" class="headerlink" title="安装influxdb"></a>安装influxdb</h3><ul><li>安装：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-1.7.6.x86_64.rpm</span><br><span class="line">sudo yum localinstall influxdb-1.7.6.x86_64.rpm</span><br></pre></td></tr></table></figure><ul><li>启动：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">加自启动：</span><br><span class="line">systemctl enable influxdb</span><br><span class="line"></span><br><span class="line">启服务：</span><br><span class="line">systemctl start influxdb</span><br></pre></td></tr></table></figure><ul><li>建库：</li></ul><p>进控制台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@tokyle influxdb]# influx</span><br><span class="line">Connected to http://localhost:8086 version 1.6.1</span><br><span class="line">InfluxDB shell version: 1.6.1</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>建库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 建库</span><br><span class="line">create database jmeterdb;</span><br><span class="line"> </span><br><span class="line"># 建存储策略</span><br><span class="line">CREATE RETENTION POLICY &quot;jmeter_7d&quot; ON &quot;jmeterdb&quot; DURATION 7d REPLICATION 1 DEFAULT;</span><br><span class="line"></span><br><span class="line"># 查看存储策略</span><br><span class="line">show retention policies on jmeterdb;</span><br><span class="line"></span><br><span class="line">name      duration shardGroupDuration replicaN default</span><br><span class="line">----      -------- ------------------ -------- -------</span><br><span class="line">autogen   0s       168h0m0s           1        false</span><br><span class="line">jmeter_7d 168h0m0s 24h0m0s            1        true</span><br></pre></td></tr></table></figure></p><h3 id="安装grafana"><a href="#安装grafana" class="headerlink" title="安装grafana"></a>安装grafana</h3><ul><li>安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.grafana.com/oss/release/grafana-6.2.5-1.x86_64.rpm </span><br><span class="line">sudo yum localinstall grafana-6.2.5-1.x86_64.rpm</span><br></pre></td></tr></table></figure><ul><li>启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">systemctl start grafana-server</span><br><span class="line"></span><br><span class="line">systemctl status grafana-server</span><br></pre></td></tr></table></figure><p>进官网，下载Jmter标准模板。。。</p><blockquote><p><a href="https://grafana.com/dashboards/5496" target="_blank" rel="noopener">Grafana-Jmeter模板</a></p></blockquote><p>可以直接下载Json，然后进grafana web页面，导入dashboard即可</p><h3 id="Jmeter配置"><a href="#Jmeter配置" class="headerlink" title="Jmeter配置"></a>Jmeter配置</h3><p>主要就是配置一个<code>Backend Listener</code></p><p><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4fodelbddj213f094tbg.jpg" alt="Jmeter配置"></p><p>需要修改部分：</p><ol><li><p>influxdbUrl: IP改为自己influxdb的IP</p></li><li><p>application：自定义一个应用名称，后面grafana要用到</p></li><li><p>summaryOnly：false</p></li></ol><p>然后就可以直接运行jmeter跑结果了，在grafana中可以直观的呈现：</p><p><img src="http://ww1.sinaimg.cn/large/a025e134gy1g4fpmqipiwj20dw074gmr.jpg" alt></p><h3 id="Jmeter-Metrics"><a href="#Jmeter-Metrics" class="headerlink" title="Jmeter Metrics"></a>Jmeter Metrics</h3><p>Jmter对接influxdb之后，可以在表里找到很多的字段，翻jmeter官网，看看各个metric的含义</p><blockquote><p><a href="http://jmeter.apache.org/usermanual/realtime-results.html" target="_blank" rel="noopener">Jmeter官网Metrics教程</a></p></blockquote><h4 id="线程-虚拟用户"><a href="#线程-虚拟用户" class="headerlink" title="线程/虚拟用户"></a>线程/虚拟用户</h4><table><thead><tr><th>Item</th><th>含义</th></tr></thead><tbody><tr><td>minAT</td><td>最小活跃线程（虚拟用户）</td></tr><tr><td>maxAT</td><td>最大活跃线程（虚拟用户）</td></tr><tr><td>meanAT</td><td>平均活跃线程（虚拟用户）</td></tr><tr><td>startedT</td><td>started threads运行中的线程？</td></tr><tr><td>endedT</td><td>Finished thread停止的线程</td></tr></tbody></table><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><table><thead><tr><th>Item</th><th>含义</th></tr></thead><tbody><tr><td>.ok.count</td><td>成功的请求数</td></tr><tr><td>.h.count/hit</td><td>QPS</td></tr><tr><td>.ok.min</td><td>最小成功请求响应时间</td></tr><tr><td>.ok.max</td><td>最大成功请求响应时间</td></tr><tr><td>.ok.avg</td><td>成功请求平均响应时间</td></tr><tr><td>.ok.pct</td><td>请求成功率</td></tr><tr><td>.a.count</td><td>总请求数（成功+失败）</td></tr><tr><td>.sb.bytes</td><td>发送数据量（Bytes）</td></tr><tr><td>.rb.bytes</td><td>接收数据量（Bytes）</td></tr><tr><td>countError</td><td>错误数</td></tr><tr><td>pct90.0</td><td>90%响应时间</td></tr><tr><td>pct95.0</td><td>95%响应时间</td></tr><tr><td>pct99.0</td><td>99%响应时间</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jmeter使用Grafana展示&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="grafana" scheme="http://tokyle.com/tags/grafana/"/>
    
      <category term="Influxdb" scheme="http://tokyle.com/tags/Influxdb/"/>
    
      <category term="Jmeter" scheme="http://tokyle.com/tags/Jmeter/"/>
    
  </entry>
  
  <entry>
    <title>Influxdb启动失败日志定位</title>
    <link href="http://tokyle.com/2019/06/26/Influxdb%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E6%97%A5%E5%BF%97%E5%AE%9A%E4%BD%8D/"/>
    <id>http://tokyle.com/2019/06/26/Influxdb启动失败日志定位/</id>
    <published>2019-06-27T03:15:54.000Z</published>
    <updated>2019-06-27T03:17:47.756Z</updated>
    
    <content type="html"><![CDATA[<p>Influxdb启动失败日志定位</p><a id="more"></a><p>之前做过Jmeter使用influxdb和grafana展示测试数据，当时使用了graphite，现在看到Jmeter好像可以直接存在influxdb中，就想尝试下，就找了台机器搭建influxdb，然后悲剧了，起不来。</p><p>其实问题很简单，基本不是端口占用就是文件夹权限问，主要是找不到日志。。</p><p>下面是完整的经过<br>搭建完influxdb，并且<code>systemctl start influxdb</code>之后，想连进去看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tokyle bin]# influx</span><br><span class="line">Failed to connect to http://localhost:8086: Get http://localhost:8086/ping: dial tcp [::1]:8086: connect: connection refused</span><br><span class="line">Please check your connection settings and ensure &apos;influxd&apos; is running.</span><br></pre></td></tr></table></figure></p><p>进不去。。检查状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@tokyle bin]# systemctl  status  influxdb</span><br><span class="line">● influxdb.service - InfluxDB is an open-source, distributed, time series database</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/influxdb.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: start-limit) since 四 2019-06-27 11:00:45 CST; 2min 0s ago</span><br><span class="line">     Docs: https://docs.influxdata.com/influxdb/</span><br><span class="line">  Process: 3587 ExecStart=/usr/bin/influxd -config /etc/influxdb/influxdb.conf $INFLUXD_OPTS (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 3587 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">6月 27 11:00:44 tokyle.com systemd[1]: Unit influxdb.service entered failed state.</span><br><span class="line">6月 27 11:00:44 tokyle.com systemd[1]: influxdb.service failed.</span><br><span class="line">6月 27 11:00:45 tokyle.com systemd[1]: influxdb.service holdoff time over, scheduling restart.</span><br><span class="line">6月 27 11:00:45 tokyle.com systemd[1]: Stopped InfluxDB is an open-source, distributed, time series database.</span><br><span class="line">6月 27 11:00:45 tokyle.com systemd[1]: start request repeated too quickly for influxdb.service</span><br><span class="line">6月 27 11:00:45 tokyle.com systemd[1]: Failed to start InfluxDB is an open-source, distributed, time series database.</span><br><span class="line">6月 27 11:00:45 tokyle.com systemd[1]: Unit influxdb.service entered failed state.</span><br><span class="line">6月 27 11:00:45 tokyle.com systemd[1]: influxdb.service failed.</span><br></pre></td></tr></table></figure></p><p>压根没起来</p><p>找日志，先到<code>/var/lib/influxdb</code>下，没知道，<code>/var/log/</code>没找到</p><p>找<strong>系统日志</strong><br><code>journalctl -u influxdb</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u influxdb</span><br><span class="line"></span><br><span class="line">6月 27 10:46:02 tokyle.com systemd[1]: influxdb.service: main process exited, code=exited, status=1/FAILURE</span><br><span class="line">6月 27 10:46:02 tokyle.com systemd[1]: Unit influxdb.service entered failed state.</span><br><span class="line">6月 27 10:46:02 tokyle.com systemd[1]: influxdb.service failed.</span><br><span class="line">6月 27 10:46:03 tokyle.com systemd[1]: influxdb.service holdoff time over, scheduling restart.</span><br><span class="line">6月 27 10:46:03 tokyle.com systemd[1]: Stopped InfluxDB is an open-source, distributed, time series database.</span><br><span class="line">6月 27 10:46:03 tokyle.com systemd[1]: start request repeated too quickly for influxdb.service</span><br><span class="line">6月 27 10:46:03 tokyle.com systemd[1]: Failed to start InfluxDB is an open-source, distributed, time series database.</span><br></pre></td></tr></table></figure></p><p>还是看不出什么问题</p><p>最后，不使用systemctl直接手工启动influxdb：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop influxdb</span><br><span class="line"></span><br><span class="line">cd /usr/bin</span><br><span class="line"></span><br><span class="line">[root@tokyle bin]# influxd -config /etc/influxdb/influxdb.conf </span><br><span class="line"></span><br><span class="line"> 8888888           .d888 888                   8888888b.  888888b.</span><br><span class="line">   888            d88P&quot;  888                   888  &quot;Y88b 888  &quot;88b</span><br><span class="line">   888            888    888                   888    888 888  .88P</span><br><span class="line">   888   88888b.  888888 888 888  888 888  888 888    888 8888888K.</span><br><span class="line">   888   888 &quot;88b 888    888 888  888  Y8bd8P&apos; 888    888 888  &quot;Y88b</span><br><span class="line">   888   888  888 888    888 888  888   X88K   888    888 888    888</span><br><span class="line">   888   888  888 888    888 Y88b 888 .d8&quot;&quot;8b. 888  .d88P 888   d88P</span><br><span class="line"> 8888888 888  888 888    888  &quot;Y88888 888  888 8888888P&quot;  8888888P&quot;</span><br><span class="line"></span><br><span class="line">2019-06-27T03:04:08.786635ZinfoInfluxDB starting&#123;&quot;log_id&quot;: &quot;0GHj5JKW000&quot;, &quot;version&quot;: &quot;1.6.1&quot;, &quot;branch&quot;: &quot;1.6&quot;, &quot;commit&quot;: &quot;5766854b95ae86cccf6cc8ffe4c5bb9eacc994b8&quot;&#125;</span><br><span class="line">2019-06-27T03:04:08.786678ZinfoGo runtime&#123;&quot;log_id&quot;: &quot;0GHj5JKW000&quot;, &quot;version&quot;: &quot;go1.10.3&quot;, &quot;maxprocs&quot;: 4&#125;</span><br><span class="line">run: open server: listen: listen tcp 127.0.0.1:8088: bind: address already in use</span><br></pre></td></tr></table></figure></p><p>终于看见了，端口被占用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tokyle bin]# netstat -anp | grep 8088</span><br><span class="line">tcp6       0      0 :::8088                 :::*                    LISTEN      22329/docker-proxy</span><br></pre></td></tr></table></figure><p>docker占了8088,问题解决</p><p>以上经过，记住，influxdb找不到日志：</p><ol><li>journalctl -u influxdb</li><li>/usr/bin/influxd -config /etc/influxdb/influxdb.conf</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Influxdb启动失败日志定位&lt;/p&gt;
    
    </summary>
    
      <category term="Devops" scheme="http://tokyle.com/categories/Devops/"/>
    
    
      <category term="Influxdb" scheme="http://tokyle.com/tags/Influxdb/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter ForEach控制器使用</title>
    <link href="http://tokyle.com/2019/06/26/Jmeter-ForEach%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://tokyle.com/2019/06/26/Jmeter-ForEach控制器使用/</id>
    <published>2019-06-27T01:56:28.000Z</published>
    <updated>2019-06-27T02:01:11.690Z</updated>
    
    <content type="html"><![CDATA[<p>Jmeter ForEach控制器使用</p><a id="more"></a><p>昨天遇到的问题，有个接口需要循环删除多个taskid（前一个接口获得），找了网上资料，最后成功实现</p><h3 id="ForEach控制器"><a href="#ForEach控制器" class="headerlink" title="ForEach控制器"></a>ForEach控制器</h3><p>ForEach控制器一般和用户自定义变量一起使用，其在用户自定义变量中读取一系列相关的变量。该控制器下的采样器或控制器都会被执行一次或多次，每次读取不同的变量值</p><p>字段解释：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Input Variable Prefix</td><td>输入变量前缀</td></tr><tr><td>Output variable name</td><td>输出变量名称</td></tr><tr><td>Start index for loop(exclusive)</td><td>循环开始的索引（这里如果不填写，默认从1开始，如果没有1开始的变量，执行时会报错）</td></tr><tr><td>End index for loop(inclusive)</td><td>循环结束的索引</td></tr><tr><td>Add”_”before number</td><td>输入变量名称中是否使用“_”进行间隔</td></tr></tbody></table><h3 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h3><p>ForEach控制器一般喝<code>用户定义的变量</code>一起使用<br>结构类似这样：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ffkn6taqj20wp089t9m.jpg" alt="ForEach示例"></p><p>在<code>用户定义的变量</code>插件中定义了四个name，在后续http请求，需要每个都传进去执行一次，也就是整个线程组执行是一次，其中http请求会执行四次，并且每次使用不通的name</p><p>ForEach控制器配置：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ffnhsjnlj20a906owf2.jpg" alt="ForEach控制器配置"></p><p>传入name，输出testname，在后续http请求中，name替换成<code>${testname}</code>即可<br>看看效果：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ffrpyrraj20ld08oq4t.jpg" alt="执行效果"></p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>回到之前那个删除taskid的问题，可以采用同样的方式，只要保证，传给ForEach控制器的是key:value形式，并且是同一个key，不同的value</p><p><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ffwmsfu7j20ju081wg0.jpg" alt="11"></p><p>其中search接口返回数据大概是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;taskId&quot;:&quot;5d12ddc64d44wserwreeaa4cb56&quot;,</span><br><span class="line">        &quot;input&quot;:Object&#123;...&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;taskId&quot;:&quot;5d12ddc64ereea017eaa4cb56&quot;,</span><br><span class="line">        &quot;input&quot;:Object&#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>可以看到返回值中有多个taskId，这些taskId是需要全部传给后续delete接口删除的<br>可以用JSON提取出所有的taskID，再传给ForEach控制器，输出一个新的变量taskidItem，将该taskidItem传给delete接口，达到有多少taskId，delete接口就取不同的taskId循环多少次，最终全部删除的效果</p><p><code>JSON Extractor</code>配置：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4fg1x4m2wj20wn07jq4x.jpg" alt="JSON Extractor"></p><p>以上就是本次实现，ForEach控制器，总的来说，适用于有多个value值返回，并且这些value值都需要进行后续操作的场景</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jmeter ForEach控制器使用&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Jmeter" scheme="http://tokyle.com/tags/Jmeter/"/>
    
  </entry>
  
  <entry>
    <title>性能监控简单小结</title>
    <link href="http://tokyle.com/2019/06/26/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%AE%80%E5%8D%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://tokyle.com/2019/06/26/性能监控简单小结/</id>
    <published>2019-06-26T07:39:34.000Z</published>
    <updated>2019-06-26T07:41:01.031Z</updated>
    
    <content type="html"><![CDATA[<p>性能监控简单小结</p><p>涉及MySQL和JVM<br><a id="more"></a></p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>首先是MySQL的常用监控项</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li><p>缓存概览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%Query_cache%%&quot;;</span><br><span class="line">+------------------------------+----------+</span><br><span class="line">| Variable_name                | Value    |</span><br><span class="line">+------------------------------+----------+</span><br><span class="line">| have_query_cache             | YES      |</span><br><span class="line">| query_cache_limit            | 16777216 |</span><br><span class="line">| query_cache_min_res_unit     | 4096     |</span><br><span class="line">| query_cache_size             | 16777216 |</span><br><span class="line">| query_cache_type             | OFF      |</span><br><span class="line">| query_cache_wlock_invalidate | OFF      |</span><br><span class="line">+------------------------------+----------+</span><br><span class="line">6 rows in set (0.24 sec)</span><br></pre></td></tr></table></figure></li><li><p>缓存碎片率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status  like &quot;%Qcache%&quot;;</span><br><span class="line">+-------------------------+----------+</span><br><span class="line">| Variable_name           | Value    |</span><br><span class="line">+-------------------------+----------+</span><br><span class="line">| Qcache_free_blocks      | 1        |</span><br><span class="line">| Qcache_free_memory      | 16760152 |</span><br><span class="line">| Qcache_hits             | 0        |</span><br><span class="line">| Qcache_inserts          | 0        |</span><br><span class="line">| Qcache_lowmem_prunes    | 0        |</span><br><span class="line">| Qcache_not_cached       | 19860231 |</span><br><span class="line">| Qcache_queries_in_cache | 0        |</span><br><span class="line">| Qcache_total_blocks     | 1        |</span><br><span class="line">+-------------------------+----------+</span><br><span class="line">8 rows in set (0.21 sec)</span><br></pre></td></tr></table></figure></li></ul><p>其中，如果Qcache_free_blocks大致等于Qcache_total_blocks/2，说明碎片非常严重<br>如果Qcache_lowmem_prunes的值正在增加，并且有大量的自由块，表示碎片导致查询正在被从缓存中永久删除</p><p><strong>缓存碎片率 = Qcache_free_block/Qcache_total_blocks *100%</strong>如果查询缓存碎片率都超过20%，可以使用<code>FLUSH QUERY CACHE</code>整理缓存碎片</p><p><strong>缓存利用率 = （query_cache_size - Qcache_free_memory）/ query_cache_size *100% </strong><br>查询缓存利用率低于25%，表明query_cache_size值设置过大，可以适当减小；<br>查询利用率在80%以上，并且Qcache_lowmem_prunes &gt;50，表明query_cache_size值太小或者碎片太多</p><ul><li>thread_cache_size<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;thread%&quot;;</span><br><span class="line">+-------------------+---------------------------+</span><br><span class="line">| Variable_name     | Value                     |</span><br><span class="line">+-------------------+---------------------------+</span><br><span class="line">| thread_cache_size | 32                        |</span><br><span class="line">| thread_handling   | one-thread-per-connection |</span><br><span class="line">| thread_stack      | 262144                    |</span><br><span class="line">+-------------------+---------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p>缓存在Cache中的线程数量</p><h4 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h4><ul><li><p>DB已连接线程数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;Connections&apos;;</span><br><span class="line">+---------------+--------+</span><br><span class="line">| Variable_name | Value  |</span><br><span class="line">+---------------+--------+</span><br><span class="line">| Connections   | 245884 |</span><br><span class="line">+---------------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>当前连接线程状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;%thread%&apos;;</span><br><span class="line">+------------------------------------------+-------+</span><br><span class="line">| Variable_name                            | Value |</span><br><span class="line">+------------------------------------------+-------+</span><br><span class="line">| Delayed_insert_threads                   | 0     |</span><br><span class="line">| Performance_schema_thread_classes_lost   | 0     |</span><br><span class="line">| Performance_schema_thread_instances_lost | 0     |</span><br><span class="line">| Slow_launch_threads                      | 0     |</span><br><span class="line">| Threads_cached                           | 18    |</span><br><span class="line">| Threads_connected                        | 9     |</span><br><span class="line">| Threads_created                          | 27    |</span><br><span class="line">| Threads_running                          | 1     |</span><br><span class="line">+------------------------------------------+-------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>服务器允许最大连接数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;max_connections&apos;;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| max_connections | 151   |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p>一般500 ~ 800比较合适</p><ul><li>服务器响应的最大连接数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;Max_used_connections&apos;;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Max_used_connections | 27    |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p><strong>Max_used_connections/max_connections &lt;= 85%</strong>比较理想</p><ul><li>连接队列长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;back_log&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| back_log      | 80    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p>类似于线程队列，当无法响应请求时，就让线程排队；值越小越好。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul><li>索引缓存大小<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;key_buffer_size&apos;;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| key_buffer_size | 33554432 |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">1 row in set (0.00 sec</span><br></pre></td></tr></table></figure></li></ul><p><strong>连接缓存命中率Threads_Cache_Hit = (Connections - Threads_created)/Connections*100%</strong>建议90%左右甚至更高</p><ul><li>索引缓存未命中率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;key_read%&apos;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Key_read_requests | 28    |</span><br><span class="line">| Key_reads         | 10    |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">2 rows in set (0.10 sec)</span><br></pre></td></tr></table></figure></li></ul><p><strong>索引缓存未命中率key_cache_miss_rate = Key_reads/Key_read_requests *100%</strong><br>1%即100个索引中有一个在缓存中找不到，要直接从硬盘读取;建议<code>小于0.1%</code></p><ul><li>索引缓存命中率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;key_%&apos;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Key_blocks_not_flushed | 0     |</span><br><span class="line">| Key_blocks_unused      | 26785 |</span><br><span class="line">| Key_blocks_used        | 7     |</span><br><span class="line">| Key_read_requests      | 28    |</span><br><span class="line">| Key_reads              | 10    |</span><br><span class="line">| Key_write_requests     | 2     |</span><br><span class="line">| Key_writes             | 2     |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p><strong>key_buffer_read_hits = (1-Key_reads/Key_read_requests) *100%</strong><br><strong>key_buffer_write_hits = (1-Key_writes/Key_write_requests)*100%</strong><br>越大越好</p><ul><li>索引读取统计<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;key_blocks_u%&apos;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Key_blocks_unused | 26785 |</span><br><span class="line">| Key_blocks_used   | 7     |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p>Key_blocks_unused表示未使用的缓存簇（blocks）数，Key_blocks_used表示曾经用到的最大的blocks数，如果缓存都用到了，那么要么增加key_buffer_size，要么就是过度索引把缓存占满了。<br>比较理想的情况：<br><strong>Key_blocks_used/(Key_blocks_unused + Key_blocks_used) *100% ≈ 80%</strong></p><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><ul><li>临时表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;created_tmp%&apos;;</span><br><span class="line">+-------------------------+--------+</span><br><span class="line">| Variable_name           | Value  |</span><br><span class="line">+-------------------------+--------+</span><br><span class="line">| Created_tmp_disk_tables | 3054   |</span><br><span class="line">| Created_tmp_files       | 7      |</span><br><span class="line">| Created_tmp_tables      | 624084 |</span><br><span class="line">+-------------------------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p>临时表比较大无法在内存中完成时就不得不使用磁盘文件。如果Created_tmp_tables非常大，则可能是系统中排序操作过多，或者表连接方式不是很优化。如果Created_tmp_disk_tables和Created_tmp_tables的比率过高，如超过10%，则需要考虑tmp_table_size这个系统参数的值是都设置的足够大。<br>参考值： <strong>Created_tmp_disk_tables/Created_tmp_tables &lt; 5%</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables where Variable_name in (&apos;tmp_table_size&apos;, &apos;max_heap_table_size&apos;);</span><br><span class="line">+---------------------+----------+</span><br><span class="line">| Variable_name       | Value    |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">| max_heap_table_size | 33554432 |</span><br><span class="line">| tmp_table_size      | 33554432 |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>MySQL规定的内部内存临时表的最大值，每个线程都要分配。（实际起限制作用的是tmp_table_size和max_heap_table_size的最小值。）如果内存临时表超出了限制，MySQL就会自动地把它转化为基于磁盘的MyISAM表，存储在指定的tmpdir目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;tmpdir&quot;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| tmpdir        | /tmp  |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure></p><ul><li>表扫描情况<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;handler_read%&apos;;</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Variable_name         | Value    |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Handler_read_first    | 9357279  |</span><br><span class="line">| Handler_read_key      | 77387871 |</span><br><span class="line">| Handler_read_last     | 121      |</span><br><span class="line">| Handler_read_next     | 69589828 |</span><br><span class="line">| Handler_read_prev     | 104      |</span><br><span class="line">| Handler_read_rnd      | 531042   |</span><br><span class="line">| Handler_read_rnd_next | 45348670 |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;com_select&apos;;</span><br><span class="line">+---------------+----------+</span><br><span class="line">| Variable_name | Value    |</span><br><span class="line">+---------------+----------+</span><br><span class="line">| Com_select    | 19894899 |</span><br><span class="line">+---------------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>表扫描率 = Handler_read_rnd_next /Com_select</strong><br>如果表扫描率超过4000，说明进行了太多表扫描，可能是索引没有建好；</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>直接运行命令，返回java进程号，参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-l： 返回java进程全路径 </span><br><span class="line">-q： 仅显示进程号</span><br><span class="line">-v： 返回JVM参数，可以查看堆大小</span><br></pre></td></tr></table></figure></p><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>用的最多</p><ul><li>查看运行情况<br>首先通过<code>jps</code>获取进程号，再使用<code>jstat</code>获取JVM中加载的累的数据和size<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jps</span><br><span class="line">15649 Gtest.0-y-1.1.5.jar</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstat -class -h5  15649 1000</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line"> 11654 21472.7        0     0.0       4.21</span><br><span class="line"> 11654 21472.7        0     0.0       4.21</span><br><span class="line"> 11654 21472.7        0     0.0       4.21</span><br><span class="line"> 11654 21472.7        0     0.0       4.21</span><br><span class="line"> 11654 21472.7        0     0.0       4.21</span><br></pre></td></tr></table></figure><p>每1秒统计一次，每统计5次显示一次表头</p><p>字段含义：</p><table><thead><tr><th>Item</th><th>含义</th></tr></thead><tbody><tr><td>Loaded</td><td>加载类的数目</td></tr><tr><td>Bytes</td><td>加载类的Size，单位Bytes</td></tr><tr><td>Unloaded</td><td>卸载类的数量</td></tr><tr><td>Bytes</td><td>卸载类的Size，单位Bytes</td></tr><tr><td>Time</td><td>加载和卸载类花费的时间</td></tr></tbody></table><ul><li>jstat 所有选项说明<br>更详细可以<code>man jstat</code>查看，所有选项及对应的参数说明</li></ul><table><thead><tr><th>Item</th><th>含义</th></tr></thead><tbody><tr><td>class</td><td>查看类加载情况的统计</td></tr><tr><td>compiler</td><td>查看HotSpot中即使编译器编译情况的统计</td></tr><tr><td>gc</td><td>用于查看JVM中堆的垃圾回收情况统计</td></tr><tr><td>gccapacity</td><td>查看新生代、老年代及元空间情况</td></tr><tr><td>gccause</td><td>最后一次及当前正在垃圾回收的原因</td></tr><tr><td>gcnew</td><td>查看新生代垃圾回收情况</td></tr><tr><td>gcnewcapacity</td><td>查看新生代存储容量情况</td></tr><tr><td>gcold</td><td>查看老年代及持久代发生GC的情况</td></tr><tr><td>gcoldcapacity</td><td>查看老年代容量</td></tr><tr><td>gcmetacapacity</td><td>元空间容量</td></tr><tr><td>gcutil</td><td>GC统计</td></tr></tbody></table><ul><li>jstat gccapacity</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstat -gccapacity 15649</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC </span><br><span class="line"> 84992.0 1355776.0 688640.0 8192.0 20992.0 640512.0   171008.0  2711552.0   201728.0   201728.0      0.0 1105920.0  65280.0      0.0 1048576.0   8192.0     14     3</span><br></pre></td></tr></table></figure><p>字段说明：</p><table><thead><tr><th>Item</th><th>说明</th></tr></thead><tbody><tr><td>NGCMN</td><td>新生代最小容量（KB）</td></tr><tr><td>NGCMX</td><td>新生代最大容量(KB)</td></tr><tr><td>NGC</td><td>新生代当前容量(KB)</td></tr><tr><td>S0C</td><td>当前幸存者一区（survivor）容量(KB)</td></tr><tr><td>S1C</td><td>当前幸存者二区（survivor）容量(KB)</td></tr><tr><td>EC</td><td>当前伊甸园（eden）容量(KB)</td></tr><tr><td>OGCMN</td><td>老年代初始化大小(KB)</td></tr><tr><td>OGCMX</td><td>老年代最大容量(KB)</td></tr><tr><td>OGC</td><td>老年代当前容量(KB) Current old generation capacity (kB)</td></tr><tr><td>OC</td><td>old区当前容量（KB） Current old space capacity (kB)</td></tr><tr><td>MCMN</td><td>最小元空间容量（kB）</td></tr><tr><td>MCMX</td><td>最大元空间容量（kB）</td></tr><tr><td>MC</td><td>元空间容量（kB）</td></tr><tr><td>CCSMN</td><td>压缩类空间最小容量（kB）</td></tr><tr><td>CCSMX</td><td>压缩类空间最大容量（kB）</td></tr><tr><td>CCSC</td><td>压缩类空间容量（kB）</td></tr><tr><td>YGC</td><td>young GC次数</td></tr><tr><td>FGC</td><td>Full GC次数</td></tr></tbody></table><ul><li>jstat gcutil</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstat -gcutil 15649</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line"> 99.22   0.00  81.74  21.00  95.96  93.63     14    0.161     3    0.186    0.347</span><br></pre></td></tr></table></figure><p>字段说明：</p><table><thead><tr><th>Item</th><th>含义</th></tr></thead><tbody><tr><td>S0</td><td>幸存者一区已使用的容量百分比</td></tr><tr><td>S1</td><td>幸存者二区已使用的容量百分比</td></tr><tr><td>E</td><td>伊甸园已使用的容量百分比</td></tr><tr><td>O</td><td>老年代已使用的容量百分比</td></tr><tr><td>M</td><td>元空间已使用的容量百分比</td></tr><tr><td>CCS</td><td>压缩类空间利用率百分比</td></tr><tr><td>YGC</td><td>Young GC次数</td></tr><tr><td>YGCT</td><td>JVM启动到采样时，Young GC用时（s）</td></tr><tr><td>FGC</td><td>Full GC次数</td></tr><tr><td>FGCT</td><td>JVM启动到采样时，Full GC用时（s）</td></tr><tr><td>GCT</td><td>GC总时间</td></tr></tbody></table><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>jmap我知道的作用，就是dump下堆快照，再用工具分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=dump.hprof PID</span><br></pre></td></tr></table></figure></p><p>其他用法：</p><ul><li><p>jmap分析jvm内存<br><code>jmap -heap pidOP</code></p></li><li><p>打印当前java堆活跃的各个对象的数量、大小<br><code>jmap -histo:live 16102 | head -10</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[C is a char[]</span><br><span class="line">[S is a short[]</span><br><span class="line">[I is a int[]</span><br><span class="line">[B is a byte[]</span><br><span class="line">[[I is a int[][]</span><br></pre></td></tr></table></figure><ul><li>打印等待回收的对象信息<br><code>jmap -finalizerinfo  pid</code></li></ul><p>dump快照打印下来之后，传到本地，可以使用Jsisualvm或者<code>MemoryAnalyze</code>（mat）打开</p><blockquote><p><a href="https://pan.baidu.com/s/159QUTj5OKKi7jvtPIlSIvA" target="_blank" rel="noopener">MemoryAnalyze</a></p></blockquote><p>提取码：t4yy</p><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>步骤：</p><ol><li><p>top -c   P（找最耗CPU进程拿pid）    4209</p></li><li><p>top -Hp 4209    P (找最耗CPU线程，拿pid)     9890</p></li><li><p>printf “%x” 9890    （转换为16进制）</p></li><li><p>jstack 4209 | grep 26a2 -C5 –color</p></li></ol><p>以上，就是整理的一点监控相关，配合以下几篇，性能测试的性能问题定位，差不多入门：</p><blockquote><p><a href="https://tokyle.com/2018/05/16/%E3%80%90%E8%BD%AC%E3%80%91windows%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/#">windows性能监控指标</a><br><a href="https://tokyle.com/2018/08/29/%E3%80%90%E8%BD%AC%E3%80%91Linux%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90/">Linux性能监控与分析</a><br><a href="https://tokyle.com/2018/10/17/Linux%E5%AE%9A%E4%BD%8D%E6%9C%80%E8%80%97CPU%E7%9A%84%E7%BA%BF%E7%A8%8B/#">Linux定位最耗CPU的线程</a><br><a href="https://tokyle.com/2018/11/02/JVM%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/">JVM内存性能问题定位</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;性能监控简单小结&lt;/p&gt;
&lt;p&gt;涉及MySQL和JVM&lt;br&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="mysql" scheme="http://tokyle.com/tags/mysql/"/>
    
      <category term="JVM" scheme="http://tokyle.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>性能测试工具nGrinder试用</title>
    <link href="http://tokyle.com/2019/06/25/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7nGrinder%E8%AF%95%E7%94%A8/"/>
    <id>http://tokyle.com/2019/06/25/性能测试工具nGrinder试用/</id>
    <published>2019-06-26T01:57:41.000Z</published>
    <updated>2019-06-26T02:11:23.583Z</updated>
    
    <content type="html"><![CDATA[<p>性能测试工具nGrinder试用</p><a id="more"></a><p>之前就有听过这工具，但本着工具在精不在多原则，一直没用过，最近看市场上，苏州有家公司把这个列进了要求，就试用了下</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这边是直接使用的docker拉的镜像安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ngrinder/controller</span><br></pre></td></tr></table></figure></p><p>直接拉了最新版本镜像，然后起容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name ngrinder -d -p 8099:80 ngrinder/controller</span><br></pre></td></tr></table></figure></p><p>嗯，起起来了，不出所料，后续起agent时候挂了，端口没开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR agent controller: Error while connecting to agent controller server at /192.168.0.97:16001</span><br></pre></td></tr></table></figure></p><p>原因很简单，起容器时候，没暴露16001端口，省略后续的其他踩坑，直接把要用的端口都开了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name ngrinder -d -p 8099:80 \</span><br><span class="line"> -p 16001:16001 \</span><br><span class="line"> -p 12000-12009:12000-12009 \</span><br><span class="line"> ngrinder/controller</span><br></pre></td></tr></table></figure></p><p>查看状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 拿containerid</span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"># 看日志</span><br><span class="line">docker logs -f --tail=300 containerid</span><br></pre></td></tr></table></figure></p><p>起好之后，浏览器打开：<code>http://192.168.0.97:8099</code>，默认账密<code>admin/admin</code><br>界面长这样：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4eb9syiw4j20s40hh41l.jpg" alt="主界面"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>帮助</code>旁边的<code>admin</code>下，点击下载代理和下载监控，传到服务器上，解压完起代理和监控（linux下直接起shell脚本）<br>先创建<code>脚本</code>,再创建<code>性能测试</code></p><p>创建脚本填写对应参数即可：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ebe1j89ej20ov0hmmxi.jpg" alt="创建脚本"></p><p>测试配置页面也很简单，都是一些通用的配置，代理数量，vusers，启动延时配置，运行时间，运行次数等<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ebfx4si4j20t30ml3zm.jpg" alt="测试配置"></p><p>配置完成，点保存并运行即可</p><p>测试报告：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ebhu40qej20t00m0t9u.jpg" alt="测试报告"><br>其中有日志，也可以点<code>详细测试结果</code>查看更详细的数据<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ebkhbyh9j20rx0ofq4b.jpg" alt="详细报告"><br>支持下载CSV报告查看</p><p>以上就是nGrinder的一次，总的印象，工具还行，报告很直观，但是对于编码可能要求（看了下，Jython编写的，基本就是python的request框架），语言试用Groovy和Jython;内置了SVN，团队之间脚本分享很方便。</p><p>实在不想手持身份证用七牛云，用了新浪的图床，很可能图会挂。。见谅。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;性能测试工具nGrinder试用&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="nGrinder" scheme="http://tokyle.com/tags/nGrinder/"/>
    
  </entry>
  
  <entry>
    <title>python字符串实践</title>
    <link href="http://tokyle.com/2019/06/25/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E8%B7%B5/"/>
    <id>http://tokyle.com/2019/06/25/python字符串实践/</id>
    <published>2019-06-25T09:19:10.000Z</published>
    <updated>2019-06-25T09:20:38.738Z</updated>
    
    <content type="html"><![CDATA[<p>python字符串实践</p><a id="more"></a><p>收银小票打印尝试</p><h3 id="python字符串对齐方式"><a href="#python字符串对齐方式" class="headerlink" title="python字符串对齐方式"></a>python字符串对齐方式</h3><p>首先，看几个命令的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from math import pi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;&#123;0:&lt;10.2f&#125;\n&#123;0:^10.2f&#125;\n&#123;0:&gt;10.2f&#125;&quot;.format(pi))</span><br><span class="line">print(&apos;&#123;&#125;&apos;.format(pi))</span><br><span class="line">print(&apos;&#123;0&#125;&apos;.format(pi))</span><br><span class="line">print(&apos;&#123;&#123;:&#123;&#125;&#125;&#125;&apos;.format(10))</span><br><span class="line">print(&apos;&#123;:10.2f&#125;&apos;.format(pi))</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3.14      </span><br><span class="line">   3.14   </span><br><span class="line">      3.14</span><br><span class="line">3.141592653589793</span><br><span class="line">3.141592653589793</span><br><span class="line">&#123;:10&#125;</span><br><span class="line">      3.14</span><br></pre></td></tr></table></figure></p><h3 id="收银小票尝试："><a href="#收银小票尝试：" class="headerlink" title="收银小票尝试："></a>收银小票尝试：</h3><p>实现方式有点low，写的有点乱。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*-coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: kyle</span><br><span class="line">@time: 2019/6/20 16:06</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># from math import pi</span><br><span class="line"></span><br><span class="line"># print(&quot;&#123;0:&lt;10.2f&#125;\n&#123;0:^10.2f&#125;\n&#123;0:&gt;10.2f&#125;&quot;.format(pi))</span><br><span class="line"># print(&apos;&#123;&#125;&apos;.format(pi))</span><br><span class="line"># print(&apos;&#123;0&#125;&apos;.format(pi))</span><br><span class="line"># print(&apos;&#123;&#123;:&#123;&#125;&#125;&#125;&apos;.format(10))</span><br><span class="line"># print(&apos;&#123;:10.2f&#125;&apos;.format(pi))</span><br><span class="line"></span><br><span class="line">def fruit_price(fruit):</span><br><span class="line">    if fruit == &apos;Watermelon&apos;:</span><br><span class="line">        return 1.6</span><br><span class="line">    elif fruit == &apos;Apple&apos;:</span><br><span class="line">        return 10</span><br><span class="line">    elif fruit == &apos;Peach&apos;:</span><br><span class="line">        return 3.3</span><br><span class="line">    elif fruit == &apos;Pear&apos;:</span><br><span class="line">        return 2</span><br><span class="line">    else:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">def enter_price():</span><br><span class="line">    price = []</span><br><span class="line">    weights = []</span><br><span class="line">    fruits = []</span><br><span class="line">    num = 0</span><br><span class="line">    while True:</span><br><span class="line">        num += 1</span><br><span class="line">        fruit = input(&apos;Enter the fruit: &apos;)</span><br><span class="line">        weight = input(&apos;Enter the weight: &apos;)</span><br><span class="line">        fruits.append(fruit)</span><br><span class="line">        weights.append(weight)</span><br><span class="line">        a = fruit_price(fruit)</span><br><span class="line">        price.append(a)</span><br><span class="line">        if fruit == &apos;q&apos; or weight == &apos;q&apos;:</span><br><span class="line">            break</span><br><span class="line">    num -= 1</span><br><span class="line">    fruits.remove(fruits[-1])</span><br><span class="line">    price.remove(price[-1])</span><br><span class="line">    weights.remove(weights[-1])</span><br><span class="line"></span><br><span class="line">    return [num,fruits,weights,price]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fruit_res = enter_price()</span><br><span class="line">print(fruit_res)</span><br><span class="line"></span><br><span class="line"># 设置小票宽度</span><br><span class="line">width = int(input(&apos;Please enter your width: &apos;))</span><br><span class="line">price_width = 10</span><br><span class="line">num_width = 10</span><br><span class="line">item_width = width - price_width - num_width</span><br><span class="line"></span><br><span class="line"># 设置小票表头格式</span><br><span class="line">header_fmt = &apos;&#123;&#123;:&#123;&#125;&#125;&#125;&#123;&#123;:^&#123;&#125;&#125;&#125;&#123;&#123;:&gt;&#123;&#125;&#125;&#125;&apos;.format(item_width, num_width, price_width)</span><br><span class="line">fmt = &apos;&#123;&#123;:&#123;&#125;&#125;&#125;&#123;&#123;:^&#123;&#125;&#125;&#125;&#123;&#123;:&gt;&#123;&#125;.2f&#125;&#125;&apos;.format(item_width, num_width, price_width)</span><br><span class="line"></span><br><span class="line">print(&apos;*&apos;* width)</span><br><span class="line">print(&quot;Here&apos;s Your Ticket&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;=&apos;* width)</span><br><span class="line">print(header_fmt.format(&apos;Item&apos;, &apos;Num&apos;, &apos;Price&apos;))</span><br><span class="line">print(&apos;-&apos; * width)</span><br><span class="line"></span><br><span class="line"># 循环打印水果，单价，数量</span><br><span class="line">num = fruit_res[0]</span><br><span class="line">i = 0</span><br><span class="line">prices = []</span><br><span class="line">for i in range(int(num)):</span><br><span class="line">    prices.append(int(fruit_res[2][i]) * float(fruit_res[3][i]))</span><br><span class="line">    print(fmt.format(fruit_res[1][i], fruit_res[2][i], fruit_res[3][i]))</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">print(&apos;-&apos; * width)</span><br><span class="line"></span><br><span class="line"># 打印总价</span><br><span class="line">Sum = sum(prices)</span><br><span class="line">item2_width = width - price_width</span><br><span class="line">foot_fmt = &apos;&#123;&#123;:&lt;&#123;&#125;&#125;&#125;&#123;&#123;:&gt;&#123;&#125;.2f&#125;&#125;&apos;.format(item2_width, price_width)</span><br><span class="line">print(foot_fmt.format(&apos;Summary&apos;, Sum))</span><br><span class="line">print(&apos;-&apos; * width)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Enter the fruit: Watermelon</span><br><span class="line">Enter the weight: 10</span><br><span class="line">Enter the fruit: Apple</span><br><span class="line">Enter the weight: 20</span><br><span class="line">Enter the fruit: Peach</span><br><span class="line">Enter the weight: 30</span><br><span class="line">Enter the fruit: q</span><br><span class="line">Enter the weight: q</span><br><span class="line">[3, [&apos;Watermelon&apos;, &apos;Apple&apos;, &apos;Peach&apos;], [&apos;10&apos;, &apos;20&apos;, &apos;30&apos;], [1.6, 10, 3.3]]</span><br><span class="line">Please enter your width: 45</span><br><span class="line">*********************************************</span><br><span class="line">Here&apos;s Your Ticket</span><br><span class="line">=============================================</span><br><span class="line">Item                        Num         Price</span><br><span class="line">---------------------------------------------</span><br><span class="line">Watermelon                   10          1.60</span><br><span class="line">Apple                        20         10.00</span><br><span class="line">Peach                        30          3.30</span><br><span class="line">---------------------------------------------</span><br><span class="line">Summary                                315.00</span><br><span class="line">---------------------------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p><p>有空再改进。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python字符串实践&lt;/p&gt;
    
    </summary>
    
      <category term="python基础" scheme="http://tokyle.com/categories/python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>敏捷测试与自动化</title>
    <link href="http://tokyle.com/2019/06/23/%E6%95%8F%E6%8D%B7%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>http://tokyle.com/2019/06/23/敏捷测试与自动化/</id>
    <published>2019-06-24T02:09:56.000Z</published>
    <updated>2019-07-04T03:18:20.214Z</updated>
    
    <content type="html"><![CDATA[<p>敏捷测试与自动化</p><a id="more"></a><h3 id="敏捷自动化问题"><a href="#敏捷自动化问题" class="headerlink" title="敏捷自动化问题"></a>敏捷自动化问题</h3><p>最近看到一篇文章，讨论敏捷开发模式下的自动化实施问题，看到里面有很多值得好好想想的地方。</p><p>首先，在一个追求敏捷开发的团队中，很多时候，测试工作都是放在整个项目的最后一个环节，尤其是Android应用项目，多数情况下，会出现很多个版本一起上线，这个时候，作为测试的压力明显是非常大，工作量巨大，纯手工进行测试很可能会忙于应付需求，这个时候正式自动化回归最大效率化的时候，然后现状很可能是，自动化连手工都不如，需要半天甚至一天才能出测试结果，每次运行都是全流程，自动化测试报告也需要大量时间进行分析，这无疑是很失败的敏捷自动化实施。</p><p>很多团队，可能也有专人进行了很长时间的专职自动化设计，搭建，但是效果一直不理想，原因可能是：</p><ol><li><p>自动化人员与业务剥离，甚至不了解业务，所有用例需要业务功能测试人员提供；试想这样的情况下，自动化也不是纯框架设计，进行的也是涉及业务的自动化用例设计，那怎么可能设计出有效的自动化用例呢。</p></li><li><p>管理人员对于自动化预期过高，认为自动化测试可以实现所有的测试活动；自动化测试，说到底，也是在设计了断言的情况下进行验证，也就是已知结果的情况，很多时候，测试工作需要随机测试，暴力测试等等去发现很多非正常情况下可能出现的问题。</p></li><li><p>自动化测试没有专人，没有必要的时间和精力；有的公司可能实行的是固定测试开发团队进行自动化框架编辑搭建，后续的自动化用例是由产线的测试工程师进行编写维护；这样的做法，的确算是功能细分，但是有个前提，产线的测试有时间和精力去专门做自动化测试相关。很多团队有点搞笑，自动化用例让产线实施，并不给产线测试需要的时间去学习和练习自动化测试技能，最终的结果，可想而知。</p></li></ol><p>其实测试人员也都知道，产品交接时间点临近时，产品功能交付的优先级肯定是高于自动化实施，测试人员需要确保的是那些即将交付的产品功能，而不是确保产品功能正常的自动化测试用例。但是长此以往的不断将自动化测试实施优先级降低，一次次的迭代发布日期指定，只会将产线折腾的异常忙碌，烦躁。造成这种情况的原因，可能是迫于市场和客户压力，需要一次次的制定满足于市场的新功能，短时间铺开市场，解决客户问题，但是这样的一次次的追求快，仓促发布功能，最终真的是在满足市场吗？守业更比创业难，不要等到最后市场诚信低至谷底时候才想起来，当然，追求快速IPO分钱走人就当没说。</p><p>插一句：敏捷工作方式的目的是以最小幅度增长的方式发布可供用户使用的功能，并且得到用户的即时反馈。</p><h3 id="可能的解决办法"><a href="#可能的解决办法" class="headerlink" title="可能的解决办法"></a>可能的解决办法</h3><ol><li><p>设定合理的预期，想清楚，为什么需要自动化，需要自动化做什么，怎么实施可以帮助现在的团队。有个很扯淡的想法，实施自动化是因为不想做手工。。。</p></li><li><p>给自动化分配专用的资源，公司需要关注的不应该仅仅是测试开发需要专门的资源，产线的自动化用例编写维护人员更需要专门的时间和精力去学习，练习，维护自动化，整天疲于应对功能迭代压力，最终结果是自动化夭折。</p></li><li><p>提高自动化关注度和优先级，这个需要在公司层面，宣传论证实施自动化的价值，试问如果团队都不知道自动化为何物，就提出要花大时间，聘请专员进行自动化，是不是有点扯。</p></li><li><p>将自动化测试看做软件研发对待，这点是对自动化测试工程师本身来说的，实施自动化测试之前，需要和产品研发一样，需求分析，方案论证，概要设计，详细设计等。</p></li><li><p>合理制定目标，也是针对自动化实施人员来说的，在经验没有那么丰富，或者时间没有那么充裕的情况下，是是不是可以考虑首先进行的是接口的自动化，而不是直接UI。</p></li><li><p>持续学习，既然敏捷工作模式下，产品都是一些快速迭代的过程，那身为自动化工程师的你，是不是应该为了适应不断增加的需求，去快递学习。例如自动化工具后续直接使用docker镜像化，自动化实施配合CI，构建完成直接Jenkins调度，无需手工执行，自动化实施过程中，关注测试右移，实施APM监控等等。</p></li></ol><p>以上是看到的和自己的一点点想法，希望国内广大的测试同胞们可以不被自动化所累，知道自己想要的是什么，其实在我看来，追求系统的底层实现，开发语言的基本语法，高效实施等，才是更有效的方式，一味的追求工具，追求框架，很可能会迷失自己，毕竟做到后面，自动化也成了维护代码。</p><p>愿测试可以被温柔以待</p><p>突然想到个毫无关系的一句话：<code>少年不知画中意，归来已成画中人</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;敏捷测试与自动化&lt;/p&gt;
    
    </summary>
    
      <category term="测试之道" scheme="http://tokyle.com/categories/%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="自动化测试" scheme="http://tokyle.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一次Android安全问题定位</title>
    <link href="http://tokyle.com/2019/06/21/%E4%B8%80%E6%AC%A1Android%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/"/>
    <id>http://tokyle.com/2019/06/21/一次Android安全问题定位/</id>
    <published>2019-06-21T09:06:26.000Z</published>
    <updated>2019-06-21T09:07:31.485Z</updated>
    
    <content type="html"><![CDATA[<p>一次Android安全问题定位</p><a id="more"></a><p>有个账密明文存库问题，<code>default.realm</code>存了明文的用户名和密码</p><h3 id="文件获取"><a href="#文件获取" class="headerlink" title="文件获取"></a>文件获取</h3><p>首先，很明显，需要root手机了，正常的权限，根本进不去<code>/data/data</code>文件夹</p><p>root完之后开始</p><p><code>adb devices</code>，设备已连接上</p><p><code>su</code>切换用户，进入shell</p><p>赋权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /data</span><br><span class="line">chmod 777 /data/data</span><br><span class="line">chmod -R 777 /data/data/com.test.package</span><br></pre></td></tr></table></figure></p><p><code>find / -name &quot;default.realm&quot;</code>查找该数据库文件</p><p><code>cd /data/data/com.test.package/files</code>进入数据库文件夹</p><p><code>cp default.realm /sdcard</code>将数据库文件拷贝到外部存储器SD卡（方便拉倒本地）</p><p><code>exit</code><br>退出adb shell</p><p><code>adb pull /sdcard/default.realm E:/LOGS</code> 将SD卡里数据库文件拉到本地</p><h3 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h3><p>没那本事在windows下看<code>.realm</code>，找个台mac，装了个<code>Realm Browser</code>打开导出的<code>default.realm</code></p><p>看到在user表，明文的链接，用户名，密码。。。<br>(android sdk的platform_tool中有个monitor.bat工具，可以看见android的文件系统，可能不能深层次进入，还是命令行方式靠谱)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一次Android安全问题定位&lt;/p&gt;
    
    </summary>
    
      <category term="skill" scheme="http://tokyle.com/categories/skill/"/>
    
    
      <category term="adb" scheme="http://tokyle.com/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>Service Mesh基础知识</title>
    <link href="http://tokyle.com/2019/06/21/Service-Mesh%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://tokyle.com/2019/06/21/Service-Mesh基础知识/</id>
    <published>2019-06-21T06:31:34.000Z</published>
    <updated>2019-06-21T06:42:33.311Z</updated>
    
    <content type="html"><![CDATA[<p>Service Mesh基础知识</p><a id="more"></a><p>微服务大噪一时，可以说是最火的后端架构，微服务架构将原来的单体应用进行服务拆分，做成一个个独立的服务应用，各个服务各司其职，彼此独立，各个服务甚至不需要用同样的编程语言，更方便团队协作。</p><p>微服务包含一些基本组件，服务发现，服务注册，鉴权，熔断降级等。由于微服务是将单体拆分为独立应用，当应用越来越大，微服务越来越多，管理起来也就会越来越麻烦。一套微服务环境，链路追踪，负载均衡，安全配置，流量管理等等，可能就会耗费大量时间去维护。针对微服务不断壮大，微服务管理的相关问题，出现了新的微服务框架<code>Service Mesh</code>(服务网格)</p><h3 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h3><p>在解释service mesh之前，先看看nginx的基本概念</p><p>nginx有几大功能，其中正向代理和反向代理，应该都很熟悉。本来最基本的架构是A和B需要进行通信，A和B可以直接相互传输，买房子为例，买家和卖家直接交易。这样的架构有个问题，A和B传输之间的信息，旁人无法知道，传输状态外界也无法监控，传输的数据包如果太大把带宽占满，外界也无法知晓，这样的情况下，就有了中间加一层，代理,C。</p><p>A和B进行通信，会经过C，A向C发起通知，要和B通信，消息给C，C转给B。C就成了中间人，也就是代理，说两个日常常用但可能没多想的例子：</p><ol><li>国内万里长城的存在，想要见识外部世界，就需要VPN，俗称的翻墙。技术实现其实很简单，VPN其实是搭建在一台可以直接访问外部网站（例如IG）的服务器上的正向代理服务，可能在日本，可能在美国等；本地挂VPN翻墙，其实就是用客户端去访问正向代理服务，再由服务进行转发，达到大陆也可以访问外网的效果。这就是正向代理（Forward Proxy）</li><li>典型的nginx负载均衡，A访问C，C将A的请求，分发给下面的无数个B(B1,B2,B3,B4,B5…)。A其实压根不知道它是最终是在和B进行通信，A也根本不关心有多少个B，只要有C，和C进行通信，就能达到A和无数个B进行通信的效果，C就是反向代理。（Reverse Proxy）</li></ol><p>说完代理的例子，说说中间加这么一层有什么意义：</p><ol><li>拦截：原来A和B直接通信，没人能阻止，现在加了层这个，就可以防止员工上班时间看视频。。。</li><li>统计：既然A和B所有的通信都会经过代理，那么也就可以通过代理来统计网络传输中的数据信息</li><li>缓存：典型应用CDN，访问比较慢，直接将数据缓存到访问快的地方，通过这个地方进行访问，要快很多</li><li>分发：负载均衡</li><li>跳板：堡垒机<br>… …</li></ol><p>说完nginx的代理，说回service mesh，其实service mesh也就是类似于nginx的一个代理，可以看做是分布式微服务代理。在传统的代理模式下，代理一般是单独的代理服务器，所有请求先通过代理，再转发到实际的后端。service mesh中，代理是分布式的，常驻在服务身边（sidecar模式），每个服务可以理解成有两个部分，一个是原来的服务（service），一个是用于service mesh的代理（sidecar），sidecar之间相互连接，和彼此的服务彼此隔离，和传统的代理一样，流量也就是经过sidecar进行管理，所有的服务的sidecar进行连接，组成了mesh（网格）。</p><p>同时，传统的代理，基本是只基于网络流量，但是 Service Mesh 中，代理会知道整个集群的所有应用信息，并且额外添加了热更新、注入服务发现、降级熔断、认证授权、超时重试、日志监控等功能，让这些通用的功能不必每个应用都自己实现，放在代理中即可。换句话说，Service Mesh 中的代理对微服务中的应用做了定制化的改进。</p><p>有了service mesh，管理员只需要和代理层打交道，就能达到对整个微服务系统控制的效果。</p><p><img src="http://ww1.sinaimg.cn/large/a025e134gy1g48rpbys10g21hc0tee81.gif" alt="Service Mesh原理"></p><h3 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h3><p>Istio其实就是Service Mesh架构的一种实现，来看看通过istio可以解决什么问题：<br>来自Istio网站：</p><ul><li>HTTP、gRPC、WebSocket和TCP流量的自动负载均衡。</li><li>通过丰富的路由规则、重试、故障转移和故障注入对流量行为进行细粒度控制。</li><li>支持访问控制、速率限制和配额的可拔插策略层和配置API。</li><li>自动指标、日志和集群内所有流量的跟踪，包括集群入口和出口。</li><li>通过集群中的服务之间的强身份断言来实现服务间的身份验证。</li></ul><p><img src="http://ww1.sinaimg.cn/large/a025e134gy1g48ru7eqtng21hc0te7ip.gif" alt="Istio解决的问题"></p><p>以上内容均来自万能的互联网，由于自己目前对k8s理解还比较浅，对k8s的sidecar还只是理论的认知，Service Mesh和Istio以及Serviceless和knative当前也只是在理论阶段，本篇只是敲门，后面再慢慢入门。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Service Mesh基础知识&lt;/p&gt;
    
    </summary>
    
      <category term="cloud native" scheme="http://tokyle.com/categories/cloud-native/"/>
    
    
      <category term="Service Mesh" scheme="http://tokyle.com/tags/Service-Mesh/"/>
    
      <category term="Istio" scheme="http://tokyle.com/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>pytest学习实践（二）</title>
    <link href="http://tokyle.com/2019/06/19/pytest%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/19/pytest学习实践（二）/</id>
    <published>2019-06-19T07:54:47.000Z</published>
    <updated>2019-06-19T07:55:58.784Z</updated>
    
    <content type="html"><![CDATA[<p>pytest学习实践（二）</p><a id="more"></a><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>pytest的断言就用的python最基本的assert<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line"></span><br><span class="line">def func(x):</span><br><span class="line">    return x + 1</span><br><span class="line"></span><br><span class="line">def test_func():</span><br><span class="line">    assert func(3) == 5</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    pytest.main([&apos;-q&apos;])</span><br></pre></td></tr></table></figure></p><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>用raises来捕获预期的异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line">import pytest</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    filename = &apos;package.json&apos;</span><br><span class="line">    with open(filename) as f_obj:</span><br><span class="line">        json.load(f_obj)</span><br><span class="line">    raise FileNotFoundError</span><br><span class="line"></span><br><span class="line">def test_func():</span><br><span class="line">    with pytest.raises(FileNotFoundError):</span><br><span class="line">        func()</span><br></pre></td></tr></table></figure></p><h3 id="多个类组成用例"><a href="#多个类组成用例" class="headerlink" title="多个类组成用例"></a>多个类组成用例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line"></span><br><span class="line">class TestClass():</span><br><span class="line">    def test_one(self):</span><br><span class="line">        x = &quot;this&quot;</span><br><span class="line">        assert &apos;h&apos; in x</span><br><span class="line"></span><br><span class="line">    def test_two(self):</span><br><span class="line">        x = &apos;hello&apos;</span><br><span class="line">        assert hasattr(x, &apos;check&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    pytest.main([&apos;-q&apos;])</span><br></pre></td></tr></table></figure><p>只要函数以test_开头，都可以识别</p><h3 id="指定测试case"><a href="#指定测试case" class="headerlink" title="指定测试case"></a>指定测试case</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def test_one():</span><br><span class="line">    x = &quot;this&quot;</span><br><span class="line">    assert &apos;h&apos; in x</span><br><span class="line"></span><br><span class="line">def test_two():</span><br><span class="line">    x = &apos;hello&apos;</span><br><span class="line">    assert hasattr(x, &apos;check&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    pytest.main([&apos;-q&apos;, &apos;test_2.py::test_one&apos;])</span><br></pre></td></tr></table></figure><p>但是这样的方式只能指定一个函数，如果需要执行多个，就有点麻烦</p><p>使用<code>pytest.mark</code>进行标记<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@pytest.mark.commit</span><br><span class="line">def test_one():</span><br><span class="line">    x = &quot;this&quot;</span><br><span class="line">    assert &apos;h&apos; in x</span><br><span class="line"></span><br><span class="line">@pytest.mark.finished</span><br><span class="line">def test_two():</span><br><span class="line">    x = &apos;hello&apos;</span><br><span class="line">    assert hasattr(x, &apos;check&apos;)</span><br><span class="line"></span><br><span class="line">@pytest.mark.finished</span><br><span class="line">def test_three():</span><br><span class="line">    assert 1 == 2</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    pytest.main([&apos;-m&apos;, &apos;finished&apos;])</span><br><span class="line">    # os.system(&apos;pytest -m finished&apos;)</span><br></pre></td></tr></table></figure></p><p>使用mark进行标记，标记哪些需要执行，也支持：<code>pytest -m &quot;commit and finished&quot;</code></p><h3 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@pytest.mark.skip</span><br><span class="line">def test_two():</span><br><span class="line">    x = &apos;hello&apos;</span><br><span class="line">    assert hasattr(x, &apos;check&apos;)</span><br></pre></td></tr></table></figure><p>也支持<code>skipif</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@pytest.mark.skipif(sys.platform == &quot;win32&quot;, reason=&quot;not support win32&quot;)</span><br><span class="line">def test_four():</span><br><span class="line">    assert 1 == 1</span><br></pre></td></tr></table></figure></p><h3 id="捕获遇见错误xfail"><a href="#捕获遇见错误xfail" class="headerlink" title="捕获遇见错误xfail"></a>捕获遇见错误xfail</h3><p>使用xfail来标记，期望该测试函数执行失败（执行失败，但又不想跳过）；配合配置文件<code>test.ini</code>，文件中指定标志位，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[pytest]</span><br><span class="line">xfail_strict=true</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@pytest.mark.xfail(strict=True)</span><br><span class="line">def test_five():</span><br><span class="line">    a = id([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])</span><br><span class="line">    b = id([1, 2, 3])</span><br><span class="line">    assert a == b</span><br></pre></td></tr></table></figure><p>运行返回结果<code>x</code>表示<code>XFAIL</code>预见的失败；<code>X</code>表示<code>XPASS</code>预见的成果</p><p>也可以用<code>pytest --runxfail</code>强制执行标记xfail的用例</p><h3 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h3><p>pytest使用<code>pytest.mark.parametrize(argnames, argvalues)</code>进行参数化实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@pytest.mark.parametrize(&apos;passwd&apos;, [&apos;12345678909&apos;, &apos;sdsddewd&apos;])</span><br><span class="line">def test_six(passwd):</span><br><span class="line">    assert len(passwd) &gt;= 10</span><br></pre></td></tr></table></figure><p>测试结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.F                                                                       [100%]</span><br><span class="line">================================== FAILURES ===================================</span><br><span class="line">_____________________________ test_six[sdsddewd] ______________________________</span><br><span class="line"></span><br><span class="line">passwd = &apos;sdsddewd&apos;</span><br><span class="line"></span><br><span class="line">    @pytest.mark.parametrize(&apos;passwd&apos;, [&apos;12345678909&apos;, &apos;sdsddewd&apos;])</span><br><span class="line">    def test_six(passwd):</span><br><span class="line">&gt;       assert len(passwd) &gt;= 10</span><br><span class="line">E       AssertionError: assert 8 &gt;= 10</span><br><span class="line">E        +  where 8 = len(&apos;sdsddewd&apos;)</span><br><span class="line"></span><br><span class="line">test_2.py:31: AssertionError</span><br><span class="line">1 failed, 1 passed in 0.15 seconds</span><br></pre></td></tr></table></figure></p><h3 id="case重试"><a href="#case重试" class="headerlink" title="case重试"></a>case重试</h3><p>安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pytest-rerunfailures</span><br></pre></td></tr></table></figure></p><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    pytest.main([&apos;-s&apos;, &apos;-q&apos;, &apos;--reruns&apos;, &apos;3&apos;])</span><br><span class="line">    # os.system(&apos;pytest -s -q test_2.py --reruns 3&apos;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 failed, 1 warnings, 3 rerun in 0.13 seconds</span><br></pre></td></tr></table></figure><p>可以指定单个case重试</p><h3 id="多进程运行cases"><a href="#多进程运行cases" class="headerlink" title="多进程运行cases"></a>多进程运行cases</h3><p>安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pytest-xdist</span><br></pre></td></tr></table></figure></p><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # pytest.main([&apos;-s&apos;, &apos;-n&apos;, &apos;3&apos;])</span><br><span class="line">    os.system(&apos;pytest -s -n 3 test_2.py&apos;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gw0 I / gw1 I / gw2 I</span><br><span class="line">gw0 [1] / gw1 [1] / gw2 [1]</span><br></pre></td></tr></table></figure><h3 id="生成测试报告（htmlReport）"><a href="#生成测试报告（htmlReport）" class="headerlink" title="生成测试报告（htmlReport）"></a>生成测试报告（htmlReport）</h3><p>安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pytest-html</span><br></pre></td></tr></table></figure></p><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # pytest.main([&apos;--html=report.html&apos;])</span><br><span class="line">    os.system(&apos;pytest  test_2.py --html=report.html&apos;)</span><br></pre></td></tr></table></figure></p><p>报告很好看！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pytest学习实践（二）&lt;/p&gt;
    
    </summary>
    
      <category term="python基础" scheme="http://tokyle.com/categories/python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="pytest" scheme="http://tokyle.com/tags/pytest/"/>
    
  </entry>
  
  <entry>
    <title>pytest学习实践（一）</title>
    <link href="http://tokyle.com/2019/06/19/pytest%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/19/pytest学习实践（一）/</id>
    <published>2019-06-19T05:15:34.000Z</published>
    <updated>2019-06-19T05:24:09.190Z</updated>
    
    <content type="html"><![CDATA[<p>pytest学习实践（一）</p><a id="more"></a><p>pytest是python中一个很好用的框架，主要特点：</p><ol><li>支持参数化（不用unittest一样接ddt）</li><li>支持简单单元测试及复杂功能测试，可以用来做selenium和appium，以及接口自动化（pytest+request）</li><li>众多第三方插件：pytest-html（报告）、pytest-selenium（集成selenium）、pytest-rerunfailures（失败重跑）等</li><li>测试用来skip和xfail处理</li><li>CI方便</li></ol><blockquote><p><a href="http://plugincompat.herokuapp.com/" target="_blank" rel="noopener">pytest插件大全</a></p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>写一个简单的测试函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">def test_func1():</span><br><span class="line">    assert 1 == 1</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    os.system(&apos;pytest&apos;)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">collected 1 item</span><br><span class="line"></span><br><span class="line">test_1.py .                                                              [100%]</span><br><span class="line"></span><br><span class="line">========================== 1 passed in 0.06 seconds ===========================</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p><p>pytest以<code>.</code>表示测试成功，可以看一下测试失败：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">def test_func1():</span><br><span class="line">    assert 1 == 2</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    os.system(&apos;pytest&apos;)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">collected 1 item</span><br><span class="line"></span><br><span class="line">test_1.py F                                                              [100%]</span><br><span class="line"></span><br><span class="line">================================== FAILURES ===================================</span><br><span class="line">_________________________________ test_func1 __________________________________</span><br><span class="line"></span><br><span class="line">    def test_func1():</span><br><span class="line">&gt;       assert 1 == 2</span><br><span class="line">E       assert 1 == 2</span><br><span class="line"></span><br><span class="line">test_1.py:5: AssertionError</span><br><span class="line">========================== 1 failed in 0.11 seconds ===========================</span><br></pre></td></tr></table></figure></p><p><code>F</code>表示运行失败</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pytest学习实践（一）&lt;/p&gt;
    
    </summary>
    
      <category term="python基础" scheme="http://tokyle.com/categories/python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="pytest" scheme="http://tokyle.com/tags/pytest/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（六）</title>
    <link href="http://tokyle.com/2019/06/14/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/14/docker简单使用（六）/</id>
    <published>2019-06-14T06:29:55.000Z</published>
    <updated>2019-06-14T06:30:36.537Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（六）</p><p>数据卷<br><a id="more"></a></p><p>数据卷的使用，类似于linux下的挂载。</p><p>数据卷是一个可供一个或多个容器使用的特殊目录，有以下特性：</p><ul><li>数据卷可以在容器间共享和重用</li><li>对数据卷的修改立刻生效</li><li>对数据卷的更新，不会影响到镜像</li><li>数据卷默认一直存在，即使容器被删除</li></ul><p>创建数据卷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create test_vol</span><br></pre></td></tr></table></figure></p><p>查看数据卷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mynexus]# docker volume ls | grep test</span><br><span class="line">local               test_vol</span><br></pre></td></tr></table></figure></p><p>查看数据卷详细信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mynexus]# docker volume inspect test_vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2019-06-14T14:08:45+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/test_vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;test_vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>启动一个挂载数据卷的容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8077:80 --name web2 --mount source=test_vol,target=/webapp nginx</span><br></pre></td></tr></table></figure></p><p>查看数据卷具体信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker inspect web2</span><br><span class="line"></span><br><span class="line"># 在Mounts节点</span><br><span class="line"> &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;test_vol&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/test_vol/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/webapp&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure></p><p>删除数据卷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm test_vol</span><br></pre></td></tr></table></figure></p><p>删除之前需要将使用这个数据卷的容器关闭，否则报错</p><p>挂载主机目录<br>使用<code>--mount</code>标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8076:80 --name web3 --mount type=bind,source=/home/volumetest,target=/opt/webapp nginx</span><br></pre></td></tr></table></figure><p>本地文件需要存在，否则报错</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（六）&lt;/p&gt;
&lt;p&gt;数据卷&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（五）</title>
    <link href="http://tokyle.com/2019/06/13/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/13/docker简单使用（五）/</id>
    <published>2019-06-14T00:40:45.000Z</published>
    <updated>2019-06-14T05:46:56.644Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（五）</p><p>仓库<br><a id="more"></a></p><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>类似<code>github</code>，docker也有<code>Docker Hub</code>注册了账号之后，也就可以进行镜像的<br>拉取：<code>docker pull nginx</code><br>上传：<code>docker push nginx</code><br>上传到Ddocker Hub时候，可以给自己的镜像一个标注，自己的docker hub id加上镜像<code>kyle/nginx</code>这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:v3 kyle/nginx:v3</span><br><span class="line"></span><br><span class="line">docker push kyle/nginx:v3</span><br></pre></td></tr></table></figure></p><h3 id="私仓"><a href="#私仓" class="headerlink" title="私仓"></a>私仓</h3><p>个人、公司级别的镜像，可能不适合上传到公有仓库，类似gitlab一样，可以在本地创建私有仓库</p><h4 id="创建私仓"><a href="#创建私仓" class="headerlink" title="创建私仓"></a>创建私仓</h4><p>官方提供的工具：<code>docker-registry</code><br>运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8090:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure></p><p>进入容器：<code>docker exec -it registry sh</code><br>仓库默认会创建到容器的该路径：<code>/var/lib/registry</code></p><p>或者通过<code>-v</code>更改路径，将镜像文件放在本地指定路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8081:5000 -v /home/images:/var/lib/registry  --restart=always --name registry2 registry</span><br></pre></td></tr></table></figure></p><p>将本地<code>/home/images</code>作为镜像上传路径，替换默认路径（该文件不存在，会自动创建）</p><h4 id="操作镜像"><a href="#操作镜像" class="headerlink" title="操作镜像"></a>操作镜像</h4><p>先打tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu:16.04 192.168.0.97:8081/ubuntu:16.04</span><br></pre></td></tr></table></figure></p><p>再推送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost images]# docker push 192.168.0.97:8081/ubuntu:16.04</span><br><span class="line">The push refers to repository [192.168.0.97:8081/ubuntu]</span><br><span class="line">Get https://192.168.0.97:8081/v2/: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure></p><p>嗯。失败了、、、因为Docker默认不允许非<code>HTTPS</code>方式推送镜像，解决办法，要么是该配置，要么配置https</p><h4 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h4><p>适用于：<code>ubuntu 16.04+</code>、<code>Debian 8+</code>、<code>centos 7</code><br>修改<code>/etc/docker/daemon.json</code>（不存在就新建）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;:[</span><br><span class="line">        &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;insecure-registries&quot;:[</span><br><span class="line">        &quot;192.168.0.97:8081&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重启docker:<code>systemctl restart docker</code><br>重新push：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost images]# docker push 192.168.0.97:8081/ubuntu:16.04</span><br><span class="line">The push refers to repository [192.168.0.97:8081/ubuntu]</span><br><span class="line">4c54072a5034: Pushed </span><br><span class="line">49652298c779: Pushed </span><br><span class="line">e15278fcccca: Pushed </span><br><span class="line">739482a9723d: Pushed </span><br><span class="line">16.04: digest: sha256:08f4295167241c59fc4a24f18816618ff8f959756fb4b236e880a3b7f45f0ba0 size: 1150</span><br></pre></td></tr></table></figure></p><p>看到成功了。。。<br>在本地<code>/home/images</code>下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# tree images/</span><br><span class="line">images/</span><br><span class="line">└── docker</span><br><span class="line">    └── registry</span><br><span class="line">        └── v2</span><br><span class="line">            ├── blobs</span><br><span class="line">            │   └── sha256</span><br><span class="line">            │       ├── 08</span><br><span class="line">            │       │   └── 08f4295167241c59fc4a24f18816618ff8f959756fb4b236e880a3b7f45f0ba0</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── 2a</span><br><span class="line">            │       │   └── 2a697363a8709093834e852b26bedb1d85b316c613120720fea9524f0e98e4a2</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── 59</span><br><span class="line">            │       │   └── 59856638ac9f32d4caa0f5761b2597fe251642786fdfe1b917ddbb074b890c29</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── 6f</span><br><span class="line">            │       │   └── 6f317d6d954b9a59c54b2cb09e1f30cd3e872796e431cd2ceac5ed570beb2939</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── 9f</span><br><span class="line">            │       │   └── 9ff7e2e5f967fb9c4e8099e63508ab0dddebe3f820d08ca7fd568431b0d10c0e</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       └── a9</span><br><span class="line">            │           └── a9dde5e2a643eca8fde0eed52f4aed31f3ecd9c1b2f24d5e3729cd8d2ae68177</span><br><span class="line">            │               └── data</span><br><span class="line">            └── repositories</span><br><span class="line">                └── ubuntu</span><br><span class="line">                    ├── _layers</span><br><span class="line">                    │   └── sha256</span><br><span class="line">                    │       ├── 2a697363a8709093834e852b26bedb1d85b316c613120720fea9524f0e98e4a2</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       ├── 59856638ac9f32d4caa0f5761b2597fe251642786fdfe1b917ddbb074b890c29</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       ├── 6f317d6d954b9a59c54b2cb09e1f30cd3e872796e431cd2ceac5ed570beb2939</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       ├── 9ff7e2e5f967fb9c4e8099e63508ab0dddebe3f820d08ca7fd568431b0d10c0e</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       └── a9dde5e2a643eca8fde0eed52f4aed31f3ecd9c1b2f24d5e3729cd8d2ae68177</span><br><span class="line">                    │           └── link</span><br><span class="line">                    ├── _manifests</span><br><span class="line">                    │   ├── revisions</span><br><span class="line">                    │   │   └── sha256</span><br><span class="line">                    │   │       └── 08f4295167241c59fc4a24f18816618ff8f959756fb4b236e880a3b7f45f0ba0</span><br><span class="line">                    │   │           └── link</span><br><span class="line">                    │   └── tags</span><br><span class="line">                    │       └── 16.04</span><br><span class="line">                    │           ├── current</span><br><span class="line">                    │           │   └── link</span><br><span class="line">                    │           └── index</span><br><span class="line">                    │               └── sha256</span><br><span class="line">                    │                   └── 08f4295167241c59fc4a24f18816618ff8f959756fb4b236e880a3b7f45f0ba0</span><br><span class="line">                    │                       └── link</span><br><span class="line">                    └── _uploads</span><br></pre></td></tr></table></figure></p><p>使用curl获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# curl 192.168.0.97:8081/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Docker-Compose建私仓"><a href="#Docker-Compose建私仓" class="headerlink" title="Docker Compose建私仓"></a>Docker Compose建私仓</h3><p>参照《docker practice》建私仓，配置全新啊认证，TLS<br>使用openssl自动签发站点SSL证书</p><p>新建一个空白文件夹，进入文件夹，开始操作<br><code>/etc/docker/registry</code></p><h4 id="创建CA私钥"><a href="#创建CA私钥" class="headerlink" title="创建CA私钥"></a>创建CA私钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out &quot;root-ca.key&quot; 4096</span><br></pre></td></tr></table></figure><h4 id="创建CA根证书请求文件"><a href="#创建CA根证书请求文件" class="headerlink" title="创建CA根证书请求文件"></a>创建CA根证书请求文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key &quot;root-ca.key&quot; -out &quot;root-ca.csr&quot; -sha256 \</span><br><span class="line">&gt; -subj &apos;/C=CN/ST=Jiangsu/L=Suzhou/O=Company Xaa/CN=Company Xaa Docker Registry CA&apos;</span><br></pre></td></tr></table></figure><p>其中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/C表示国家，如CN；/ST表示省，如Jiangsu；/L表示城市或地区，如Suzhou；/O表示组织名，如公司名；/CN表示组织通用名称，如公司对外的名称，XXX company</span><br></pre></td></tr></table></figure></p><h4 id="配置CA根证书"><a href="#配置CA根证书" class="headerlink" title="配置CA根证书"></a>配置CA根证书</h4><p><code>vim root-ca.cnf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root_ca]</span><br><span class="line">basicConstraints = critical,CA:TRUE,pathlen:1</span><br><span class="line">keyUsage = critical, nonRepudiation, cRLSign, keyCertSign</span><br><span class="line">subjectKeyIdentifier=hash</span><br></pre></td></tr></table></figure></p><h4 id="签发根证书"><a href="#签发根证书" class="headerlink" title="签发根证书"></a>签发根证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in &quot;root-ca.csr&quot; \</span><br><span class="line">&gt; -signkey &quot;root-ca.key&quot; -sha256 -out &quot;root-ca.crt&quot; \</span><br><span class="line">&gt; -extfile &quot;root-ca.cnf&quot; -extensions \</span><br><span class="line">&gt; root_ca</span><br></pre></td></tr></table></figure><h4 id="生成站点SSL私钥"><a href="#生成站点SSL私钥" class="headerlink" title="生成站点SSL私钥"></a>生成站点SSL私钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out &quot;tokyle.com.key&quot; 4096</span><br></pre></td></tr></table></figure><h4 id="使用私钥生成证书请求文件"><a href="#使用私钥生成证书请求文件" class="headerlink" title="使用私钥生成证书请求文件"></a>使用私钥生成证书请求文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key &quot;tokyle.com.key&quot; -out &quot;site.csr&quot; -sha256 \</span><br><span class="line">&gt; -subj &apos;/C=CN/ST=Jiangsu/L=Suzhou/O=Company Xaa/CN=tokyle.com&apos;</span><br></pre></td></tr></table></figure><h4 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h4><p>新建<code>site.cnf</code>文件 <code>vim site.cnf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints = critical,CA:FALSE</span><br><span class="line">extendedKeyUsage=serverAuth</span><br><span class="line">keyUsage = critical, digitalSignature, keyEncipherment</span><br><span class="line">subjectAltName = DNS:tokyle.com, IP:127.0.0.1</span><br><span class="line">subjectKeyIdentifier=hash</span><br></pre></td></tr></table></figure></p><h4 id="签署站点SSL证书"><a href="#签署站点SSL证书" class="headerlink" title="签署站点SSL证书"></a>签署站点SSL证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 750 -in &quot;site.csr&quot; -sha256 \</span><br><span class="line">&gt; -CA &quot;root-ca.crt&quot; -CAkey &quot;root-ca.key&quot; -CAcreateserial \</span><br><span class="line">&gt; -out &quot;tokyle.com.crt&quot; -extfile &quot;site.cnf&quot; -extensions server</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost registry]# ll</span><br><span class="line">总用量 36</span><br><span class="line">-rw-r--r-- 1 root root  140 6月  13 17:03 root-ca.cnf</span><br><span class="line">-rw-r--r-- 1 root root 2021 6月  13 17:05 root-ca.crt</span><br><span class="line">-rw-r--r-- 1 root root 1708 6月  13 16:49 root-ca.csr</span><br><span class="line">-rw-r--r-- 1 root root 3247 6月  13 16:45 root-ca.key</span><br><span class="line">-rw-r--r-- 1 root root   17 6月  13 17:18 root-ca.srl</span><br><span class="line">-rw-r--r-- 1 root root  237 6月  13 17:14 site.cnf</span><br><span class="line">-rw-r--r-- 1 root root 1679 6月  13 17:10 site.csr</span><br><span class="line">-rw-r--r-- 1 root root 2098 6月  13 17:18 tokyle.com.crt</span><br><span class="line">-rw-r--r-- 1 root root 3243 6月  13 17:08 tokyle.com.key</span><br></pre></td></tr></table></figure><p>这样，就已经拥有了<code>tokyle.com</code>的网站SSL私钥<code>tokyle.com.key</code>和SSL证书<code>tokyle.com.crt</code>及CA根证书<code>root-ca.crt</code></p><p>新建ssl文件夹，将<code>tokyle.com.key</code>、<code>tokyle.com.crt</code>、<code>root-ca.crt</code>拷入，其他删除。</p><h4 id="配置私有仓库"><a href="#配置私有仓库" class="headerlink" title="配置私有仓库"></a>配置私有仓库</h4><p>私仓默认配置文件位于:<code>/etc/docker/registry/config.yml</code>，先本地编辑config.yml再挂在到容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">version: 0.1</span><br><span class="line">log:</span><br><span class="line">  accesslog:</span><br><span class="line">    disabled: true</span><br><span class="line">  level: debug</span><br><span class="line">  formatter: text</span><br><span class="line">  fields:</span><br><span class="line">    service: registry</span><br><span class="line">    environment: staging</span><br><span class="line">storage:</span><br><span class="line">  delete:</span><br><span class="line">    enabled: true</span><br><span class="line">  cache:</span><br><span class="line">    blobdescriptor: inmemory</span><br><span class="line">  filesystem:</span><br><span class="line">    rootdirectory: /var/lib/registry</span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    realm: basic-realm</span><br><span class="line">    path: /etc/docker/registry/auth/nginx.htpasswd</span><br><span class="line">http:</span><br><span class="line">  addr: :443</span><br><span class="line">  host: https://tokyle.com</span><br><span class="line">  headers:</span><br><span class="line">    X-Content-Type-Options: [nosniff]</span><br><span class="line">  http2:</span><br><span class="line">    disabled: false</span><br><span class="line">  tls:</span><br><span class="line">    certificate: /etc/docker/registry/ssl/tokyle.com.crt</span><br><span class="line">    key: /etc/docker/registry/ssl/tokyle.com.key</span><br><span class="line">health:</span><br><span class="line">  storagedriver:</span><br><span class="line">    enabled: true</span><br><span class="line">    interval: 10s</span><br><span class="line">threshold: 3</span><br></pre></td></tr></table></figure></p><h4 id="生成http认证文件"><a href="#生成http认证文件" class="headerlink" title="生成http认证文件"></a>生成http认证文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir auth</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">    --entrypoint htpasswd \</span><br><span class="line">    registry \</span><br><span class="line">    -Bbn username pwd &gt; auth/nginx.htpasswd</span><br></pre></td></tr></table></figure><p>用户名密码用自己的</p><h4 id="编辑docker-compose-yml"><a href="#编辑docker-compose-yml" class="headerlink" title="编辑docker-compose.yml"></a>编辑docker-compose.yml</h4><p><code>vim docker-compose.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  registry:</span><br><span class="line">    image: registry</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;443:443&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./:/etc/docker/registry</span><br><span class="line">      - registry-data:/var/lib/registry</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  registry-data:</span><br></pre></td></tr></table></figure></p><h4 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h4><p><code>vim /etc/hosts</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 tokyle.com</span><br></pre></td></tr></table></figure></p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>安装docker-compose<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U docker-compose</span><br></pre></td></tr></table></figure></p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p><p>由于自行签发的 CA 根证书不被系统信任，所以我们需要将 CA 根证书 ssl/root-ca.crt 移入/etc/docker/certs.d/docker.domain.com 文件夹中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker/certs.d/tokyle.com</span><br><span class="line">cp ssl/root-ca.crt /etc/docker/certs.d/tokyle.com/ca.crt</span><br></pre></td></tr></table></figure></p><h4 id="私仓操作"><a href="#私仓操作" class="headerlink" title="私仓操作"></a>私仓操作</h4><p>登录私仓：<code>docker login tokyle.com</code><br>就可以进行镜像推送、拉取了（需要登录进去）</p><h3 id="参考docker-practice"><a href="#参考docker-practice" class="headerlink" title="参考docker practice"></a>参考docker practice</h3><blockquote><p><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry_auth.html" target="_blank" rel="noopener">私仓高级配置</a></p></blockquote><h3 id="使用Nexus建私仓"><a href="#使用Nexus建私仓" class="headerlink" title="使用Nexus建私仓"></a>使用Nexus建私仓</h3><p>docker官方的registry建立的仓库，有些镜像删除后不会回收空间，必须命令去释放空间，重启Registry程序。当前比较常见的做法是使用<code>Nexus</code>来管理<code>Docker</code>、<code>Yum</code>、<code>PyPI</code>等</p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nexus3 --restart=always \</span><br><span class="line">    -p 8081:8081 sonatype/nexus3</span><br></pre></td></tr></table></figure></p><p>需要等一段时间，可以进容器<code>docker exec -it nexus3 bash</code>，看日志<code>/nexus-data/log/nexus.log</code>看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Started Sonatype Nexus OSS 3.16.2-01</span><br></pre></td></tr></table></figure></p><p>就是起好了，可以通过<a href="http://IP:8088访问web页面。默认账密：`admin/admin123`" target="_blank" rel="noopener">http://IP:8088访问web页面。默认账密：`admin/admin123`</a></p><h4 id="Nexus配置"><a href="#Nexus配置" class="headerlink" title="Nexus配置"></a>Nexus配置</h4><h5 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h5><p>进入nexus界面之后，创建仓库：<br>点击设置（齿轮）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Repository-&gt;Repositories 点击右边菜单 Create repository 选择 docker (hosted)</span><br></pre></td></tr></table></figure></p><ul><li>Name: 仓库的名称，如dockertest</li><li>HTTP: 仓库单独的访问端口，如8082</li><li>Enable Docker V1 API: 如果需要同时支持 V1 版本请勾选此项</li><li>Hosted -&gt; Deployment pollcy: 请选择 Allow redeploy 否则无法上传 Docker 镜像</li></ul><h5 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h5><p>菜单 Security-&gt;Realms 把 Docker Bearer Token Realm 移到右边的框中保存。</p><p>添加用户规则：菜单 Security-&gt;Roles-&gt;Create role 在 Privlleges 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p><p>添加用户：菜单 Security-&gt;Users-&gt;Create local user 在 Roles 选项中选中刚才创建的规则移动到右边的窗口保存。</p><h4 id="操作Nexus私仓"><a href="#操作Nexus私仓" class="headerlink" title="操作Nexus私仓"></a>操作Nexus私仓</h4><p>和之前官方私仓一样，不是https访问，需要在<code>/etc/docker/daemon.json</code>中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   &quot;insecure-registries&quot;:[&quot;http://192.168.0.97:8082&quot;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重启docker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>登录：<code>docker login 192.168.0.97:8082</code>，输入创建的用户名和密码，完成登录。</p><h5 id="Error-response-from-daemon-Get-http-192-168-0-97-8082-v2-dial-tcp-192-168-0-97-8082-connect-connection-refused"><a href="#Error-response-from-daemon-Get-http-192-168-0-97-8082-v2-dial-tcp-192-168-0-97-8082-connect-connection-refused" class="headerlink" title="Error response from daemon: Get http://192.168.0.97:8082/v2/: dial tcp 192.168.0.97:8082: connect: connection refused"></a>Error response from daemon: Get <a href="http://192.168.0.97:8082/v2/" target="_blank" rel="noopener">http://192.168.0.97:8082/v2/</a>: dial tcp 192.168.0.97:8082: connect: connection refused</h5><p><code>docker login 192.168.0.97:8082</code>时候，登录不进去，确认用户名密码正确，确认有添加到daemon.json中。<br>这个问题折腾我一个上午，想来想去，配置的没有问题，然后翻Stack Overflow时候看到差不多的问题，才知道什么鬼。。</p><p>首先，碰到这个，用curl验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http://192.168.0.97:8082/v2/_catalog&quot;</span><br><span class="line"></span><br><span class="line">curl: (7) Failed connect to 192.168.0.97:8082; Connection refused</span><br></pre></td></tr></table></figure></p><p>证明这个端口应该压根就没起来，然后往回翻，看看起nexus3这个容器的命令，发现是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nexus3 --restart=always \</span><br><span class="line">    -p 8081:8081 sonatype/nexus3</span><br></pre></td></tr></table></figure></p><p>只给nexus3分配了8081端口，没有其他端口暴露出来，即使在页面设置了8082端口，因为8082是在容器内部，没有暴露出来，所以在服务器上，根本就连不到192.168.0.97的8082端口，解决办法就是暴露出8082端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8081:8081 -p 8082:8082 -p 8083:8083 --restart=always --name nexus3 sonatype/nexus3</span><br></pre></td></tr></table></figure></p><p>然后再进入nexus页面重新设置，这样，就可以登陆了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost log]# docker login 192.168.0.97:8082</span><br><span class="line">Username: admin</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure></p><h5 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h5><p>首先登录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker login 192.168.0.97:8082</span><br><span class="line">Username: kyle</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure></p><p>镜像操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:v2 192.168.0.97:8082/nginx:v2</span><br><span class="line"></span><br><span class="line">[root@localhost docker]# docker push 192.168.0.97:8082/nginx:v2</span><br><span class="line">The push refers to repository [192.168.0.97:8082/nginx]</span><br><span class="line">7df9ba6b1822: Pushed </span><br><span class="line">ea06a73e56fc: Pushed </span><br><span class="line">22c458a3ff08: Pushed </span><br><span class="line">6270adb5794c: Pushed </span><br><span class="line">v2: digest: sha256:619a4fd83aef966bbee5677f0a2c169ae990cf83b9183aed0969c991b04e23dc size: 1155</span><br></pre></td></tr></table></figure></p><p>可以到nexus界面的Docker栏看到推送上去的镜像。</p><p>删除本地镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker image ls</span><br><span class="line">REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.0.97:8082/nginx   v2                  f531cfc896d6        3 days ago          109MB</span><br><span class="line">nginx                     v2                  f531cfc896d6        3 days ago          109MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost docker]# docker rmi 192.168.0.97:8082/nginx:v2</span><br><span class="line">Untagged: 192.168.0.97:8082/nginx:v2</span><br><span class="line">Untagged: 192.168.0.97:8082/nginx@sha256:619a4fd83aef966bbee5677f0a2c169ae990cf83b9183aed0969c991b04e23dc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost docker]# docker image ls</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                 v2                  f531cfc896d6        3 days ago          109MB</span><br></pre></td></tr></table></figure></p><p>从nexus私仓拉取镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker pull 192.168.0.97:8082/nginx:v2</span><br><span class="line">v2: Pulling from nginx</span><br><span class="line">Digest: sha256:619a4fd83aef966bbee5677f0a2c169ae990cf83b9183aed0969c991b04e23dc</span><br><span class="line">Status: Downloaded newer image for 192.168.0.97:8082/nginx:v2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost docker]# docker image ls</span><br><span class="line">REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.0.97:8082/nginx   v2                  f531cfc896d6        3 days ago          109MB</span><br><span class="line">nginx                     v2                  f531cfc896d6        3 days ago          109MB</span><br></pre></td></tr></table></figure></p><p>退出私仓：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker logout 192.168.0.97:8082</span><br><span class="line">Removing login credentials for 192.168.0.97:8082</span><br></pre></td></tr></table></figure></p><p>然后，可以对自己的私仓加上个<strong>s</strong>，更安全一点，这个，教程一堆</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（五）&lt;/p&gt;
&lt;p&gt;仓库&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（四）</title>
    <link href="http://tokyle.com/2019/06/13/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/13/docker简单使用（四）/</id>
    <published>2019-06-13T06:48:29.000Z</published>
    <updated>2019-06-13T06:49:04.406Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（四）</p><p>Docker容器操作<br><a id="more"></a></p><h3 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h3><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>构建完镜像之后，启动容器<br>例如：<code>docker run -it ubintu:16.04 bash</code>，启ubuntu，并开启交互终端</p><h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><p>容器已经关闭，可以使用<code>docker container start containerID(或name)</code>启动<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser2]# docker run --name web1 -d -p 8088:80 nginx</span><br><span class="line">73a5c1a3ac2300f6e2317ae39c9571b84be07e44beb92fcb98b41ee68aa6672a</span><br><span class="line"></span><br><span class="line">[root@localhost myuser2]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                          PORTS                  NAMES</span><br><span class="line">73a5c1a3ac23        nginx               &quot;nginx -g &apos;daemon of…&quot;   14 seconds ago      Up 4 seconds                    0.0.0.0:8088-&gt;80/tcp   web1</span><br></pre></td></tr></table></figure></p><p>关掉容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser2]# docker kill 73a5c1a3ac23</span><br><span class="line">73a5c1a3ac23</span><br><span class="line"></span><br><span class="line">[root@localhost myuser2]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                        PORTS               NAMES</span><br><span class="line">73a5c1a3ac23        nginx               &quot;nginx -g &apos;daemon of…&quot;   About a minute ago   Exited (137) 14 seconds ago                       web1</span><br></pre></td></tr></table></figure></p><p>重新启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser2]# docker container start 73a5c1a3ac23</span><br><span class="line">73a5c1a3ac23</span><br><span class="line"></span><br><span class="line">[root@localhost myuser2]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                     PORTS                  NAMES</span><br><span class="line">73a5c1a3ac23        nginx               &quot;nginx -g &apos;daemon of…&quot;   About a minute ago   Up 9 seconds               0.0.0.0:8088-&gt;80/tcp   web1</span><br></pre></td></tr></table></figure></p><p><code>docker container start -i  5879098886bf</code>以交互模式重启</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>推荐<code>docker exec</code>，交互模式：<code>docker exec -it container</code></p><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>可以<code>docker container stop containerid(name)</code><br>也可以暴力的<code>dokcer kill containerid</code></p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p><code>docker rm containerid</code></p><p>删除镜像：<code>docker rmi imageid</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（四）&lt;/p&gt;
&lt;p&gt;Docker容器操作&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（三）</title>
    <link href="http://tokyle.com/2019/06/12/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/12/docker简单使用（三）/</id>
    <published>2019-06-13T02:43:54.000Z</published>
    <updated>2019-06-13T02:44:32.823Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（三）</p><p>Dockerfile简介二<br><a id="more"></a><br>简单介绍Dockerfile的一些指令</p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>COPY，复制文件指令，格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;源路径&gt;  &lt;目标路径&gt;</span><br></pre></td></tr></table></figure></p><p>另一种格式类似函数调用：<code>COPY [&quot;&lt;源路径&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p><p>COPY指令作用是从构建上下文目录中<code>&lt;源路径&gt;</code>（相对于上下文的路径）下的文件复制到镜像中的<code>目标路径</code></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY test1.txt /usr/local/test/</span><br></pre></td></tr></table></figure></p><p>将当前上下文目录下的test1.txt复制到新镜像的/usr/local/test/文件夹下<br>&lt;目标路径&gt;可以是容器内的绝对路径，也可以是相对于<code>WOKDIR</code>的相对路径</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>不实用的命令，有拷贝的功能，同时，可以拷贝url，但是使用ADD url时，docker会先将url的文件下载下来，如果是个压缩包，还需要自己添加一层RUN进行解压，剔除不需要的文件，再复制；所以不如直接RUN wget，然后解压缩，剔除文件复制</p><p>ADD命令在有一种情况下很有用，源路径是一个gzip，bzip2以及xz的压缩包，ADD会自动解压压缩包到目标路径。</p><p>在《docker practice》中指出，<strong>在COPY和ADD指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用COPY指令，仅在需要自动解压缩场合使用ADD</strong></p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>首先要理解，容器是进程，不是虚拟机，在正常linux中，运行进程一般都伴随有启动参数，类似的，容器也有，CMD就是用于指定默认的容器主进程的启动命令的</p><p>格式：<br><code>shell</code>格式：<code>CMD &lt;命令&gt;</code><br><code>exec</code>格式：<code>CMD [&quot;可执行文件&quot;， &quot;参数1&quot;, &quot;参数2&quot;...]</code></p><p>在运行时，可以使用CMD来指定新的命令来替代镜像中设置的默认命令，例如，ubuntu镜像的默认CMD是<code>/bin/bash</code>，如果我们直接<code>docker run -it ubuntu:16.04</code>会直接进入<code>bash</code>；也可以指定别的命令，例如输出系统版本：<code>docker run -it ubuntu:16.04 cat /etc/os-rlease</code></p><p>在指令格式上，推荐使用<code>CMD [&quot;可执行文件&quot;， &quot;参数1&quot;, &quot;参数2&quot;...]</code>，这类格式会被解析成JSON，因此一定要是用双引号<code>&quot;</code><br>如果使用shell格式，例如<code>CMD echo $JAVA_HOME</code>在实际执行中会变更为<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $JAVA_HOME&quot;]</code>，实际会被包装成<code>sh -c</code>的参数形式。（这也是shell中可以直接使用环境变量的原因）</p><p>前面说过，容器其实就是进程，本身就是进程，所以就不存在什么进程里面的程序有后台执行的说法了，容器中的应用，都是在前台执行的，不存在systemctl这样的操作，不会像虚拟机中有<code>systemctl start mysqld</code>这样的操作，如果使用CMD写成这样的：<code>CMD systemctl start nginx</code>，会发现容器执行后立刻退出。</p><p>这是因为，docker容器，默认会把容器内部第一个进程，也就是pid=1的程序作为docker容器正在运行的依据，如果容器中pid=1的程序挂了，那docker容器就会直接退出；在执行<code>CMD systemctl start nginx</code>时候，实际执行的是<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;systemctl start nginx&quot;]</code>，起初pid=1的程序是bash，但是后面接上了systemctl start nginx（后台守护模式daemon启动nginx），使得systemctl start nginx进程启动后，sh也结束了（CMD会更改默认命令），当pid=1的程序结束，容器就退出了。所以只要运行程序时候，在非守护模式下，容器就不会退出，因此，容器内启动nginx可以：<code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off&quot;]</code></p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>和CMD类似，不同的是，CMD会被docker run覆盖，而ENTERPOINT不会，例如以下一个最简单的镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">CMD [&quot;/bin/echo&quot;, &quot;test&quot;]</span><br></pre></td></tr></table></figure></p><p>构建镜像：<code>docker build -t echotest .</code>，<br>运行容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myip]# docker run echotest </span><br><span class="line">test</span><br></pre></td></tr></table></figure></p><p>但是既然容器是进程，那如果像其他进程一样，加参数，效果如何：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myip]# docker run echotest -i</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;exec: \&quot;-i\&quot;: executable file not found in $PATH&quot;: unknown.</span><br><span class="line">ERRO[0001] error waiting for container: context canceled</span><br></pre></td></tr></table></figure></p><p>直接就报错了。。这是因为跟在镜像名之后的执行，会替换调CMD的默认值，但是-i又不是个指令，所以就报错了。</p><p>ENTRYPOINT在这点上就可以做到带参数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;test&quot;]</span><br></pre></td></tr></table></figure></p><p>构建：<code>docker build -t echotest2 .</code>，运行容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost echotest]# docker run echotest2 -i</span><br><span class="line">test -i</span><br></pre></td></tr></table></figure></p><p>可以看到，-i可以带进去。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>顾名思义，设置环境变量<code>ENV JAVA_VERSION 1.8.0_191</code></p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>和ENV类似，都是设置环境变量。区别在于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The ARG instruction defines a variable that users can pass at build-time to the builder with the docker build command using the --build-arg &lt;varname&gt;=&lt;value&gt; flag.ARG指令定义了用户可以在编译时或者运行时传递的变量，如使用如下命令：--build-arg &lt;varname&gt;=&lt;value&gt;</span><br><span class="line"></span><br><span class="line">The ENV instruction sets the environment variable &lt;key&gt; to the value &lt;value&gt;. The environment variables set using ENV will persist when a container is run from the resulting image.ENV指令是在dockerfile里面设置环境变量，不能在编译时或运行时传递。</span><br></pre></td></tr></table></figure></p><p>例如，在Dockerfile中定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG a_key1</span><br><span class="line">ARG a_key2 = a_value2</span><br></pre></td></tr></table></figure></p><p>ARG指令定义的参数，在docker build命令中可以通过–build-arg a_key1=avalue1来覆盖</p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>创建一个可以从本地主机或其他容器挂载的挂在点，格式：<code>VOLUME [&quot;/data&quot;]</code><br>对于数据库类需要保存动态数据的应用，数据库文件应该保存在卷（volume）。为了防止运行时用户忘记将动态文件所保存的目录挂在为卷，在写Dockerfile时，就可以事先指定某些目录挂载为匿名卷，这样运行时如果用户不挂载，应用也可以正常运行，不会向容器存储层写大量数据</p><p><code>VOLUME [&quot;/data&quot;]</code>,这里的<code>/data</code>目录就会在运行时自动挂载为匿名卷，任何向/data中写入的信息都不会记录进容器存储层。当然，docker run时候也可以覆盖这个设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data/tmp mysql</span><br></pre></td></tr></table></figure></p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>声明端口，格式：<code>EXPOSE &lt;port1&gt; &lt;port2&gt;</code><br>用来指定要映射出去的端口，例如，容器内部开启了nginx,就需要将80（或者指定的端口）暴露出去：<code>EXPOSE 80</code>。这个需要-P（大写）配合，启动容器是，加上-P，让它自动分配。如果想指定具体端口，使用-p(小写)</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定工作目录，格式：<code>WORKDIR &lt;工作目录路径&gt;</code>，作用就是为后续的<code>RUN</code>、<code>COPY</code>等指定工作目录<br>在Dockerfile中，每个RUN，都会启一个容器，都是一个<code>启动容器</code>、<code>执行命令</code>、<code>提交存储层文件变更</code>的操作。<br>示例，如果Dockerfile这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN cd /home \</span><br><span class="line">    &amp;&amp; mkdir myapp \</span><br><span class="line">    &amp;&amp; cd myapp</span><br><span class="line">RUN echo &quot;docker practice&quot; &gt; test1.txt</span><br></pre></td></tr></table></figure></p><p>然后构建镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myworkfile]# docker build -t workfile1 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/3 : FROM ubuntu:16.04</span><br><span class="line"> ---&gt; 2a697363a870</span><br><span class="line">Step 2/3 : RUN cd /home     &amp;&amp; mkdir myapp     &amp;&amp; cd myapp</span><br><span class="line"> ---&gt; Running in a33b48c39597</span><br><span class="line">Removing intermediate container a33b48c39597</span><br><span class="line"> ---&gt; daebc80cbf9d</span><br><span class="line">Step 3/3 : RUN echo &quot;docker practice&quot; &gt; test1.txt</span><br><span class="line"> ---&gt; Running in 500473ff3363</span><br><span class="line">Removing intermediate container 500473ff3363</span><br><span class="line"> ---&gt; 4a1668a9a53c</span><br><span class="line">Successfully built 4a1668a9a53c</span><br><span class="line">Successfully tagged workfile1:latest</span><br></pre></td></tr></table></figure></p><p>可以看到，构建过程中，出现了两个中间容器<code>a33b48c39597</code>和<code>500473ff3363</code>，所以这两个RUN，其实运行的是不一样的容器，最终结果，启动容器后在<code>/home/myapp</code>下可能就找不到<code>test1.txt</code>，验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myworkfile]# docker run -it workfile1 bash</span><br><span class="line">root@3a7bbb6da9a2:/# cd /home/</span><br><span class="line">root@3a7bbb6da9a2:/home# ls</span><br><span class="line">myapp</span><br><span class="line">root@3a7bbb6da9a2:/home# cd myapp/</span><br><span class="line">root@3a7bbb6da9a2:/home/myapp# ls</span><br><span class="line">root@3a7bbb6da9a2:/home/myapp#</span><br></pre></td></tr></table></figure></p><p>没有找到test1.txt</p><p>使用WORKDIR:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">WORKDIR /home/myapp</span><br><span class="line">RUN echo &quot;docker practice&quot; &gt; test2.txt</span><br></pre></td></tr></table></figure></p><p>构建镜像，运行容器，查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myworkfile2]# docker build -t workfile2 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/3 : FROM ubuntu:16.04</span><br><span class="line"> ---&gt; 2a697363a870</span><br><span class="line">Step 2/3 : WORKDIR /home/myapp</span><br><span class="line"> ---&gt; Running in a64c73b81fcb</span><br><span class="line">Removing intermediate container a64c73b81fcb</span><br><span class="line"> ---&gt; c7868d92cec6</span><br><span class="line">Step 3/3 : RUN echo &quot;docker practice&quot; &gt; test2.txt</span><br><span class="line"> ---&gt; Running in f18afb589fee</span><br><span class="line">Removing intermediate container f18afb589fee</span><br><span class="line"> ---&gt; 8733481c9491</span><br><span class="line">Successfully built 8733481c9491</span><br><span class="line">Successfully tagged workfile2:latest</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myworkfile2]# docker run -it workfile2 bash</span><br><span class="line">root@8bc345cf4fe7:/home/myapp# ls</span><br><span class="line">test2.txt</span><br><span class="line">root@8bc345cf4fe7:/home/myapp# cat test2.txt </span><br><span class="line">docker practic</span><br></pre></td></tr></table></figure><p>看到在<code>/home/myapp</code>下有<code>test2.txt</code>，并且内容是我们指定的。</p><p>Ps 在Dockerfile中，这边只使用<code>WORKDIR /home/myapp</code>并没有创建该目录，但是，后面执行就是在该目录下，这是因为<code>WORKDIR</code>会帮你建立目录</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>和<code>WORKDIR</code>类似，指定之后执行<code>RUN</code>、<code>COPY</code>等命令的用户；</p><p>示例一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">USER kyle</span><br><span class="line">RUN echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure></p><p>构建镜像:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser2]# docker build -t myuser2 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/3 : FROM ubuntu:16.04</span><br><span class="line"> ---&gt; 2a697363a870</span><br><span class="line">Step 2/3 : USER kyle</span><br><span class="line"> ---&gt; Running in b9af960d2702</span><br><span class="line">Removing intermediate container b9af960d2702</span><br><span class="line"> ---&gt; ba5592dfdba1</span><br><span class="line">Step 3/3 : RUN echo &quot;Hello world&quot;</span><br><span class="line"> ---&gt; Running in d93f1b59934c</span><br><span class="line">unable to find user kyle: no matching entries in passwd file</span><br></pre></td></tr></table></figure></p><p>发现报错，kyle该用户不存在，镜像<code>myuser2</code>构建不成功</p><p>示例二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser1]# cat Dockerfile </span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN groupadd -r tests &amp;&amp; useradd -r -g tests kyle</span><br><span class="line">USER kyle</span><br><span class="line">RUN echo &quot;Hello World&quot;</span><br></pre></td></tr></table></figure></p><p>构建镜像，运行容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser1]# docker build -t myuser1 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM ubuntu:16.04</span><br><span class="line"> ---&gt; 2a697363a870</span><br><span class="line">Step 2/4 : RUN groupadd -r tests &amp;&amp; useradd -r -g tests kyle</span><br><span class="line"> ---&gt; Running in 95030508e783</span><br><span class="line">Removing intermediate container 95030508e783</span><br><span class="line"> ---&gt; 8910cd5c0ee0</span><br><span class="line">Step 3/4 : USER kyle</span><br><span class="line"> ---&gt; Running in 5ca75c068a8b</span><br><span class="line">Removing intermediate container 5ca75c068a8b</span><br><span class="line"> ---&gt; 17e120181a8a</span><br><span class="line">Step 4/4 : RUN echo &quot;Hello World&quot;</span><br><span class="line"> ---&gt; Running in 022b81376556</span><br><span class="line">Hello World</span><br><span class="line">Removing intermediate container 022b81376556</span><br><span class="line"> ---&gt; 73527faf6379</span><br><span class="line">Successfully built 73527faf6379</span><br><span class="line">Successfully tagged myuser1:latest</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser1]# docker run -it myuser1 bash</span><br><span class="line">kyle@55b05690325a:/$ whoami</span><br><span class="line">kyle</span><br></pre></td></tr></table></figure><p>成功构建镜像，切换用户。</p><p>这两个示例可以看出，使用<code>USER</code>之前，必须创建好用户，也就是<strong><code>USER</code>不会帮你建用户，只是切换用户</strong></p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>指定制作作者信息，格式：<code>MAINTAINER &lt;name&gt;</code>，例如<code>MAINTAINER kyle kyle@xxx.com</code></p><p>以上，就是Dockerfile一些常用的指令，基本是借鉴的<a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">《docker practice》</a>…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（三）&lt;/p&gt;
&lt;p&gt;Dockerfile简介二&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客配置https</title>
    <link href="http://tokyle.com/2019/06/11/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AEhttps/"/>
    <id>http://tokyle.com/2019/06/11/hexo博客配置https/</id>
    <published>2019-06-11T09:30:35.000Z</published>
    <updated>2019-06-11T09:37:59.043Z</updated>
    
    <content type="html"><![CDATA[<p>hexo博客配置https</p><a id="more"></a><p>整天被chrome提醒不安全，简直了，实在忍不下去了，给博客加个s</p><p>方法很简单，到<a href="https://dash.cloudflare.com/login" target="_blank" rel="noopener">CloudFlare</a>解析域名，开启CDN强制http转https，修改DNS即可</p><p>原DNS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dns23.hichina.com</span><br><span class="line"></span><br><span class="line">dns24.hichina.com</span><br></pre></td></tr></table></figure></p><p>修改后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cortney.ns.cloudflare.com</span><br><span class="line"></span><br><span class="line">lloyd.ns.cloudflare.com</span><br></pre></td></tr></table></figure></p><p><code>CloudFlare</code>注册以后配置很简单，基本输入自己域名（tokyle.com）下一步下一步就结束了</p><p>就最后有一步配置DNS:<code>DNS Manage your Domain Name System (DNS) settings</code>时候，CNAME配置自己的域名，然后到对应的域名提供商（阿里云）去修改DNS解析</p><p>成功之后，CloudFlare会邮件给你，就可以愉快的https了：</p><blockquote><p><a href="https://tokyle.com">https://tokyle.com</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo博客配置https&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://tokyle.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Hexo" scheme="http://tokyle.com/tags/Hexo/"/>
    
      <category term="https" scheme="http://tokyle.com/tags/https/"/>
    
  </entry>
  
</feed>
