<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>它夏了夏天</title>
  
  <subtitle>生命中有一种遇见，就让它美如行云流水，然后一生去回味。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tokyle.com/"/>
  <updated>2019-06-27T03:17:47.756Z</updated>
  <id>http://tokyle.com/</id>
  
  <author>
    <name>Kyle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Influxdb启动失败日志定位</title>
    <link href="http://tokyle.com/2019/06/26/Influxdb%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E6%97%A5%E5%BF%97%E5%AE%9A%E4%BD%8D/"/>
    <id>http://tokyle.com/2019/06/26/Influxdb启动失败日志定位/</id>
    <published>2019-06-27T03:15:54.000Z</published>
    <updated>2019-06-27T03:17:47.756Z</updated>
    
    <content type="html"><![CDATA[<p>Influxdb启动失败日志定位</p><a id="more"></a><p>之前做过Jmeter使用influxdb和grafana展示测试数据，当时使用了graphite，现在看到Jmeter好像可以直接存在influxdb中，就想尝试下，就找了台机器搭建influxdb，然后悲剧了，起不来。</p><p>其实问题很简单，基本不是端口占用就是文件夹权限问，主要是找不到日志。。</p><p>下面是完整的经过<br>搭建完influxdb，并且<code>systemctl start influxdb</code>之后，想连进去看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@tokyle bin]# influx</span><br><span class="line">Failed to connect to http://localhost:8086: Get http://localhost:8086/ping: dial tcp [::1]:8086: connect: connection refused</span><br><span class="line">Please check your connection settings and ensure &apos;influxd&apos; is running.</span><br></pre></td></tr></table></figure></p><p>进不去。。检查状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@tokyle bin]# systemctl  status  influxdb</span><br><span class="line">● influxdb.service - InfluxDB is an open-source, distributed, time series database</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/influxdb.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: start-limit) since 四 2019-06-27 11:00:45 CST; 2min 0s ago</span><br><span class="line">     Docs: https://docs.influxdata.com/influxdb/</span><br><span class="line">  Process: 3587 ExecStart=/usr/bin/influxd -config /etc/influxdb/influxdb.conf $INFLUXD_OPTS (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 3587 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">6月 27 11:00:44 tokyle.com systemd[1]: Unit influxdb.service entered failed state.</span><br><span class="line">6月 27 11:00:44 tokyle.com systemd[1]: influxdb.service failed.</span><br><span class="line">6月 27 11:00:45 tokyle.com systemd[1]: influxdb.service holdoff time over, scheduling restart.</span><br><span class="line">6月 27 11:00:45 tokyle.com systemd[1]: Stopped InfluxDB is an open-source, distributed, time series database.</span><br><span class="line">6月 27 11:00:45 tokyle.com systemd[1]: start request repeated too quickly for influxdb.service</span><br><span class="line">6月 27 11:00:45 tokyle.com systemd[1]: Failed to start InfluxDB is an open-source, distributed, time series database.</span><br><span class="line">6月 27 11:00:45 tokyle.com systemd[1]: Unit influxdb.service entered failed state.</span><br><span class="line">6月 27 11:00:45 tokyle.com systemd[1]: influxdb.service failed.</span><br></pre></td></tr></table></figure></p><p>压根没起来</p><p>找日志，先到<code>/var/lib/influxdb</code>下，没知道，<code>/var/log/</code>没找到</p><p>找<strong>系统日志</strong><br><code>journalctl -u influxdb</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u influxdb</span><br><span class="line"></span><br><span class="line">6月 27 10:46:02 tokyle.com systemd[1]: influxdb.service: main process exited, code=exited, status=1/FAILURE</span><br><span class="line">6月 27 10:46:02 tokyle.com systemd[1]: Unit influxdb.service entered failed state.</span><br><span class="line">6月 27 10:46:02 tokyle.com systemd[1]: influxdb.service failed.</span><br><span class="line">6月 27 10:46:03 tokyle.com systemd[1]: influxdb.service holdoff time over, scheduling restart.</span><br><span class="line">6月 27 10:46:03 tokyle.com systemd[1]: Stopped InfluxDB is an open-source, distributed, time series database.</span><br><span class="line">6月 27 10:46:03 tokyle.com systemd[1]: start request repeated too quickly for influxdb.service</span><br><span class="line">6月 27 10:46:03 tokyle.com systemd[1]: Failed to start InfluxDB is an open-source, distributed, time series database.</span><br></pre></td></tr></table></figure></p><p>还是看不出什么问题</p><p>最后，不使用systemctl直接手工启动influxdb：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop influxdb</span><br><span class="line"></span><br><span class="line">cd /usr/bin</span><br><span class="line"></span><br><span class="line">[root@tokyle bin]# influxd -config /etc/influxdb/influxdb.conf </span><br><span class="line"></span><br><span class="line"> 8888888           .d888 888                   8888888b.  888888b.</span><br><span class="line">   888            d88P&quot;  888                   888  &quot;Y88b 888  &quot;88b</span><br><span class="line">   888            888    888                   888    888 888  .88P</span><br><span class="line">   888   88888b.  888888 888 888  888 888  888 888    888 8888888K.</span><br><span class="line">   888   888 &quot;88b 888    888 888  888  Y8bd8P&apos; 888    888 888  &quot;Y88b</span><br><span class="line">   888   888  888 888    888 888  888   X88K   888    888 888    888</span><br><span class="line">   888   888  888 888    888 Y88b 888 .d8&quot;&quot;8b. 888  .d88P 888   d88P</span><br><span class="line"> 8888888 888  888 888    888  &quot;Y88888 888  888 8888888P&quot;  8888888P&quot;</span><br><span class="line"></span><br><span class="line">2019-06-27T03:04:08.786635ZinfoInfluxDB starting&#123;&quot;log_id&quot;: &quot;0GHj5JKW000&quot;, &quot;version&quot;: &quot;1.6.1&quot;, &quot;branch&quot;: &quot;1.6&quot;, &quot;commit&quot;: &quot;5766854b95ae86cccf6cc8ffe4c5bb9eacc994b8&quot;&#125;</span><br><span class="line">2019-06-27T03:04:08.786678ZinfoGo runtime&#123;&quot;log_id&quot;: &quot;0GHj5JKW000&quot;, &quot;version&quot;: &quot;go1.10.3&quot;, &quot;maxprocs&quot;: 4&#125;</span><br><span class="line">run: open server: listen: listen tcp 127.0.0.1:8088: bind: address already in use</span><br></pre></td></tr></table></figure></p><p>终于看见了，端口被占用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tokyle bin]# netstat -anp | grep 8088</span><br><span class="line">tcp6       0      0 :::8088                 :::*                    LISTEN      22329/docker-proxy</span><br></pre></td></tr></table></figure><p>docker占了8088,问题解决</p><p>以上经过，记住，influxdb找不到日志：</p><ol><li>journalctl -u influxdb</li><li>/usr/bin/influxd -config /etc/influxdb/influxdb.conf</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Influxdb启动失败日志定位&lt;/p&gt;
    
    </summary>
    
      <category term="Devops" scheme="http://tokyle.com/categories/Devops/"/>
    
    
      <category term="Influxdb" scheme="http://tokyle.com/tags/Influxdb/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter ForEach控制器使用</title>
    <link href="http://tokyle.com/2019/06/26/Jmeter-ForEach%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://tokyle.com/2019/06/26/Jmeter-ForEach控制器使用/</id>
    <published>2019-06-27T01:56:28.000Z</published>
    <updated>2019-06-27T02:01:11.690Z</updated>
    
    <content type="html"><![CDATA[<p>Jmeter ForEach控制器使用</p><a id="more"></a><p>昨天遇到的问题，有个接口需要循环删除多个taskid（前一个接口获得），找了网上资料，最后成功实现</p><h3 id="ForEach控制器"><a href="#ForEach控制器" class="headerlink" title="ForEach控制器"></a>ForEach控制器</h3><p>ForEach控制器一般和用户自定义变量一起使用，其在用户自定义变量中读取一系列相关的变量。该控制器下的采样器或控制器都会被执行一次或多次，每次读取不同的变量值</p><p>字段解释：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Input Variable Prefix</td><td>输入变量前缀</td></tr><tr><td>Output variable name</td><td>输出变量名称</td></tr><tr><td>Start index for loop(exclusive)</td><td>循环开始的索引（这里如果不填写，默认从1开始，如果没有1开始的变量，执行时会报错）</td></tr><tr><td>End index for loop(inclusive)</td><td>循环结束的索引</td></tr><tr><td>Add”_”before number</td><td>输入变量名称中是否使用“_”进行间隔</td></tr></tbody></table><h3 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h3><p>ForEach控制器一般喝<code>用户定义的变量</code>一起使用<br>结构类似这样：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ffkn6taqj20wp089t9m.jpg" alt="ForEach示例"></p><p>在<code>用户定义的变量</code>插件中定义了四个name，在后续http请求，需要每个都传进去执行一次，也就是整个线程组执行是一次，其中http请求会执行四次，并且每次使用不通的name</p><p>ForEach控制器配置：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ffnhsjnlj20a906owf2.jpg" alt="ForEach控制器配置"></p><p>传入name，输出testname，在后续http请求中，name替换成<code>${testname}</code>即可<br>看看效果：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ffrpyrraj20ld08oq4t.jpg" alt="执行效果"></p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>回到之前那个删除taskid的问题，可以采用同样的方式，只要保证，传给ForEach控制器的是key:value形式，并且是同一个key，不同的value</p><p><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ffwmsfu7j20ju081wg0.jpg" alt="11"></p><p>其中search接口返回数据大概是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;taskId&quot;:&quot;5d12ddc64d44wserwreeaa4cb56&quot;,</span><br><span class="line">        &quot;input&quot;:Object&#123;...&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;taskId&quot;:&quot;5d12ddc64ereea017eaa4cb56&quot;,</span><br><span class="line">        &quot;input&quot;:Object&#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>可以看到返回值中有多个taskId，这些taskId是需要全部传给后续delete接口删除的<br>可以用JSON提取出所有的taskID，再传给ForEach控制器，输出一个新的变量taskidItem，将该taskidItem传给delete接口，达到有多少taskId，delete接口就取不同的taskId循环多少次，最终全部删除的效果</p><p><code>JSON Extractor</code>配置：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4fg1x4m2wj20wn07jq4x.jpg" alt="JSON Extractor"></p><p>以上就是本次实现，ForEach控制器，总的来说，适用于有多个value值返回，并且这些value值都需要进行后续操作的场景</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jmeter ForEach控制器使用&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Jmeter" scheme="http://tokyle.com/tags/Jmeter/"/>
    
  </entry>
  
  <entry>
    <title>性能监控简单小结</title>
    <link href="http://tokyle.com/2019/06/26/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%AE%80%E5%8D%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://tokyle.com/2019/06/26/性能监控简单小结/</id>
    <published>2019-06-26T07:39:34.000Z</published>
    <updated>2019-06-26T07:41:01.031Z</updated>
    
    <content type="html"><![CDATA[<p>性能监控简单小结</p><p>涉及MySQL和JVM<br><a id="more"></a></p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>首先是MySQL的常用监控项</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li><p>缓存概览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%Query_cache%%&quot;;</span><br><span class="line">+------------------------------+----------+</span><br><span class="line">| Variable_name                | Value    |</span><br><span class="line">+------------------------------+----------+</span><br><span class="line">| have_query_cache             | YES      |</span><br><span class="line">| query_cache_limit            | 16777216 |</span><br><span class="line">| query_cache_min_res_unit     | 4096     |</span><br><span class="line">| query_cache_size             | 16777216 |</span><br><span class="line">| query_cache_type             | OFF      |</span><br><span class="line">| query_cache_wlock_invalidate | OFF      |</span><br><span class="line">+------------------------------+----------+</span><br><span class="line">6 rows in set (0.24 sec)</span><br></pre></td></tr></table></figure></li><li><p>缓存碎片率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status  like &quot;%Qcache%&quot;;</span><br><span class="line">+-------------------------+----------+</span><br><span class="line">| Variable_name           | Value    |</span><br><span class="line">+-------------------------+----------+</span><br><span class="line">| Qcache_free_blocks      | 1        |</span><br><span class="line">| Qcache_free_memory      | 16760152 |</span><br><span class="line">| Qcache_hits             | 0        |</span><br><span class="line">| Qcache_inserts          | 0        |</span><br><span class="line">| Qcache_lowmem_prunes    | 0        |</span><br><span class="line">| Qcache_not_cached       | 19860231 |</span><br><span class="line">| Qcache_queries_in_cache | 0        |</span><br><span class="line">| Qcache_total_blocks     | 1        |</span><br><span class="line">+-------------------------+----------+</span><br><span class="line">8 rows in set (0.21 sec)</span><br></pre></td></tr></table></figure></li></ul><p>其中，如果Qcache_free_blocks大致等于Qcache_total_blocks/2，说明碎片非常严重<br>如果Qcache_lowmem_prunes的值正在增加，并且有大量的自由块，表示碎片导致查询正在被从缓存中永久删除</p><p><strong>缓存碎片率 = Qcache_free_block/Qcache_total_blocks *100%</strong>如果查询缓存碎片率都超过20%，可以使用<code>FLUSH QUERY CACHE</code>整理缓存碎片</p><p><strong>缓存利用率 = （query_cache_size - Qcache_free_memory）/ query_cache_size *100% </strong><br>查询缓存利用率低于25%，表明query_cache_size值设置过大，可以适当减小；<br>查询利用率在80%以上，并且Qcache_lowmem_prunes &gt;50，表明query_cache_size值太小或者碎片太多</p><ul><li>thread_cache_size<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;thread%&quot;;</span><br><span class="line">+-------------------+---------------------------+</span><br><span class="line">| Variable_name     | Value                     |</span><br><span class="line">+-------------------+---------------------------+</span><br><span class="line">| thread_cache_size | 32                        |</span><br><span class="line">| thread_handling   | one-thread-per-connection |</span><br><span class="line">| thread_stack      | 262144                    |</span><br><span class="line">+-------------------+---------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p>缓存在Cache中的线程数量</p><h4 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h4><ul><li><p>DB已连接线程数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;Connections&apos;;</span><br><span class="line">+---------------+--------+</span><br><span class="line">| Variable_name | Value  |</span><br><span class="line">+---------------+--------+</span><br><span class="line">| Connections   | 245884 |</span><br><span class="line">+---------------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>当前连接线程状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;%thread%&apos;;</span><br><span class="line">+------------------------------------------+-------+</span><br><span class="line">| Variable_name                            | Value |</span><br><span class="line">+------------------------------------------+-------+</span><br><span class="line">| Delayed_insert_threads                   | 0     |</span><br><span class="line">| Performance_schema_thread_classes_lost   | 0     |</span><br><span class="line">| Performance_schema_thread_instances_lost | 0     |</span><br><span class="line">| Slow_launch_threads                      | 0     |</span><br><span class="line">| Threads_cached                           | 18    |</span><br><span class="line">| Threads_connected                        | 9     |</span><br><span class="line">| Threads_created                          | 27    |</span><br><span class="line">| Threads_running                          | 1     |</span><br><span class="line">+------------------------------------------+-------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>服务器允许最大连接数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;max_connections&apos;;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| max_connections | 151   |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p>一般500 ~ 800比较合适</p><ul><li>服务器响应的最大连接数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;Max_used_connections&apos;;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Max_used_connections | 27    |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p><strong>Max_used_connections/max_connections &lt;= 85%</strong>比较理想</p><ul><li>连接队列长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;back_log&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| back_log      | 80    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p>类似于线程队列，当无法响应请求时，就让线程排队；值越小越好。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul><li>索引缓存大小<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;key_buffer_size&apos;;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| key_buffer_size | 33554432 |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">1 row in set (0.00 sec</span><br></pre></td></tr></table></figure></li></ul><p><strong>连接缓存命中率Threads_Cache_Hit = (Connections - Threads_created)/Connections*100%</strong>建议90%左右甚至更高</p><ul><li>索引缓存未命中率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;key_read%&apos;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Key_read_requests | 28    |</span><br><span class="line">| Key_reads         | 10    |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">2 rows in set (0.10 sec)</span><br></pre></td></tr></table></figure></li></ul><p><strong>索引缓存未命中率key_cache_miss_rate = Key_reads/Key_read_requests *100%</strong><br>1%即100个索引中有一个在缓存中找不到，要直接从硬盘读取;建议<code>小于0.1%</code></p><ul><li>索引缓存命中率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;key_%&apos;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Key_blocks_not_flushed | 0     |</span><br><span class="line">| Key_blocks_unused      | 26785 |</span><br><span class="line">| Key_blocks_used        | 7     |</span><br><span class="line">| Key_read_requests      | 28    |</span><br><span class="line">| Key_reads              | 10    |</span><br><span class="line">| Key_write_requests     | 2     |</span><br><span class="line">| Key_writes             | 2     |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p><strong>key_buffer_read_hits = (1-Key_reads/Key_read_requests) *100%</strong><br><strong>key_buffer_write_hits = (1-Key_writes/Key_write_requests)*100%</strong><br>越大越好</p><ul><li>索引读取统计<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;key_blocks_u%&apos;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Key_blocks_unused | 26785 |</span><br><span class="line">| Key_blocks_used   | 7     |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p>Key_blocks_unused表示未使用的缓存簇（blocks）数，Key_blocks_used表示曾经用到的最大的blocks数，如果缓存都用到了，那么要么增加key_buffer_size，要么就是过度索引把缓存占满了。<br>比较理想的情况：<br><strong>Key_blocks_used/(Key_blocks_unused + Key_blocks_used) *100% ≈ 80%</strong></p><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><ul><li>临时表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;created_tmp%&apos;;</span><br><span class="line">+-------------------------+--------+</span><br><span class="line">| Variable_name           | Value  |</span><br><span class="line">+-------------------------+--------+</span><br><span class="line">| Created_tmp_disk_tables | 3054   |</span><br><span class="line">| Created_tmp_files       | 7      |</span><br><span class="line">| Created_tmp_tables      | 624084 |</span><br><span class="line">+-------------------------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p>临时表比较大无法在内存中完成时就不得不使用磁盘文件。如果Created_tmp_tables非常大，则可能是系统中排序操作过多，或者表连接方式不是很优化。如果Created_tmp_disk_tables和Created_tmp_tables的比率过高，如超过10%，则需要考虑tmp_table_size这个系统参数的值是都设置的足够大。<br>参考值： <strong>Created_tmp_disk_tables/Created_tmp_tables &lt; 5%</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables where Variable_name in (&apos;tmp_table_size&apos;, &apos;max_heap_table_size&apos;);</span><br><span class="line">+---------------------+----------+</span><br><span class="line">| Variable_name       | Value    |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">| max_heap_table_size | 33554432 |</span><br><span class="line">| tmp_table_size      | 33554432 |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>MySQL规定的内部内存临时表的最大值，每个线程都要分配。（实际起限制作用的是tmp_table_size和max_heap_table_size的最小值。）如果内存临时表超出了限制，MySQL就会自动地把它转化为基于磁盘的MyISAM表，存储在指定的tmpdir目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;tmpdir&quot;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| tmpdir        | /tmp  |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure></p><ul><li>表扫描情况<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;handler_read%&apos;;</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Variable_name         | Value    |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Handler_read_first    | 9357279  |</span><br><span class="line">| Handler_read_key      | 77387871 |</span><br><span class="line">| Handler_read_last     | 121      |</span><br><span class="line">| Handler_read_next     | 69589828 |</span><br><span class="line">| Handler_read_prev     | 104      |</span><br><span class="line">| Handler_read_rnd      | 531042   |</span><br><span class="line">| Handler_read_rnd_next | 45348670 |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;com_select&apos;;</span><br><span class="line">+---------------+----------+</span><br><span class="line">| Variable_name | Value    |</span><br><span class="line">+---------------+----------+</span><br><span class="line">| Com_select    | 19894899 |</span><br><span class="line">+---------------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>表扫描率 = Handler_read_rnd_next /Com_select</strong><br>如果表扫描率超过4000，说明进行了太多表扫描，可能是索引没有建好；</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>直接运行命令，返回java进程号，参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-l： 返回java进程全路径 </span><br><span class="line">-q： 仅显示进程号</span><br><span class="line">-v： 返回JVM参数，可以查看堆大小</span><br></pre></td></tr></table></figure></p><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>用的最多</p><ul><li>查看运行情况<br>首先通过<code>jps</code>获取进程号，再使用<code>jstat</code>获取JVM中加载的累的数据和size<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jps</span><br><span class="line">15649 Gtest.0-y-1.1.5.jar</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstat -class -h5  15649 1000</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line"> 11654 21472.7        0     0.0       4.21</span><br><span class="line"> 11654 21472.7        0     0.0       4.21</span><br><span class="line"> 11654 21472.7        0     0.0       4.21</span><br><span class="line"> 11654 21472.7        0     0.0       4.21</span><br><span class="line"> 11654 21472.7        0     0.0       4.21</span><br></pre></td></tr></table></figure><p>每1秒统计一次，每统计5次显示一次表头</p><p>字段含义：</p><table><thead><tr><th>Item</th><th>含义</th></tr></thead><tbody><tr><td>Loaded</td><td>加载类的数目</td></tr><tr><td>Bytes</td><td>加载类的Size，单位Bytes</td></tr><tr><td>Unloaded</td><td>卸载类的数量</td></tr><tr><td>Bytes</td><td>卸载类的Size，单位Bytes</td></tr><tr><td>Time</td><td>加载和卸载类花费的时间</td></tr></tbody></table><ul><li>jstat 所有选项说明<br>更详细可以<code>man jstat</code>查看，所有选项及对应的参数说明</li></ul><table><thead><tr><th>Item</th><th>含义</th></tr></thead><tbody><tr><td>class</td><td>查看类加载情况的统计</td></tr><tr><td>compiler</td><td>查看HotSpot中即使编译器编译情况的统计</td></tr><tr><td>gc</td><td>用于查看JVM中堆的垃圾回收情况统计</td></tr><tr><td>gccapacity</td><td>查看新生代、老年代及元空间情况</td></tr><tr><td>gccause</td><td>最后一次及当前正在垃圾回收的原因</td></tr><tr><td>gcnew</td><td>查看新生代垃圾回收情况</td></tr><tr><td>gcnewcapacity</td><td>查看新生代存储容量情况</td></tr><tr><td>gcold</td><td>查看老年代及持久代发生GC的情况</td></tr><tr><td>gcoldcapacity</td><td>查看老年代容量</td></tr><tr><td>gcmetacapacity</td><td>元空间容量</td></tr><tr><td>gcutil</td><td>GC统计</td></tr></tbody></table><ul><li>jstat gccapacity</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstat -gccapacity 15649</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC </span><br><span class="line"> 84992.0 1355776.0 688640.0 8192.0 20992.0 640512.0   171008.0  2711552.0   201728.0   201728.0      0.0 1105920.0  65280.0      0.0 1048576.0   8192.0     14     3</span><br></pre></td></tr></table></figure><p>字段说明：</p><table><thead><tr><th>Item</th><th>说明</th></tr></thead><tbody><tr><td>NGCMN</td><td>新生代最小容量（KB）</td></tr><tr><td>NGCMX</td><td>新生代最大容量(KB)</td></tr><tr><td>NGC</td><td>新生代当前容量(KB)</td></tr><tr><td>S0C</td><td>当前幸存者一区（survivor）容量(KB)</td></tr><tr><td>S1C</td><td>当前幸存者二区（survivor）容量(KB)</td></tr><tr><td>EC</td><td>当前伊甸园（eden）容量(KB)</td></tr><tr><td>OGCMN</td><td>老年代初始化大小(KB)</td></tr><tr><td>OGCMX</td><td>老年代最大容量(KB)</td></tr><tr><td>OGC</td><td>老年代当前容量(KB) Current old generation capacity (kB)</td></tr><tr><td>OC</td><td>old区当前容量（KB） Current old space capacity (kB)</td></tr><tr><td>MCMN</td><td>最小元空间容量（kB）</td></tr><tr><td>MCMX</td><td>最大元空间容量（kB）</td></tr><tr><td>MC</td><td>元空间容量（kB）</td></tr><tr><td>CCSMN</td><td>压缩类空间最小容量（kB）</td></tr><tr><td>CCSMX</td><td>压缩类空间最大容量（kB）</td></tr><tr><td>CCSC</td><td>压缩类空间容量（kB）</td></tr><tr><td>YGC</td><td>young GC次数</td></tr><tr><td>FGC</td><td>Full GC次数</td></tr></tbody></table><ul><li>jstat gcutil</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstat -gcutil 15649</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line"> 99.22   0.00  81.74  21.00  95.96  93.63     14    0.161     3    0.186    0.347</span><br></pre></td></tr></table></figure><p>字段说明：</p><table><thead><tr><th>Item</th><th>含义</th></tr></thead><tbody><tr><td>S0</td><td>幸存者一区已使用的容量百分比</td></tr><tr><td>S1</td><td>幸存者二区已使用的容量百分比</td></tr><tr><td>E</td><td>伊甸园已使用的容量百分比</td></tr><tr><td>O</td><td>老年代已使用的容量百分比</td></tr><tr><td>M</td><td>元空间已使用的容量百分比</td></tr><tr><td>CCS</td><td>压缩类空间利用率百分比</td></tr><tr><td>YGC</td><td>Young GC次数</td></tr><tr><td>YGCT</td><td>JVM启动到采样时，Young GC用时（s）</td></tr><tr><td>FGC</td><td>Full GC次数</td></tr><tr><td>FGCT</td><td>JVM启动到采样时，Full GC用时（s）</td></tr><tr><td>GCT</td><td>GC总时间</td></tr></tbody></table><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>jmap我知道的作用，就是dump下堆快照，再用工具分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=dump.hprof PID</span><br></pre></td></tr></table></figure></p><p>其他用法：</p><ul><li><p>jmap分析jvm内存<br><code>jmap -heap pidOP</code></p></li><li><p>打印当前java堆活跃的各个对象的数量、大小<br><code>jmap -histo:live 16102 | head -10</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[C is a char[]</span><br><span class="line">[S is a short[]</span><br><span class="line">[I is a int[]</span><br><span class="line">[B is a byte[]</span><br><span class="line">[[I is a int[][]</span><br></pre></td></tr></table></figure><ul><li>打印等待回收的对象信息<br><code>jmap -finalizerinfo  pid</code></li></ul><p>dump快照打印下来之后，传到本地，可以使用Jsisualvm或者<code>MemoryAnalyze</code>（mat）打开</p><blockquote><p><a href="https://pan.baidu.com/s/159QUTj5OKKi7jvtPIlSIvA" target="_blank" rel="noopener">MemoryAnalyze</a></p></blockquote><p>提取码：t4yy</p><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>步骤：</p><ol><li><p>top -c   P（找最耗CPU进程拿pid）    4209</p></li><li><p>top -Hp 4209    P (找最耗CPU线程，拿pid)     9890</p></li><li><p>printf “%x” 9890    （转换为16进制）</p></li><li><p>jstack 4209 | grep 26a2 -C5 –color</p></li></ol><p>以上，就是整理的一点监控相关，配合以下几篇，性能测试的性能问题定位，差不多入门：</p><blockquote><p><a href="https://tokyle.com/2018/05/16/%E3%80%90%E8%BD%AC%E3%80%91windows%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/#">windows性能监控指标</a><br><a href="https://tokyle.com/2018/08/29/%E3%80%90%E8%BD%AC%E3%80%91Linux%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90/">Linux性能监控与分析</a><br><a href="https://tokyle.com/2018/10/17/Linux%E5%AE%9A%E4%BD%8D%E6%9C%80%E8%80%97CPU%E7%9A%84%E7%BA%BF%E7%A8%8B/#">Linux定位最耗CPU的线程</a><br><a href="https://tokyle.com/2018/11/02/JVM%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/">JVM内存性能问题定位</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;性能监控简单小结&lt;/p&gt;
&lt;p&gt;涉及MySQL和JVM&lt;br&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="mysql" scheme="http://tokyle.com/tags/mysql/"/>
    
      <category term="JVM" scheme="http://tokyle.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>性能测试工具nGrinder试用</title>
    <link href="http://tokyle.com/2019/06/25/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7nGrinder%E8%AF%95%E7%94%A8/"/>
    <id>http://tokyle.com/2019/06/25/性能测试工具nGrinder试用/</id>
    <published>2019-06-26T01:57:41.000Z</published>
    <updated>2019-06-26T02:11:23.583Z</updated>
    
    <content type="html"><![CDATA[<p>性能测试工具nGrinder试用</p><a id="more"></a><p>之前就有听过这工具，但本着工具在精不在多原则，一直没用过，最近看市场上，苏州有家公司把这个列进了要求，就试用了下</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这边是直接使用的docker拉的镜像安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ngrinder/controller</span><br></pre></td></tr></table></figure></p><p>直接拉了最新版本镜像，然后起容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name ngrinder -d -p 8099:80 ngrinder/controller</span><br></pre></td></tr></table></figure></p><p>嗯，起起来了，不出所料，后续起agent时候挂了，端口没开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR agent controller: Error while connecting to agent controller server at /192.168.0.97:16001</span><br></pre></td></tr></table></figure></p><p>原因很简单，起容器时候，没暴露16001端口，省略后续的其他踩坑，直接把要用的端口都开了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name ngrinder -d -p 8099:80 \</span><br><span class="line"> -p 16001:16001 \</span><br><span class="line"> -p 12000-12009:12000-12009 \</span><br><span class="line"> ngrinder/controller</span><br></pre></td></tr></table></figure></p><p>查看状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 拿containerid</span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"># 看日志</span><br><span class="line">docker logs -f --tail=300 containerid</span><br></pre></td></tr></table></figure></p><p>起好之后，浏览器打开：<code>http://192.168.0.97:8099</code>，默认账密<code>admin/admin</code><br>界面长这样：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4eb9syiw4j20s40hh41l.jpg" alt="主界面"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>帮助</code>旁边的<code>admin</code>下，点击下载代理和下载监控，传到服务器上，解压完起代理和监控（linux下直接起shell脚本）<br>先创建<code>脚本</code>,再创建<code>性能测试</code></p><p>创建脚本填写对应参数即可：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ebe1j89ej20ov0hmmxi.jpg" alt="创建脚本"></p><p>测试配置页面也很简单，都是一些通用的配置，代理数量，vusers，启动延时配置，运行时间，运行次数等<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ebfx4si4j20t30ml3zm.jpg" alt="测试配置"></p><p>配置完成，点保存并运行即可</p><p>测试报告：<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ebhu40qej20t00m0t9u.jpg" alt="测试报告"><br>其中有日志，也可以点<code>详细测试结果</code>查看更详细的数据<br><img src="http://ww1.sinaimg.cn/mw690/a025e134gy1g4ebkhbyh9j20rx0ofq4b.jpg" alt="详细报告"><br>支持下载CSV报告查看</p><p>以上就是nGrinder的一次，总的印象，工具还行，报告很直观，但是对于编码可能要求（看了下，Jython编写的，基本就是python的request框架），语言试用Groovy和Jython;内置了SVN，团队之间脚本分享很方便。</p><p>实在不想手持身份证用七牛云，用了新浪的图床，很可能图会挂。。见谅。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;性能测试工具nGrinder试用&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="nGrinder" scheme="http://tokyle.com/tags/nGrinder/"/>
    
  </entry>
  
  <entry>
    <title>python字符串实践</title>
    <link href="http://tokyle.com/2019/06/25/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E8%B7%B5/"/>
    <id>http://tokyle.com/2019/06/25/python字符串实践/</id>
    <published>2019-06-25T09:19:10.000Z</published>
    <updated>2019-06-25T09:20:38.738Z</updated>
    
    <content type="html"><![CDATA[<p>python字符串实践</p><a id="more"></a><p>收银小票打印尝试</p><h3 id="python字符串对齐方式"><a href="#python字符串对齐方式" class="headerlink" title="python字符串对齐方式"></a>python字符串对齐方式</h3><p>首先，看几个命令的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from math import pi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;&#123;0:&lt;10.2f&#125;\n&#123;0:^10.2f&#125;\n&#123;0:&gt;10.2f&#125;&quot;.format(pi))</span><br><span class="line">print(&apos;&#123;&#125;&apos;.format(pi))</span><br><span class="line">print(&apos;&#123;0&#125;&apos;.format(pi))</span><br><span class="line">print(&apos;&#123;&#123;:&#123;&#125;&#125;&#125;&apos;.format(10))</span><br><span class="line">print(&apos;&#123;:10.2f&#125;&apos;.format(pi))</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3.14      </span><br><span class="line">   3.14   </span><br><span class="line">      3.14</span><br><span class="line">3.141592653589793</span><br><span class="line">3.141592653589793</span><br><span class="line">&#123;:10&#125;</span><br><span class="line">      3.14</span><br></pre></td></tr></table></figure></p><h3 id="收银小票尝试："><a href="#收银小票尝试：" class="headerlink" title="收银小票尝试："></a>收银小票尝试：</h3><p>实现方式有点low，写的有点乱。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*-coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: kyle</span><br><span class="line">@time: 2019/6/20 16:06</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># from math import pi</span><br><span class="line"></span><br><span class="line"># print(&quot;&#123;0:&lt;10.2f&#125;\n&#123;0:^10.2f&#125;\n&#123;0:&gt;10.2f&#125;&quot;.format(pi))</span><br><span class="line"># print(&apos;&#123;&#125;&apos;.format(pi))</span><br><span class="line"># print(&apos;&#123;0&#125;&apos;.format(pi))</span><br><span class="line"># print(&apos;&#123;&#123;:&#123;&#125;&#125;&#125;&apos;.format(10))</span><br><span class="line"># print(&apos;&#123;:10.2f&#125;&apos;.format(pi))</span><br><span class="line"></span><br><span class="line">def fruit_price(fruit):</span><br><span class="line">    if fruit == &apos;Watermelon&apos;:</span><br><span class="line">        return 1.6</span><br><span class="line">    elif fruit == &apos;Apple&apos;:</span><br><span class="line">        return 10</span><br><span class="line">    elif fruit == &apos;Peach&apos;:</span><br><span class="line">        return 3.3</span><br><span class="line">    elif fruit == &apos;Pear&apos;:</span><br><span class="line">        return 2</span><br><span class="line">    else:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">def enter_price():</span><br><span class="line">    price = []</span><br><span class="line">    weights = []</span><br><span class="line">    fruits = []</span><br><span class="line">    num = 0</span><br><span class="line">    while True:</span><br><span class="line">        num += 1</span><br><span class="line">        fruit = input(&apos;Enter the fruit: &apos;)</span><br><span class="line">        weight = input(&apos;Enter the weight: &apos;)</span><br><span class="line">        fruits.append(fruit)</span><br><span class="line">        weights.append(weight)</span><br><span class="line">        a = fruit_price(fruit)</span><br><span class="line">        price.append(a)</span><br><span class="line">        if fruit == &apos;q&apos; or weight == &apos;q&apos;:</span><br><span class="line">            break</span><br><span class="line">    num -= 1</span><br><span class="line">    fruits.remove(fruits[-1])</span><br><span class="line">    price.remove(price[-1])</span><br><span class="line">    weights.remove(weights[-1])</span><br><span class="line"></span><br><span class="line">    return [num,fruits,weights,price]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fruit_res = enter_price()</span><br><span class="line">print(fruit_res)</span><br><span class="line"></span><br><span class="line"># 设置小票宽度</span><br><span class="line">width = int(input(&apos;Please enter your width: &apos;))</span><br><span class="line">price_width = 10</span><br><span class="line">num_width = 10</span><br><span class="line">item_width = width - price_width - num_width</span><br><span class="line"></span><br><span class="line"># 设置小票表头格式</span><br><span class="line">header_fmt = &apos;&#123;&#123;:&#123;&#125;&#125;&#125;&#123;&#123;:^&#123;&#125;&#125;&#125;&#123;&#123;:&gt;&#123;&#125;&#125;&#125;&apos;.format(item_width, num_width, price_width)</span><br><span class="line">fmt = &apos;&#123;&#123;:&#123;&#125;&#125;&#125;&#123;&#123;:^&#123;&#125;&#125;&#125;&#123;&#123;:&gt;&#123;&#125;.2f&#125;&#125;&apos;.format(item_width, num_width, price_width)</span><br><span class="line"></span><br><span class="line">print(&apos;*&apos;* width)</span><br><span class="line">print(&quot;Here&apos;s Your Ticket&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;=&apos;* width)</span><br><span class="line">print(header_fmt.format(&apos;Item&apos;, &apos;Num&apos;, &apos;Price&apos;))</span><br><span class="line">print(&apos;-&apos; * width)</span><br><span class="line"></span><br><span class="line"># 循环打印水果，单价，数量</span><br><span class="line">num = fruit_res[0]</span><br><span class="line">i = 0</span><br><span class="line">prices = []</span><br><span class="line">for i in range(int(num)):</span><br><span class="line">    prices.append(int(fruit_res[2][i]) * float(fruit_res[3][i]))</span><br><span class="line">    print(fmt.format(fruit_res[1][i], fruit_res[2][i], fruit_res[3][i]))</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">print(&apos;-&apos; * width)</span><br><span class="line"></span><br><span class="line"># 打印总价</span><br><span class="line">Sum = sum(prices)</span><br><span class="line">item2_width = width - price_width</span><br><span class="line">foot_fmt = &apos;&#123;&#123;:&lt;&#123;&#125;&#125;&#125;&#123;&#123;:&gt;&#123;&#125;.2f&#125;&#125;&apos;.format(item2_width, price_width)</span><br><span class="line">print(foot_fmt.format(&apos;Summary&apos;, Sum))</span><br><span class="line">print(&apos;-&apos; * width)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Enter the fruit: Watermelon</span><br><span class="line">Enter the weight: 10</span><br><span class="line">Enter the fruit: Apple</span><br><span class="line">Enter the weight: 20</span><br><span class="line">Enter the fruit: Peach</span><br><span class="line">Enter the weight: 30</span><br><span class="line">Enter the fruit: q</span><br><span class="line">Enter the weight: q</span><br><span class="line">[3, [&apos;Watermelon&apos;, &apos;Apple&apos;, &apos;Peach&apos;], [&apos;10&apos;, &apos;20&apos;, &apos;30&apos;], [1.6, 10, 3.3]]</span><br><span class="line">Please enter your width: 45</span><br><span class="line">*********************************************</span><br><span class="line">Here&apos;s Your Ticket</span><br><span class="line">=============================================</span><br><span class="line">Item                        Num         Price</span><br><span class="line">---------------------------------------------</span><br><span class="line">Watermelon                   10          1.60</span><br><span class="line">Apple                        20         10.00</span><br><span class="line">Peach                        30          3.30</span><br><span class="line">---------------------------------------------</span><br><span class="line">Summary                                315.00</span><br><span class="line">---------------------------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p><p>有空再改进。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python字符串实践&lt;/p&gt;
    
    </summary>
    
      <category term="python基础" scheme="http://tokyle.com/categories/python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>敏捷测试与自动化</title>
    <link href="http://tokyle.com/2019/06/23/%E6%95%8F%E6%8D%B7%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>http://tokyle.com/2019/06/23/敏捷测试与自动化/</id>
    <published>2019-06-24T02:09:56.000Z</published>
    <updated>2019-06-24T02:10:32.267Z</updated>
    
    <content type="html"><![CDATA[<p>敏捷测试与自动化</p><a id="more"></a><h3 id="敏捷自动化问题"><a href="#敏捷自动化问题" class="headerlink" title="敏捷自动化问题"></a>敏捷自动化问题</h3><p>最近看到一篇文章，讨论敏捷开发模式下的自动化实施问题，看到里面有很多值得好好想想的地方。</p><p>首先，在一个追求敏捷开发的团队中，很多时候，测试工作都是放在整个项目的最后一个环节，尤其是Android应用项目，多数情况下，会出现很多个版本一起上线，这个时候，作为测试的压力明显是非常大，工作量巨大，纯手工进行测试很可能会忙于应付需求，这个时候正式自动化回归最大效率化的时候，然后现状很可能是，自动化连手工都不如，需要半天甚至一天才能出测试结果，每次运行都是全流程，自动化测试报告也需要大量时间进行分析，这无疑是很失败的敏捷自动化实施。</p><p>很多团队，可能也有专人进行了很长时间的专职自动化设计，搭建，但是效果一直不理想，原因可能是：</p><ol><li><p>自动化人员与业务剥离，甚至不了解业务，所有用例需要业务功能测试人员提供；试想这样的情况下，自动化也不是纯框架设计，进行的也是涉及业务的自动化用例设计，那怎么可能设计出有效的自动化用例呢。</p></li><li><p>管理人员对于自动化预期过高，认为自动化测试可以实现所有的测试活动；自动化测试，说到底，也是在设计了断言的情况下进行验证，也就是已知结果的情况，很多时候，测试工作需要随机测试，暴力测试等等去发现很多非正常情况下可能出现的问题。</p></li><li><p>自动化测试没有专人，没有必要的时间和精力；有的公司可能实行的是固定测试开发团队进行自动化框架编辑搭建，后续的自动化用例是由产线的测试工程师进行编写维护；这样的做法，的确算是功能细分，但是有个前提，产线的测试有时间和精力去专门做自动化测试相关。很多团队有点搞笑，自动化用例让产线实施，并不给产线测试需要的时间去学习和练习自动化测试技能，最终的结果，可想而知。</p></li></ol><p>其实测试人员也都知道，产品交接时间点临近时，产品功能交付的优先级肯定是高于自动化实施，测试人员需要确保的是那些即将交付的产品功能，而不是确保产品功能正常的自动化测试用例。但是长此以往的不断将自动化测试实施优先级降低，一次次的迭代发布日期指定，只会将产线折腾的异常忙碌，烦躁。造成这种情况的原因，可能是迫于市场和客户压力，需要一次次的制定满足于市场的新功能，短时间铺开市场，解决客户问题，但是这样的一次次的追求快，仓促发布功能，最终真的是在满足市场吗？守业更比创业难，不要等到最后市场诚信低至谷底时候才想起来，当然，追求快速IPO分钱走人就当没说。</p><p>插一句：敏捷工作方式的目的是以最小幅度增长的方式发布可供用户使用的功能，并且得到用户的即时反馈。</p><h3 id="可能的解决办法"><a href="#可能的解决办法" class="headerlink" title="可能的解决办法"></a>可能的解决办法</h3><ol><li><p>设定合理的预期，想清楚，为什么需要自动化，需要自动化做什么，怎么实施可以帮助现在的团队。有个很扯淡的想法，实施自动化是因为不想做手工。。。</p></li><li><p>给自动化分配专用的资源，公司需要关注的不应该仅仅是测试开发需要专门的资源，产线的自动化用例编写维护人员更需要专门的时间和精力去学习，练习，维护自动化，整天疲于应对功能迭代压力，最终结果是自动化夭折。</p></li><li><p>提高自动化关注度和优先级，这个需要在公司层面，宣传论证实施自动化的价值，试问如果团队都不知道自动化为何物，就提出要花大时间，聘请专员进行自动化，是不是有点扯。</p></li><li><p>将自动化测试看做软件研发对待，这点是对自动化测试工程师本身来说的，实施自动化测试之前，需要和产品研发一样，需求分析，方案论证，概要设计，详细设计等。</p></li><li><p>合理制定目标，也是针对自动化实施人员来说的，在经验没有那么丰富，或者时间没有那么充裕的情况下，是是不是可以考虑首先进行的是接口的自动化，而不是直接UI。</p></li><li><p>持续学习，既然敏捷工作模式下，产品都是一些快速迭代的过程，那身为自动化工程师的你，是不是应该为了适应不断增加的需求，去快递学习。例如自动化工具后续直接使用docker镜像化，自动化实施配合CI，构建完成直接Jenkins调度，无需手工执行，自动化实施过程中，关注测试右移，实施APM监控等等。</p></li></ol><p>以上是看到的和自己的一点点想法，希望国内广大的测试同胞们可以不被自动化所累，知道自己想要的是什么，其实在我看来，追求系统的底层实现，开发语言的基本语法，高效实施等，才是更有效的方式，一味的追求工具，追求框架，很可能会迷失自己，毕竟做到后面，自动化也成了维护代码。</p><p>愿测试可以被温柔以待</p><p>突然想到个毫无关系的一句话：<code>少年不知画中意，归来已成画中人</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;敏捷测试与自动化&lt;/p&gt;
    
    </summary>
    
      <category term="自动化测试" scheme="http://tokyle.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://tokyle.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一次Android安全问题定位</title>
    <link href="http://tokyle.com/2019/06/21/%E4%B8%80%E6%AC%A1Android%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/"/>
    <id>http://tokyle.com/2019/06/21/一次Android安全问题定位/</id>
    <published>2019-06-21T09:06:26.000Z</published>
    <updated>2019-06-21T09:07:31.485Z</updated>
    
    <content type="html"><![CDATA[<p>一次Android安全问题定位</p><a id="more"></a><p>有个账密明文存库问题，<code>default.realm</code>存了明文的用户名和密码</p><h3 id="文件获取"><a href="#文件获取" class="headerlink" title="文件获取"></a>文件获取</h3><p>首先，很明显，需要root手机了，正常的权限，根本进不去<code>/data/data</code>文件夹</p><p>root完之后开始</p><p><code>adb devices</code>，设备已连接上</p><p><code>su</code>切换用户，进入shell</p><p>赋权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /data</span><br><span class="line">chmod 777 /data/data</span><br><span class="line">chmod -R 777 /data/data/com.test.package</span><br></pre></td></tr></table></figure></p><p><code>find / -name &quot;default.realm&quot;</code>查找该数据库文件</p><p><code>cd /data/data/com.test.package/files</code>进入数据库文件夹</p><p><code>cp default.realm /sdcard</code>将数据库文件拷贝到外部存储器SD卡（方便拉倒本地）</p><p><code>exit</code><br>退出adb shell</p><p><code>adb pull /sdcard/default.realm E:/LOGS</code> 将SD卡里数据库文件拉到本地</p><h3 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h3><p>没那本事在windows下看<code>.realm</code>，找个台mac，装了个<code>Realm Browser</code>打开导出的<code>default.realm</code></p><p>看到在user表，明文的链接，用户名，密码。。。<br>(android sdk的platform_tool中有个monitor.bat工具，可以看见android的文件系统，可能不能深层次进入，还是命令行方式靠谱)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一次Android安全问题定位&lt;/p&gt;
    
    </summary>
    
      <category term="skill" scheme="http://tokyle.com/categories/skill/"/>
    
    
      <category term="adb" scheme="http://tokyle.com/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>Service Mesh基础知识</title>
    <link href="http://tokyle.com/2019/06/21/Service-Mesh%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://tokyle.com/2019/06/21/Service-Mesh基础知识/</id>
    <published>2019-06-21T06:31:34.000Z</published>
    <updated>2019-06-21T06:42:33.311Z</updated>
    
    <content type="html"><![CDATA[<p>Service Mesh基础知识</p><a id="more"></a><p>微服务大噪一时，可以说是最火的后端架构，微服务架构将原来的单体应用进行服务拆分，做成一个个独立的服务应用，各个服务各司其职，彼此独立，各个服务甚至不需要用同样的编程语言，更方便团队协作。</p><p>微服务包含一些基本组件，服务发现，服务注册，鉴权，熔断降级等。由于微服务是将单体拆分为独立应用，当应用越来越大，微服务越来越多，管理起来也就会越来越麻烦。一套微服务环境，链路追踪，负载均衡，安全配置，流量管理等等，可能就会耗费大量时间去维护。针对微服务不断壮大，微服务管理的相关问题，出现了新的微服务框架<code>Service Mesh</code>(服务网格)</p><h3 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h3><p>在解释service mesh之前，先看看nginx的基本概念</p><p>nginx有几大功能，其中正向代理和反向代理，应该都很熟悉。本来最基本的架构是A和B需要进行通信，A和B可以直接相互传输，买房子为例，买家和卖家直接交易。这样的架构有个问题，A和B传输之间的信息，旁人无法知道，传输状态外界也无法监控，传输的数据包如果太大把带宽占满，外界也无法知晓，这样的情况下，就有了中间加一层，代理,C。</p><p>A和B进行通信，会经过C，A向C发起通知，要和B通信，消息给C，C转给B。C就成了中间人，也就是代理，说两个日常常用但可能没多想的例子：</p><ol><li>国内万里长城的存在，想要见识外部世界，就需要VPN，俗称的翻墙。技术实现其实很简单，VPN其实是搭建在一台可以直接访问外部网站（例如IG）的服务器上的正向代理服务，可能在日本，可能在美国等；本地挂VPN翻墙，其实就是用客户端去访问正向代理服务，再由服务进行转发，达到大陆也可以访问外网的效果。这就是正向代理（Forward Proxy）</li><li>典型的nginx负载均衡，A访问C，C将A的请求，分发给下面的无数个B(B1,B2,B3,B4,B5…)。A其实压根不知道它是最终是在和B进行通信，A也根本不关心有多少个B，只要有C，和C进行通信，就能达到A和无数个B进行通信的效果，C就是反向代理。（Reverse Proxy）</li></ol><p>说完代理的例子，说说中间加这么一层有什么意义：</p><ol><li>拦截：原来A和B直接通信，没人能阻止，现在加了层这个，就可以防止员工上班时间看视频。。。</li><li>统计：既然A和B所有的通信都会经过代理，那么也就可以通过代理来统计网络传输中的数据信息</li><li>缓存：典型应用CDN，访问比较慢，直接将数据缓存到访问快的地方，通过这个地方进行访问，要快很多</li><li>分发：负载均衡</li><li>跳板：堡垒机<br>… …</li></ol><p>说完nginx的代理，说回service mesh，其实service mesh也就是类似于nginx的一个代理，可以看做是分布式微服务代理。在传统的代理模式下，代理一般是单独的代理服务器，所有请求先通过代理，再转发到实际的后端。service mesh中，代理是分布式的，常驻在服务身边（sidecar模式），每个服务可以理解成有两个部分，一个是原来的服务（service），一个是用于service mesh的代理（sidecar），sidecar之间相互连接，和彼此的服务彼此隔离，和传统的代理一样，流量也就是经过sidecar进行管理，所有的服务的sidecar进行连接，组成了mesh（网格）。</p><p>同时，传统的代理，基本是只基于网络流量，但是 Service Mesh 中，代理会知道整个集群的所有应用信息，并且额外添加了热更新、注入服务发现、降级熔断、认证授权、超时重试、日志监控等功能，让这些通用的功能不必每个应用都自己实现，放在代理中即可。换句话说，Service Mesh 中的代理对微服务中的应用做了定制化的改进。</p><p>有了service mesh，管理员只需要和代理层打交道，就能达到对整个微服务系统控制的效果。</p><p><img src="http://ww1.sinaimg.cn/large/a025e134gy1g48rpbys10g21hc0tee81.gif" alt="Service Mesh原理"></p><h3 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h3><p>Istio其实就是Service Mesh架构的一种实现，来看看通过istio可以解决什么问题：<br>来自Istio网站：</p><ul><li>HTTP、gRPC、WebSocket和TCP流量的自动负载均衡。</li><li>通过丰富的路由规则、重试、故障转移和故障注入对流量行为进行细粒度控制。</li><li>支持访问控制、速率限制和配额的可拔插策略层和配置API。</li><li>自动指标、日志和集群内所有流量的跟踪，包括集群入口和出口。</li><li>通过集群中的服务之间的强身份断言来实现服务间的身份验证。</li></ul><p><img src="http://ww1.sinaimg.cn/large/a025e134gy1g48ru7eqtng21hc0te7ip.gif" alt="Istio解决的问题"></p><p>以上内容均来自万能的互联网，由于自己目前对k8s理解还比较浅，对k8s的sidecar还只是理论的认知，Service Mesh和Istio以及Serviceless和knative当前也只是在理论阶段，本篇只是敲门，后面再慢慢入门。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Service Mesh基础知识&lt;/p&gt;
    
    </summary>
    
      <category term="cloud native" scheme="http://tokyle.com/categories/cloud-native/"/>
    
    
      <category term="Service Mesh" scheme="http://tokyle.com/tags/Service-Mesh/"/>
    
      <category term="Istio" scheme="http://tokyle.com/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>pytest学习实践（二）</title>
    <link href="http://tokyle.com/2019/06/19/pytest%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/19/pytest学习实践（二）/</id>
    <published>2019-06-19T07:54:47.000Z</published>
    <updated>2019-06-19T07:55:58.784Z</updated>
    
    <content type="html"><![CDATA[<p>pytest学习实践（二）</p><a id="more"></a><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>pytest的断言就用的python最基本的assert<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line"></span><br><span class="line">def func(x):</span><br><span class="line">    return x + 1</span><br><span class="line"></span><br><span class="line">def test_func():</span><br><span class="line">    assert func(3) == 5</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    pytest.main([&apos;-q&apos;])</span><br></pre></td></tr></table></figure></p><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>用raises来捕获预期的异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line">import pytest</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    filename = &apos;package.json&apos;</span><br><span class="line">    with open(filename) as f_obj:</span><br><span class="line">        json.load(f_obj)</span><br><span class="line">    raise FileNotFoundError</span><br><span class="line"></span><br><span class="line">def test_func():</span><br><span class="line">    with pytest.raises(FileNotFoundError):</span><br><span class="line">        func()</span><br></pre></td></tr></table></figure></p><h3 id="多个类组成用例"><a href="#多个类组成用例" class="headerlink" title="多个类组成用例"></a>多个类组成用例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line"></span><br><span class="line">class TestClass():</span><br><span class="line">    def test_one(self):</span><br><span class="line">        x = &quot;this&quot;</span><br><span class="line">        assert &apos;h&apos; in x</span><br><span class="line"></span><br><span class="line">    def test_two(self):</span><br><span class="line">        x = &apos;hello&apos;</span><br><span class="line">        assert hasattr(x, &apos;check&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    pytest.main([&apos;-q&apos;])</span><br></pre></td></tr></table></figure><p>只要函数以test_开头，都可以识别</p><h3 id="指定测试case"><a href="#指定测试case" class="headerlink" title="指定测试case"></a>指定测试case</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def test_one():</span><br><span class="line">    x = &quot;this&quot;</span><br><span class="line">    assert &apos;h&apos; in x</span><br><span class="line"></span><br><span class="line">def test_two():</span><br><span class="line">    x = &apos;hello&apos;</span><br><span class="line">    assert hasattr(x, &apos;check&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    pytest.main([&apos;-q&apos;, &apos;test_2.py::test_one&apos;])</span><br></pre></td></tr></table></figure><p>但是这样的方式只能指定一个函数，如果需要执行多个，就有点麻烦</p><p>使用<code>pytest.mark</code>进行标记<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@pytest.mark.commit</span><br><span class="line">def test_one():</span><br><span class="line">    x = &quot;this&quot;</span><br><span class="line">    assert &apos;h&apos; in x</span><br><span class="line"></span><br><span class="line">@pytest.mark.finished</span><br><span class="line">def test_two():</span><br><span class="line">    x = &apos;hello&apos;</span><br><span class="line">    assert hasattr(x, &apos;check&apos;)</span><br><span class="line"></span><br><span class="line">@pytest.mark.finished</span><br><span class="line">def test_three():</span><br><span class="line">    assert 1 == 2</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    pytest.main([&apos;-m&apos;, &apos;finished&apos;])</span><br><span class="line">    # os.system(&apos;pytest -m finished&apos;)</span><br></pre></td></tr></table></figure></p><p>使用mark进行标记，标记哪些需要执行，也支持：<code>pytest -m &quot;commit and finished&quot;</code></p><h3 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@pytest.mark.skip</span><br><span class="line">def test_two():</span><br><span class="line">    x = &apos;hello&apos;</span><br><span class="line">    assert hasattr(x, &apos;check&apos;)</span><br></pre></td></tr></table></figure><p>也支持<code>skipif</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@pytest.mark.skipif(sys.platform == &quot;win32&quot;, reason=&quot;not support win32&quot;)</span><br><span class="line">def test_four():</span><br><span class="line">    assert 1 == 1</span><br></pre></td></tr></table></figure></p><h3 id="捕获遇见错误xfail"><a href="#捕获遇见错误xfail" class="headerlink" title="捕获遇见错误xfail"></a>捕获遇见错误xfail</h3><p>使用xfail来标记，期望该测试函数执行失败（执行失败，但又不想跳过）；配合配置文件<code>test.ini</code>，文件中指定标志位，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[pytest]</span><br><span class="line">xfail_strict=true</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@pytest.mark.xfail(strict=True)</span><br><span class="line">def test_five():</span><br><span class="line">    a = id([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])</span><br><span class="line">    b = id([1, 2, 3])</span><br><span class="line">    assert a == b</span><br></pre></td></tr></table></figure><p>运行返回结果<code>x</code>表示<code>XFAIL</code>预见的失败；<code>X</code>表示<code>XPASS</code>预见的成果</p><p>也可以用<code>pytest --runxfail</code>强制执行标记xfail的用例</p><h3 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h3><p>pytest使用<code>pytest.mark.parametrize(argnames, argvalues)</code>进行参数化实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@pytest.mark.parametrize(&apos;passwd&apos;, [&apos;12345678909&apos;, &apos;sdsddewd&apos;])</span><br><span class="line">def test_six(passwd):</span><br><span class="line">    assert len(passwd) &gt;= 10</span><br></pre></td></tr></table></figure><p>测试结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.F                                                                       [100%]</span><br><span class="line">================================== FAILURES ===================================</span><br><span class="line">_____________________________ test_six[sdsddewd] ______________________________</span><br><span class="line"></span><br><span class="line">passwd = &apos;sdsddewd&apos;</span><br><span class="line"></span><br><span class="line">    @pytest.mark.parametrize(&apos;passwd&apos;, [&apos;12345678909&apos;, &apos;sdsddewd&apos;])</span><br><span class="line">    def test_six(passwd):</span><br><span class="line">&gt;       assert len(passwd) &gt;= 10</span><br><span class="line">E       AssertionError: assert 8 &gt;= 10</span><br><span class="line">E        +  where 8 = len(&apos;sdsddewd&apos;)</span><br><span class="line"></span><br><span class="line">test_2.py:31: AssertionError</span><br><span class="line">1 failed, 1 passed in 0.15 seconds</span><br></pre></td></tr></table></figure></p><h3 id="case重试"><a href="#case重试" class="headerlink" title="case重试"></a>case重试</h3><p>安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pytest-rerunfailures</span><br></pre></td></tr></table></figure></p><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    pytest.main([&apos;-s&apos;, &apos;-q&apos;, &apos;--reruns&apos;, &apos;3&apos;])</span><br><span class="line">    # os.system(&apos;pytest -s -q test_2.py --reruns 3&apos;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 failed, 1 warnings, 3 rerun in 0.13 seconds</span><br></pre></td></tr></table></figure><p>可以指定单个case重试</p><h3 id="多进程运行cases"><a href="#多进程运行cases" class="headerlink" title="多进程运行cases"></a>多进程运行cases</h3><p>安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pytest-xdist</span><br></pre></td></tr></table></figure></p><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # pytest.main([&apos;-s&apos;, &apos;-n&apos;, &apos;3&apos;])</span><br><span class="line">    os.system(&apos;pytest -s -n 3 test_2.py&apos;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gw0 I / gw1 I / gw2 I</span><br><span class="line">gw0 [1] / gw1 [1] / gw2 [1]</span><br></pre></td></tr></table></figure><h3 id="生成测试报告（htmlReport）"><a href="#生成测试报告（htmlReport）" class="headerlink" title="生成测试报告（htmlReport）"></a>生成测试报告（htmlReport）</h3><p>安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pytest-html</span><br></pre></td></tr></table></figure></p><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # pytest.main([&apos;--html=report.html&apos;])</span><br><span class="line">    os.system(&apos;pytest  test_2.py --html=report.html&apos;)</span><br></pre></td></tr></table></figure></p><p>报告很好看！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pytest学习实践（二）&lt;/p&gt;
    
    </summary>
    
      <category term="python基础" scheme="http://tokyle.com/categories/python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="pytest" scheme="http://tokyle.com/tags/pytest/"/>
    
  </entry>
  
  <entry>
    <title>pytest学习实践（一）</title>
    <link href="http://tokyle.com/2019/06/19/pytest%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/19/pytest学习实践（一）/</id>
    <published>2019-06-19T05:15:34.000Z</published>
    <updated>2019-06-19T05:24:09.190Z</updated>
    
    <content type="html"><![CDATA[<p>pytest学习实践（一）</p><a id="more"></a><p>pytest是python中一个很好用的框架，主要特点：</p><ol><li>支持参数化（不用unittest一样接ddt）</li><li>支持简单单元测试及复杂功能测试，可以用来做selenium和appium，以及接口自动化（pytest+request）</li><li>众多第三方插件：pytest-html（报告）、pytest-selenium（集成selenium）、pytest-rerunfailures（失败重跑）等</li><li>测试用来skip和xfail处理</li><li>CI方便</li></ol><blockquote><p><a href="http://plugincompat.herokuapp.com/" target="_blank" rel="noopener">pytest插件大全</a></p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>写一个简单的测试函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">def test_func1():</span><br><span class="line">    assert 1 == 1</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    os.system(&apos;pytest&apos;)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">collected 1 item</span><br><span class="line"></span><br><span class="line">test_1.py .                                                              [100%]</span><br><span class="line"></span><br><span class="line">========================== 1 passed in 0.06 seconds ===========================</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p><p>pytest以<code>.</code>表示测试成功，可以看一下测试失败：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">def test_func1():</span><br><span class="line">    assert 1 == 2</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    os.system(&apos;pytest&apos;)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">collected 1 item</span><br><span class="line"></span><br><span class="line">test_1.py F                                                              [100%]</span><br><span class="line"></span><br><span class="line">================================== FAILURES ===================================</span><br><span class="line">_________________________________ test_func1 __________________________________</span><br><span class="line"></span><br><span class="line">    def test_func1():</span><br><span class="line">&gt;       assert 1 == 2</span><br><span class="line">E       assert 1 == 2</span><br><span class="line"></span><br><span class="line">test_1.py:5: AssertionError</span><br><span class="line">========================== 1 failed in 0.11 seconds ===========================</span><br></pre></td></tr></table></figure></p><p><code>F</code>表示运行失败</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pytest学习实践（一）&lt;/p&gt;
    
    </summary>
    
      <category term="python基础" scheme="http://tokyle.com/categories/python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="pytest" scheme="http://tokyle.com/tags/pytest/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（六）</title>
    <link href="http://tokyle.com/2019/06/14/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/14/docker简单使用（六）/</id>
    <published>2019-06-14T06:29:55.000Z</published>
    <updated>2019-06-14T06:30:36.537Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（六）</p><p>数据卷<br><a id="more"></a></p><p>数据卷的使用，类似于linux下的挂载。</p><p>数据卷是一个可供一个或多个容器使用的特殊目录，有以下特性：</p><ul><li>数据卷可以在容器间共享和重用</li><li>对数据卷的修改立刻生效</li><li>对数据卷的更新，不会影响到镜像</li><li>数据卷默认一直存在，即使容器被删除</li></ul><p>创建数据卷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create test_vol</span><br></pre></td></tr></table></figure></p><p>查看数据卷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mynexus]# docker volume ls | grep test</span><br><span class="line">local               test_vol</span><br></pre></td></tr></table></figure></p><p>查看数据卷详细信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mynexus]# docker volume inspect test_vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2019-06-14T14:08:45+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/test_vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;test_vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>启动一个挂载数据卷的容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8077:80 --name web2 --mount source=test_vol,target=/webapp nginx</span><br></pre></td></tr></table></figure></p><p>查看数据卷具体信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker inspect web2</span><br><span class="line"></span><br><span class="line"># 在Mounts节点</span><br><span class="line"> &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;test_vol&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/test_vol/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/webapp&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure></p><p>删除数据卷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm test_vol</span><br></pre></td></tr></table></figure></p><p>删除之前需要将使用这个数据卷的容器关闭，否则报错</p><p>挂载主机目录<br>使用<code>--mount</code>标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8076:80 --name web3 --mount type=bind,source=/home/volumetest,target=/opt/webapp nginx</span><br></pre></td></tr></table></figure><p>本地文件需要存在，否则报错</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（六）&lt;/p&gt;
&lt;p&gt;数据卷&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（五）</title>
    <link href="http://tokyle.com/2019/06/13/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/13/docker简单使用（五）/</id>
    <published>2019-06-14T00:40:45.000Z</published>
    <updated>2019-06-14T05:46:56.644Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（五）</p><p>仓库<br><a id="more"></a></p><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>类似<code>github</code>，docker也有<code>Docker Hub</code>注册了账号之后，也就可以进行镜像的<br>拉取：<code>docker pull nginx</code><br>上传：<code>docker push nginx</code><br>上传到Ddocker Hub时候，可以给自己的镜像一个标注，自己的docker hub id加上镜像<code>kyle/nginx</code>这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:v3 kyle/nginx:v3</span><br><span class="line"></span><br><span class="line">docker push kyle/nginx:v3</span><br></pre></td></tr></table></figure></p><h3 id="私仓"><a href="#私仓" class="headerlink" title="私仓"></a>私仓</h3><p>个人、公司级别的镜像，可能不适合上传到公有仓库，类似gitlab一样，可以在本地创建私有仓库</p><h4 id="创建私仓"><a href="#创建私仓" class="headerlink" title="创建私仓"></a>创建私仓</h4><p>官方提供的工具：<code>docker-registry</code><br>运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8090:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure></p><p>进入容器：<code>docker exec -it registry sh</code><br>仓库默认会创建到容器的该路径：<code>/var/lib/registry</code></p><p>或者通过<code>-v</code>更改路径，将镜像文件放在本地指定路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8081:5000 -v /home/images:/var/lib/registry  --restart=always --name registry2 registry</span><br></pre></td></tr></table></figure></p><p>将本地<code>/home/images</code>作为镜像上传路径，替换默认路径（该文件不存在，会自动创建）</p><h4 id="操作镜像"><a href="#操作镜像" class="headerlink" title="操作镜像"></a>操作镜像</h4><p>先打tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu:16.04 192.168.0.97:8081/ubuntu:16.04</span><br></pre></td></tr></table></figure></p><p>再推送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost images]# docker push 192.168.0.97:8081/ubuntu:16.04</span><br><span class="line">The push refers to repository [192.168.0.97:8081/ubuntu]</span><br><span class="line">Get https://192.168.0.97:8081/v2/: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure></p><p>嗯。失败了、、、因为Docker默认不允许非<code>HTTPS</code>方式推送镜像，解决办法，要么是该配置，要么配置https</p><h4 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h4><p>适用于：<code>ubuntu 16.04+</code>、<code>Debian 8+</code>、<code>centos 7</code><br>修改<code>/etc/docker/daemon.json</code>（不存在就新建）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;:[</span><br><span class="line">        &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;insecure-registries&quot;:[</span><br><span class="line">        &quot;192.168.0.97:8081&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重启docker:<code>systemctl restart docker</code><br>重新push：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost images]# docker push 192.168.0.97:8081/ubuntu:16.04</span><br><span class="line">The push refers to repository [192.168.0.97:8081/ubuntu]</span><br><span class="line">4c54072a5034: Pushed </span><br><span class="line">49652298c779: Pushed </span><br><span class="line">e15278fcccca: Pushed </span><br><span class="line">739482a9723d: Pushed </span><br><span class="line">16.04: digest: sha256:08f4295167241c59fc4a24f18816618ff8f959756fb4b236e880a3b7f45f0ba0 size: 1150</span><br></pre></td></tr></table></figure></p><p>看到成功了。。。<br>在本地<code>/home/images</code>下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# tree images/</span><br><span class="line">images/</span><br><span class="line">└── docker</span><br><span class="line">    └── registry</span><br><span class="line">        └── v2</span><br><span class="line">            ├── blobs</span><br><span class="line">            │   └── sha256</span><br><span class="line">            │       ├── 08</span><br><span class="line">            │       │   └── 08f4295167241c59fc4a24f18816618ff8f959756fb4b236e880a3b7f45f0ba0</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── 2a</span><br><span class="line">            │       │   └── 2a697363a8709093834e852b26bedb1d85b316c613120720fea9524f0e98e4a2</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── 59</span><br><span class="line">            │       │   └── 59856638ac9f32d4caa0f5761b2597fe251642786fdfe1b917ddbb074b890c29</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── 6f</span><br><span class="line">            │       │   └── 6f317d6d954b9a59c54b2cb09e1f30cd3e872796e431cd2ceac5ed570beb2939</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── 9f</span><br><span class="line">            │       │   └── 9ff7e2e5f967fb9c4e8099e63508ab0dddebe3f820d08ca7fd568431b0d10c0e</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       └── a9</span><br><span class="line">            │           └── a9dde5e2a643eca8fde0eed52f4aed31f3ecd9c1b2f24d5e3729cd8d2ae68177</span><br><span class="line">            │               └── data</span><br><span class="line">            └── repositories</span><br><span class="line">                └── ubuntu</span><br><span class="line">                    ├── _layers</span><br><span class="line">                    │   └── sha256</span><br><span class="line">                    │       ├── 2a697363a8709093834e852b26bedb1d85b316c613120720fea9524f0e98e4a2</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       ├── 59856638ac9f32d4caa0f5761b2597fe251642786fdfe1b917ddbb074b890c29</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       ├── 6f317d6d954b9a59c54b2cb09e1f30cd3e872796e431cd2ceac5ed570beb2939</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       ├── 9ff7e2e5f967fb9c4e8099e63508ab0dddebe3f820d08ca7fd568431b0d10c0e</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       └── a9dde5e2a643eca8fde0eed52f4aed31f3ecd9c1b2f24d5e3729cd8d2ae68177</span><br><span class="line">                    │           └── link</span><br><span class="line">                    ├── _manifests</span><br><span class="line">                    │   ├── revisions</span><br><span class="line">                    │   │   └── sha256</span><br><span class="line">                    │   │       └── 08f4295167241c59fc4a24f18816618ff8f959756fb4b236e880a3b7f45f0ba0</span><br><span class="line">                    │   │           └── link</span><br><span class="line">                    │   └── tags</span><br><span class="line">                    │       └── 16.04</span><br><span class="line">                    │           ├── current</span><br><span class="line">                    │           │   └── link</span><br><span class="line">                    │           └── index</span><br><span class="line">                    │               └── sha256</span><br><span class="line">                    │                   └── 08f4295167241c59fc4a24f18816618ff8f959756fb4b236e880a3b7f45f0ba0</span><br><span class="line">                    │                       └── link</span><br><span class="line">                    └── _uploads</span><br></pre></td></tr></table></figure></p><p>使用curl获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# curl 192.168.0.97:8081/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Docker-Compose建私仓"><a href="#Docker-Compose建私仓" class="headerlink" title="Docker Compose建私仓"></a>Docker Compose建私仓</h3><p>参照《docker practice》建私仓，配置全新啊认证，TLS<br>使用openssl自动签发站点SSL证书</p><p>新建一个空白文件夹，进入文件夹，开始操作<br><code>/etc/docker/registry</code></p><h4 id="创建CA私钥"><a href="#创建CA私钥" class="headerlink" title="创建CA私钥"></a>创建CA私钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out &quot;root-ca.key&quot; 4096</span><br></pre></td></tr></table></figure><h4 id="创建CA根证书请求文件"><a href="#创建CA根证书请求文件" class="headerlink" title="创建CA根证书请求文件"></a>创建CA根证书请求文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key &quot;root-ca.key&quot; -out &quot;root-ca.csr&quot; -sha256 \</span><br><span class="line">&gt; -subj &apos;/C=CN/ST=Jiangsu/L=Suzhou/O=Company Xaa/CN=Company Xaa Docker Registry CA&apos;</span><br></pre></td></tr></table></figure><p>其中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/C表示国家，如CN；/ST表示省，如Jiangsu；/L表示城市或地区，如Suzhou；/O表示组织名，如公司名；/CN表示组织通用名称，如公司对外的名称，XXX company</span><br></pre></td></tr></table></figure></p><h4 id="配置CA根证书"><a href="#配置CA根证书" class="headerlink" title="配置CA根证书"></a>配置CA根证书</h4><p><code>vim root-ca.cnf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root_ca]</span><br><span class="line">basicConstraints = critical,CA:TRUE,pathlen:1</span><br><span class="line">keyUsage = critical, nonRepudiation, cRLSign, keyCertSign</span><br><span class="line">subjectKeyIdentifier=hash</span><br></pre></td></tr></table></figure></p><h4 id="签发根证书"><a href="#签发根证书" class="headerlink" title="签发根证书"></a>签发根证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in &quot;root-ca.csr&quot; \</span><br><span class="line">&gt; -signkey &quot;root-ca.key&quot; -sha256 -out &quot;root-ca.crt&quot; \</span><br><span class="line">&gt; -extfile &quot;root-ca.cnf&quot; -extensions \</span><br><span class="line">&gt; root_ca</span><br></pre></td></tr></table></figure><h4 id="生成站点SSL私钥"><a href="#生成站点SSL私钥" class="headerlink" title="生成站点SSL私钥"></a>生成站点SSL私钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out &quot;tokyle.com.key&quot; 4096</span><br></pre></td></tr></table></figure><h4 id="使用私钥生成证书请求文件"><a href="#使用私钥生成证书请求文件" class="headerlink" title="使用私钥生成证书请求文件"></a>使用私钥生成证书请求文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key &quot;tokyle.com.key&quot; -out &quot;site.csr&quot; -sha256 \</span><br><span class="line">&gt; -subj &apos;/C=CN/ST=Jiangsu/L=Suzhou/O=Company Xaa/CN=tokyle.com&apos;</span><br></pre></td></tr></table></figure><h4 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h4><p>新建<code>site.cnf</code>文件 <code>vim site.cnf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints = critical,CA:FALSE</span><br><span class="line">extendedKeyUsage=serverAuth</span><br><span class="line">keyUsage = critical, digitalSignature, keyEncipherment</span><br><span class="line">subjectAltName = DNS:tokyle.com, IP:127.0.0.1</span><br><span class="line">subjectKeyIdentifier=hash</span><br></pre></td></tr></table></figure></p><h4 id="签署站点SSL证书"><a href="#签署站点SSL证书" class="headerlink" title="签署站点SSL证书"></a>签署站点SSL证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 750 -in &quot;site.csr&quot; -sha256 \</span><br><span class="line">&gt; -CA &quot;root-ca.crt&quot; -CAkey &quot;root-ca.key&quot; -CAcreateserial \</span><br><span class="line">&gt; -out &quot;tokyle.com.crt&quot; -extfile &quot;site.cnf&quot; -extensions server</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost registry]# ll</span><br><span class="line">总用量 36</span><br><span class="line">-rw-r--r-- 1 root root  140 6月  13 17:03 root-ca.cnf</span><br><span class="line">-rw-r--r-- 1 root root 2021 6月  13 17:05 root-ca.crt</span><br><span class="line">-rw-r--r-- 1 root root 1708 6月  13 16:49 root-ca.csr</span><br><span class="line">-rw-r--r-- 1 root root 3247 6月  13 16:45 root-ca.key</span><br><span class="line">-rw-r--r-- 1 root root   17 6月  13 17:18 root-ca.srl</span><br><span class="line">-rw-r--r-- 1 root root  237 6月  13 17:14 site.cnf</span><br><span class="line">-rw-r--r-- 1 root root 1679 6月  13 17:10 site.csr</span><br><span class="line">-rw-r--r-- 1 root root 2098 6月  13 17:18 tokyle.com.crt</span><br><span class="line">-rw-r--r-- 1 root root 3243 6月  13 17:08 tokyle.com.key</span><br></pre></td></tr></table></figure><p>这样，就已经拥有了<code>tokyle.com</code>的网站SSL私钥<code>tokyle.com.key</code>和SSL证书<code>tokyle.com.crt</code>及CA根证书<code>root-ca.crt</code></p><p>新建ssl文件夹，将<code>tokyle.com.key</code>、<code>tokyle.com.crt</code>、<code>root-ca.crt</code>拷入，其他删除。</p><h4 id="配置私有仓库"><a href="#配置私有仓库" class="headerlink" title="配置私有仓库"></a>配置私有仓库</h4><p>私仓默认配置文件位于:<code>/etc/docker/registry/config.yml</code>，先本地编辑config.yml再挂在到容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">version: 0.1</span><br><span class="line">log:</span><br><span class="line">  accesslog:</span><br><span class="line">    disabled: true</span><br><span class="line">  level: debug</span><br><span class="line">  formatter: text</span><br><span class="line">  fields:</span><br><span class="line">    service: registry</span><br><span class="line">    environment: staging</span><br><span class="line">storage:</span><br><span class="line">  delete:</span><br><span class="line">    enabled: true</span><br><span class="line">  cache:</span><br><span class="line">    blobdescriptor: inmemory</span><br><span class="line">  filesystem:</span><br><span class="line">    rootdirectory: /var/lib/registry</span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    realm: basic-realm</span><br><span class="line">    path: /etc/docker/registry/auth/nginx.htpasswd</span><br><span class="line">http:</span><br><span class="line">  addr: :443</span><br><span class="line">  host: https://tokyle.com</span><br><span class="line">  headers:</span><br><span class="line">    X-Content-Type-Options: [nosniff]</span><br><span class="line">  http2:</span><br><span class="line">    disabled: false</span><br><span class="line">  tls:</span><br><span class="line">    certificate: /etc/docker/registry/ssl/tokyle.com.crt</span><br><span class="line">    key: /etc/docker/registry/ssl/tokyle.com.key</span><br><span class="line">health:</span><br><span class="line">  storagedriver:</span><br><span class="line">    enabled: true</span><br><span class="line">    interval: 10s</span><br><span class="line">threshold: 3</span><br></pre></td></tr></table></figure></p><h4 id="生成http认证文件"><a href="#生成http认证文件" class="headerlink" title="生成http认证文件"></a>生成http认证文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir auth</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">    --entrypoint htpasswd \</span><br><span class="line">    registry \</span><br><span class="line">    -Bbn username pwd &gt; auth/nginx.htpasswd</span><br></pre></td></tr></table></figure><p>用户名密码用自己的</p><h4 id="编辑docker-compose-yml"><a href="#编辑docker-compose-yml" class="headerlink" title="编辑docker-compose.yml"></a>编辑docker-compose.yml</h4><p><code>vim docker-compose.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  registry:</span><br><span class="line">    image: registry</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;443:443&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./:/etc/docker/registry</span><br><span class="line">      - registry-data:/var/lib/registry</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  registry-data:</span><br></pre></td></tr></table></figure></p><h4 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h4><p><code>vim /etc/hosts</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 tokyle.com</span><br></pre></td></tr></table></figure></p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>安装docker-compose<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U docker-compose</span><br></pre></td></tr></table></figure></p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p><p>由于自行签发的 CA 根证书不被系统信任，所以我们需要将 CA 根证书 ssl/root-ca.crt 移入/etc/docker/certs.d/docker.domain.com 文件夹中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker/certs.d/tokyle.com</span><br><span class="line">cp ssl/root-ca.crt /etc/docker/certs.d/tokyle.com/ca.crt</span><br></pre></td></tr></table></figure></p><h4 id="私仓操作"><a href="#私仓操作" class="headerlink" title="私仓操作"></a>私仓操作</h4><p>登录私仓：<code>docker login tokyle.com</code><br>就可以进行镜像推送、拉取了（需要登录进去）</p><h3 id="参考docker-practice"><a href="#参考docker-practice" class="headerlink" title="参考docker practice"></a>参考docker practice</h3><blockquote><p><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry_auth.html" target="_blank" rel="noopener">私仓高级配置</a></p></blockquote><h3 id="使用Nexus建私仓"><a href="#使用Nexus建私仓" class="headerlink" title="使用Nexus建私仓"></a>使用Nexus建私仓</h3><p>docker官方的registry建立的仓库，有些镜像删除后不会回收空间，必须命令去释放空间，重启Registry程序。当前比较常见的做法是使用<code>Nexus</code>来管理<code>Docker</code>、<code>Yum</code>、<code>PyPI</code>等</p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nexus3 --restart=always \</span><br><span class="line">    -p 8081:8081 sonatype/nexus3</span><br></pre></td></tr></table></figure></p><p>需要等一段时间，可以进容器<code>docker exec -it nexus3 bash</code>，看日志<code>/nexus-data/log/nexus.log</code>看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Started Sonatype Nexus OSS 3.16.2-01</span><br></pre></td></tr></table></figure></p><p>就是起好了，可以通过<a href="http://IP:8088访问web页面。默认账密：`admin/admin123`" target="_blank" rel="noopener">http://IP:8088访问web页面。默认账密：`admin/admin123`</a></p><h4 id="Nexus配置"><a href="#Nexus配置" class="headerlink" title="Nexus配置"></a>Nexus配置</h4><h5 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h5><p>进入nexus界面之后，创建仓库：<br>点击设置（齿轮）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Repository-&gt;Repositories 点击右边菜单 Create repository 选择 docker (hosted)</span><br></pre></td></tr></table></figure></p><ul><li>Name: 仓库的名称，如dockertest</li><li>HTTP: 仓库单独的访问端口，如8082</li><li>Enable Docker V1 API: 如果需要同时支持 V1 版本请勾选此项</li><li>Hosted -&gt; Deployment pollcy: 请选择 Allow redeploy 否则无法上传 Docker 镜像</li></ul><h5 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h5><p>菜单 Security-&gt;Realms 把 Docker Bearer Token Realm 移到右边的框中保存。</p><p>添加用户规则：菜单 Security-&gt;Roles-&gt;Create role 在 Privlleges 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p><p>添加用户：菜单 Security-&gt;Users-&gt;Create local user 在 Roles 选项中选中刚才创建的规则移动到右边的窗口保存。</p><h4 id="操作Nexus私仓"><a href="#操作Nexus私仓" class="headerlink" title="操作Nexus私仓"></a>操作Nexus私仓</h4><p>和之前官方私仓一样，不是https访问，需要在<code>/etc/docker/daemon.json</code>中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   &quot;insecure-registries&quot;:[&quot;http://192.168.0.97:8082&quot;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重启docker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>登录：<code>docker login 192.168.0.97:8082</code>，输入创建的用户名和密码，完成登录。</p><h5 id="Error-response-from-daemon-Get-http-192-168-0-97-8082-v2-dial-tcp-192-168-0-97-8082-connect-connection-refused"><a href="#Error-response-from-daemon-Get-http-192-168-0-97-8082-v2-dial-tcp-192-168-0-97-8082-connect-connection-refused" class="headerlink" title="Error response from daemon: Get http://192.168.0.97:8082/v2/: dial tcp 192.168.0.97:8082: connect: connection refused"></a>Error response from daemon: Get <a href="http://192.168.0.97:8082/v2/" target="_blank" rel="noopener">http://192.168.0.97:8082/v2/</a>: dial tcp 192.168.0.97:8082: connect: connection refused</h5><p><code>docker login 192.168.0.97:8082</code>时候，登录不进去，确认用户名密码正确，确认有添加到daemon.json中。<br>这个问题折腾我一个上午，想来想去，配置的没有问题，然后翻Stack Overflow时候看到差不多的问题，才知道什么鬼。。</p><p>首先，碰到这个，用curl验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http://192.168.0.97:8082/v2/_catalog&quot;</span><br><span class="line"></span><br><span class="line">curl: (7) Failed connect to 192.168.0.97:8082; Connection refused</span><br></pre></td></tr></table></figure></p><p>证明这个端口应该压根就没起来，然后往回翻，看看起nexus3这个容器的命令，发现是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nexus3 --restart=always \</span><br><span class="line">    -p 8081:8081 sonatype/nexus3</span><br></pre></td></tr></table></figure></p><p>只给nexus3分配了8081端口，没有其他端口暴露出来，即使在页面设置了8082端口，因为8082是在容器内部，没有暴露出来，所以在服务器上，根本就连不到192.168.0.97的8082端口，解决办法就是暴露出8082端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8081:8081 -p 8082:8082 -p 8083:8083 --restart=always --name nexus3 sonatype/nexus3</span><br></pre></td></tr></table></figure></p><p>然后再进入nexus页面重新设置，这样，就可以登陆了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost log]# docker login 192.168.0.97:8082</span><br><span class="line">Username: admin</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure></p><h5 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h5><p>首先登录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker login 192.168.0.97:8082</span><br><span class="line">Username: kyle</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure></p><p>镜像操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:v2 192.168.0.97:8082/nginx:v2</span><br><span class="line"></span><br><span class="line">[root@localhost docker]# docker push 192.168.0.97:8082/nginx:v2</span><br><span class="line">The push refers to repository [192.168.0.97:8082/nginx]</span><br><span class="line">7df9ba6b1822: Pushed </span><br><span class="line">ea06a73e56fc: Pushed </span><br><span class="line">22c458a3ff08: Pushed </span><br><span class="line">6270adb5794c: Pushed </span><br><span class="line">v2: digest: sha256:619a4fd83aef966bbee5677f0a2c169ae990cf83b9183aed0969c991b04e23dc size: 1155</span><br></pre></td></tr></table></figure></p><p>可以到nexus界面的Docker栏看到推送上去的镜像。</p><p>删除本地镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker image ls</span><br><span class="line">REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.0.97:8082/nginx   v2                  f531cfc896d6        3 days ago          109MB</span><br><span class="line">nginx                     v2                  f531cfc896d6        3 days ago          109MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost docker]# docker rmi 192.168.0.97:8082/nginx:v2</span><br><span class="line">Untagged: 192.168.0.97:8082/nginx:v2</span><br><span class="line">Untagged: 192.168.0.97:8082/nginx@sha256:619a4fd83aef966bbee5677f0a2c169ae990cf83b9183aed0969c991b04e23dc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost docker]# docker image ls</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                 v2                  f531cfc896d6        3 days ago          109MB</span><br></pre></td></tr></table></figure></p><p>从nexus私仓拉取镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker pull 192.168.0.97:8082/nginx:v2</span><br><span class="line">v2: Pulling from nginx</span><br><span class="line">Digest: sha256:619a4fd83aef966bbee5677f0a2c169ae990cf83b9183aed0969c991b04e23dc</span><br><span class="line">Status: Downloaded newer image for 192.168.0.97:8082/nginx:v2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost docker]# docker image ls</span><br><span class="line">REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.0.97:8082/nginx   v2                  f531cfc896d6        3 days ago          109MB</span><br><span class="line">nginx                     v2                  f531cfc896d6        3 days ago          109MB</span><br></pre></td></tr></table></figure></p><p>退出私仓：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker logout 192.168.0.97:8082</span><br><span class="line">Removing login credentials for 192.168.0.97:8082</span><br></pre></td></tr></table></figure></p><p>然后，可以对自己的私仓加上个<strong>s</strong>，更安全一点，这个，教程一堆</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（五）&lt;/p&gt;
&lt;p&gt;仓库&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（四）</title>
    <link href="http://tokyle.com/2019/06/13/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/13/docker简单使用（四）/</id>
    <published>2019-06-13T06:48:29.000Z</published>
    <updated>2019-06-13T06:49:04.406Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（四）</p><p>Docker容器操作<br><a id="more"></a></p><h3 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h3><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>构建完镜像之后，启动容器<br>例如：<code>docker run -it ubintu:16.04 bash</code>，启ubuntu，并开启交互终端</p><h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><p>容器已经关闭，可以使用<code>docker container start containerID(或name)</code>启动<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser2]# docker run --name web1 -d -p 8088:80 nginx</span><br><span class="line">73a5c1a3ac2300f6e2317ae39c9571b84be07e44beb92fcb98b41ee68aa6672a</span><br><span class="line"></span><br><span class="line">[root@localhost myuser2]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                          PORTS                  NAMES</span><br><span class="line">73a5c1a3ac23        nginx               &quot;nginx -g &apos;daemon of…&quot;   14 seconds ago      Up 4 seconds                    0.0.0.0:8088-&gt;80/tcp   web1</span><br></pre></td></tr></table></figure></p><p>关掉容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser2]# docker kill 73a5c1a3ac23</span><br><span class="line">73a5c1a3ac23</span><br><span class="line"></span><br><span class="line">[root@localhost myuser2]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                        PORTS               NAMES</span><br><span class="line">73a5c1a3ac23        nginx               &quot;nginx -g &apos;daemon of…&quot;   About a minute ago   Exited (137) 14 seconds ago                       web1</span><br></pre></td></tr></table></figure></p><p>重新启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser2]# docker container start 73a5c1a3ac23</span><br><span class="line">73a5c1a3ac23</span><br><span class="line"></span><br><span class="line">[root@localhost myuser2]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                     PORTS                  NAMES</span><br><span class="line">73a5c1a3ac23        nginx               &quot;nginx -g &apos;daemon of…&quot;   About a minute ago   Up 9 seconds               0.0.0.0:8088-&gt;80/tcp   web1</span><br></pre></td></tr></table></figure></p><p><code>docker container start -i  5879098886bf</code>以交互模式重启</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>推荐<code>docker exec</code>，交互模式：<code>docker exec -it container</code></p><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>可以<code>docker container stop containerid(name)</code><br>也可以暴力的<code>dokcer kill containerid</code></p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p><code>docker rm containerid</code></p><p>删除镜像：<code>docker rmi imageid</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（四）&lt;/p&gt;
&lt;p&gt;Docker容器操作&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（三）</title>
    <link href="http://tokyle.com/2019/06/12/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/12/docker简单使用（三）/</id>
    <published>2019-06-13T02:43:54.000Z</published>
    <updated>2019-06-13T02:44:32.823Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（三）</p><p>Dockerfile简介二<br><a id="more"></a><br>简单介绍Dockerfile的一些指令</p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>COPY，复制文件指令，格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;源路径&gt;  &lt;目标路径&gt;</span><br></pre></td></tr></table></figure></p><p>另一种格式类似函数调用：<code>COPY [&quot;&lt;源路径&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p><p>COPY指令作用是从构建上下文目录中<code>&lt;源路径&gt;</code>（相对于上下文的路径）下的文件复制到镜像中的<code>目标路径</code></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY test1.txt /usr/local/test/</span><br></pre></td></tr></table></figure></p><p>将当前上下文目录下的test1.txt复制到新镜像的/usr/local/test/文件夹下<br>&lt;目标路径&gt;可以是容器内的绝对路径，也可以是相对于<code>WOKDIR</code>的相对路径</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>不实用的命令，有拷贝的功能，同时，可以拷贝url，但是使用ADD url时，docker会先将url的文件下载下来，如果是个压缩包，还需要自己添加一层RUN进行解压，剔除不需要的文件，再复制；所以不如直接RUN wget，然后解压缩，剔除文件复制</p><p>ADD命令在有一种情况下很有用，源路径是一个gzip，bzip2以及xz的压缩包，ADD会自动解压压缩包到目标路径。</p><p>在《docker practice》中指出，<strong>在COPY和ADD指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用COPY指令，仅在需要自动解压缩场合使用ADD</strong></p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>首先要理解，容器是进程，不是虚拟机，在正常linux中，运行进程一般都伴随有启动参数，类似的，容器也有，CMD就是用于指定默认的容器主进程的启动命令的</p><p>格式：<br><code>shell</code>格式：<code>CMD &lt;命令&gt;</code><br><code>exec</code>格式：<code>CMD [&quot;可执行文件&quot;， &quot;参数1&quot;, &quot;参数2&quot;...]</code></p><p>在运行时，可以使用CMD来指定新的命令来替代镜像中设置的默认命令，例如，ubuntu镜像的默认CMD是<code>/bin/bash</code>，如果我们直接<code>docker run -it ubuntu:16.04</code>会直接进入<code>bash</code>；也可以指定别的命令，例如输出系统版本：<code>docker run -it ubuntu:16.04 cat /etc/os-rlease</code></p><p>在指令格式上，推荐使用<code>CMD [&quot;可执行文件&quot;， &quot;参数1&quot;, &quot;参数2&quot;...]</code>，这类格式会被解析成JSON，因此一定要是用双引号<code>&quot;</code><br>如果使用shell格式，例如<code>CMD echo $JAVA_HOME</code>在实际执行中会变更为<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $JAVA_HOME&quot;]</code>，实际会被包装成<code>sh -c</code>的参数形式。（这也是shell中可以直接使用环境变量的原因）</p><p>前面说过，容器其实就是进程，本身就是进程，所以就不存在什么进程里面的程序有后台执行的说法了，容器中的应用，都是在前台执行的，不存在systemctl这样的操作，不会像虚拟机中有<code>systemctl start mysqld</code>这样的操作，如果使用CMD写成这样的：<code>CMD systemctl start nginx</code>，会发现容器执行后立刻退出。</p><p>这是因为，docker容器，默认会把容器内部第一个进程，也就是pid=1的程序作为docker容器正在运行的依据，如果容器中pid=1的程序挂了，那docker容器就会直接退出；在执行<code>CMD systemctl start nginx</code>时候，实际执行的是<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;systemctl start nginx&quot;]</code>，起初pid=1的程序是bash，但是后面接上了systemctl start nginx（后台守护模式daemon启动nginx），使得systemctl start nginx进程启动后，sh也结束了（CMD会更改默认命令），当pid=1的程序结束，容器就退出了。所以只要运行程序时候，在非守护模式下，容器就不会退出，因此，容器内启动nginx可以：<code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off&quot;]</code></p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>和CMD类似，不同的是，CMD会被docker run覆盖，而ENTERPOINT不会，例如以下一个最简单的镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">CMD [&quot;/bin/echo&quot;, &quot;test&quot;]</span><br></pre></td></tr></table></figure></p><p>构建镜像：<code>docker build -t echotest .</code>，<br>运行容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myip]# docker run echotest </span><br><span class="line">test</span><br></pre></td></tr></table></figure></p><p>但是既然容器是进程，那如果像其他进程一样，加参数，效果如何：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myip]# docker run echotest -i</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;exec: \&quot;-i\&quot;: executable file not found in $PATH&quot;: unknown.</span><br><span class="line">ERRO[0001] error waiting for container: context canceled</span><br></pre></td></tr></table></figure></p><p>直接就报错了。。这是因为跟在镜像名之后的执行，会替换调CMD的默认值，但是-i又不是个指令，所以就报错了。</p><p>ENTRYPOINT在这点上就可以做到带参数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;test&quot;]</span><br></pre></td></tr></table></figure></p><p>构建：<code>docker build -t echotest2 .</code>，运行容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost echotest]# docker run echotest2 -i</span><br><span class="line">test -i</span><br></pre></td></tr></table></figure></p><p>可以看到，-i可以带进去。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>顾名思义，设置环境变量<code>ENV JAVA_VERSION 1.8.0_191</code></p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>和ENV类似，都是设置环境变量。区别在于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The ARG instruction defines a variable that users can pass at build-time to the builder with the docker build command using the --build-arg &lt;varname&gt;=&lt;value&gt; flag.ARG指令定义了用户可以在编译时或者运行时传递的变量，如使用如下命令：--build-arg &lt;varname&gt;=&lt;value&gt;</span><br><span class="line"></span><br><span class="line">The ENV instruction sets the environment variable &lt;key&gt; to the value &lt;value&gt;. The environment variables set using ENV will persist when a container is run from the resulting image.ENV指令是在dockerfile里面设置环境变量，不能在编译时或运行时传递。</span><br></pre></td></tr></table></figure></p><p>例如，在Dockerfile中定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG a_key1</span><br><span class="line">ARG a_key2 = a_value2</span><br></pre></td></tr></table></figure></p><p>ARG指令定义的参数，在docker build命令中可以通过–build-arg a_key1=avalue1来覆盖</p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>创建一个可以从本地主机或其他容器挂载的挂在点，格式：<code>VOLUME [&quot;/data&quot;]</code><br>对于数据库类需要保存动态数据的应用，数据库文件应该保存在卷（volume）。为了防止运行时用户忘记将动态文件所保存的目录挂在为卷，在写Dockerfile时，就可以事先指定某些目录挂载为匿名卷，这样运行时如果用户不挂载，应用也可以正常运行，不会向容器存储层写大量数据</p><p><code>VOLUME [&quot;/data&quot;]</code>,这里的<code>/data</code>目录就会在运行时自动挂载为匿名卷，任何向/data中写入的信息都不会记录进容器存储层。当然，docker run时候也可以覆盖这个设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data/tmp mysql</span><br></pre></td></tr></table></figure></p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>声明端口，格式：<code>EXPOSE &lt;port1&gt; &lt;port2&gt;</code><br>用来指定要映射出去的端口，例如，容器内部开启了nginx,就需要将80（或者指定的端口）暴露出去：<code>EXPOSE 80</code>。这个需要-P（大写）配合，启动容器是，加上-P，让它自动分配。如果想指定具体端口，使用-p(小写)</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定工作目录，格式：<code>WORKDIR &lt;工作目录路径&gt;</code>，作用就是为后续的<code>RUN</code>、<code>COPY</code>等指定工作目录<br>在Dockerfile中，每个RUN，都会启一个容器，都是一个<code>启动容器</code>、<code>执行命令</code>、<code>提交存储层文件变更</code>的操作。<br>示例，如果Dockerfile这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN cd /home \</span><br><span class="line">    &amp;&amp; mkdir myapp \</span><br><span class="line">    &amp;&amp; cd myapp</span><br><span class="line">RUN echo &quot;docker practice&quot; &gt; test1.txt</span><br></pre></td></tr></table></figure></p><p>然后构建镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myworkfile]# docker build -t workfile1 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/3 : FROM ubuntu:16.04</span><br><span class="line"> ---&gt; 2a697363a870</span><br><span class="line">Step 2/3 : RUN cd /home     &amp;&amp; mkdir myapp     &amp;&amp; cd myapp</span><br><span class="line"> ---&gt; Running in a33b48c39597</span><br><span class="line">Removing intermediate container a33b48c39597</span><br><span class="line"> ---&gt; daebc80cbf9d</span><br><span class="line">Step 3/3 : RUN echo &quot;docker practice&quot; &gt; test1.txt</span><br><span class="line"> ---&gt; Running in 500473ff3363</span><br><span class="line">Removing intermediate container 500473ff3363</span><br><span class="line"> ---&gt; 4a1668a9a53c</span><br><span class="line">Successfully built 4a1668a9a53c</span><br><span class="line">Successfully tagged workfile1:latest</span><br></pre></td></tr></table></figure></p><p>可以看到，构建过程中，出现了两个中间容器<code>a33b48c39597</code>和<code>500473ff3363</code>，所以这两个RUN，其实运行的是不一样的容器，最终结果，启动容器后在<code>/home/myapp</code>下可能就找不到<code>test1.txt</code>，验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myworkfile]# docker run -it workfile1 bash</span><br><span class="line">root@3a7bbb6da9a2:/# cd /home/</span><br><span class="line">root@3a7bbb6da9a2:/home# ls</span><br><span class="line">myapp</span><br><span class="line">root@3a7bbb6da9a2:/home# cd myapp/</span><br><span class="line">root@3a7bbb6da9a2:/home/myapp# ls</span><br><span class="line">root@3a7bbb6da9a2:/home/myapp#</span><br></pre></td></tr></table></figure></p><p>没有找到test1.txt</p><p>使用WORKDIR:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">WORKDIR /home/myapp</span><br><span class="line">RUN echo &quot;docker practice&quot; &gt; test2.txt</span><br></pre></td></tr></table></figure></p><p>构建镜像，运行容器，查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myworkfile2]# docker build -t workfile2 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/3 : FROM ubuntu:16.04</span><br><span class="line"> ---&gt; 2a697363a870</span><br><span class="line">Step 2/3 : WORKDIR /home/myapp</span><br><span class="line"> ---&gt; Running in a64c73b81fcb</span><br><span class="line">Removing intermediate container a64c73b81fcb</span><br><span class="line"> ---&gt; c7868d92cec6</span><br><span class="line">Step 3/3 : RUN echo &quot;docker practice&quot; &gt; test2.txt</span><br><span class="line"> ---&gt; Running in f18afb589fee</span><br><span class="line">Removing intermediate container f18afb589fee</span><br><span class="line"> ---&gt; 8733481c9491</span><br><span class="line">Successfully built 8733481c9491</span><br><span class="line">Successfully tagged workfile2:latest</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myworkfile2]# docker run -it workfile2 bash</span><br><span class="line">root@8bc345cf4fe7:/home/myapp# ls</span><br><span class="line">test2.txt</span><br><span class="line">root@8bc345cf4fe7:/home/myapp# cat test2.txt </span><br><span class="line">docker practic</span><br></pre></td></tr></table></figure><p>看到在<code>/home/myapp</code>下有<code>test2.txt</code>，并且内容是我们指定的。</p><p>Ps 在Dockerfile中，这边只使用<code>WORKDIR /home/myapp</code>并没有创建该目录，但是，后面执行就是在该目录下，这是因为<code>WORKDIR</code>会帮你建立目录</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>和<code>WORKDIR</code>类似，指定之后执行<code>RUN</code>、<code>COPY</code>等命令的用户；</p><p>示例一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">USER kyle</span><br><span class="line">RUN echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure></p><p>构建镜像:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser2]# docker build -t myuser2 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/3 : FROM ubuntu:16.04</span><br><span class="line"> ---&gt; 2a697363a870</span><br><span class="line">Step 2/3 : USER kyle</span><br><span class="line"> ---&gt; Running in b9af960d2702</span><br><span class="line">Removing intermediate container b9af960d2702</span><br><span class="line"> ---&gt; ba5592dfdba1</span><br><span class="line">Step 3/3 : RUN echo &quot;Hello world&quot;</span><br><span class="line"> ---&gt; Running in d93f1b59934c</span><br><span class="line">unable to find user kyle: no matching entries in passwd file</span><br></pre></td></tr></table></figure></p><p>发现报错，kyle该用户不存在，镜像<code>myuser2</code>构建不成功</p><p>示例二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser1]# cat Dockerfile </span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN groupadd -r tests &amp;&amp; useradd -r -g tests kyle</span><br><span class="line">USER kyle</span><br><span class="line">RUN echo &quot;Hello World&quot;</span><br></pre></td></tr></table></figure></p><p>构建镜像，运行容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser1]# docker build -t myuser1 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM ubuntu:16.04</span><br><span class="line"> ---&gt; 2a697363a870</span><br><span class="line">Step 2/4 : RUN groupadd -r tests &amp;&amp; useradd -r -g tests kyle</span><br><span class="line"> ---&gt; Running in 95030508e783</span><br><span class="line">Removing intermediate container 95030508e783</span><br><span class="line"> ---&gt; 8910cd5c0ee0</span><br><span class="line">Step 3/4 : USER kyle</span><br><span class="line"> ---&gt; Running in 5ca75c068a8b</span><br><span class="line">Removing intermediate container 5ca75c068a8b</span><br><span class="line"> ---&gt; 17e120181a8a</span><br><span class="line">Step 4/4 : RUN echo &quot;Hello World&quot;</span><br><span class="line"> ---&gt; Running in 022b81376556</span><br><span class="line">Hello World</span><br><span class="line">Removing intermediate container 022b81376556</span><br><span class="line"> ---&gt; 73527faf6379</span><br><span class="line">Successfully built 73527faf6379</span><br><span class="line">Successfully tagged myuser1:latest</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost myuser1]# docker run -it myuser1 bash</span><br><span class="line">kyle@55b05690325a:/$ whoami</span><br><span class="line">kyle</span><br></pre></td></tr></table></figure><p>成功构建镜像，切换用户。</p><p>这两个示例可以看出，使用<code>USER</code>之前，必须创建好用户，也就是<strong><code>USER</code>不会帮你建用户，只是切换用户</strong></p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>指定制作作者信息，格式：<code>MAINTAINER &lt;name&gt;</code>，例如<code>MAINTAINER kyle kyle@xxx.com</code></p><p>以上，就是Dockerfile一些常用的指令，基本是借鉴的<a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">《docker practice》</a>…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（三）&lt;/p&gt;
&lt;p&gt;Dockerfile简介二&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客配置https</title>
    <link href="http://tokyle.com/2019/06/11/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AEhttps/"/>
    <id>http://tokyle.com/2019/06/11/hexo博客配置https/</id>
    <published>2019-06-11T09:30:35.000Z</published>
    <updated>2019-06-11T09:37:59.043Z</updated>
    
    <content type="html"><![CDATA[<p>hexo博客配置https</p><a id="more"></a><p>整天被chrome提醒不安全，简直了，实在忍不下去了，给博客加个s</p><p>方法很简单，到<a href="https://dash.cloudflare.com/login" target="_blank" rel="noopener">CloudFlare</a>解析域名，开启CDN强制http转https，修改DNS即可</p><p>原DNS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dns23.hichina.com</span><br><span class="line"></span><br><span class="line">dns24.hichina.com</span><br></pre></td></tr></table></figure></p><p>修改后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cortney.ns.cloudflare.com</span><br><span class="line"></span><br><span class="line">lloyd.ns.cloudflare.com</span><br></pre></td></tr></table></figure></p><p><code>CloudFlare</code>注册以后配置很简单，基本输入自己域名（tokyle.com）下一步下一步就结束了</p><p>就最后有一步配置DNS:<code>DNS Manage your Domain Name System (DNS) settings</code>时候，CNAME配置自己的域名，然后到对应的域名提供商（阿里云）去修改DNS解析</p><p>成功之后，CloudFlare会邮件给你，就可以愉快的https了：</p><blockquote><p><a href="https://tokyle.com">https://tokyle.com</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo博客配置https&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://tokyle.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Hexo" scheme="http://tokyle.com/tags/Hexo/"/>
    
      <category term="https" scheme="http://tokyle.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（二）</title>
    <link href="http://tokyle.com/2019/06/11/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/11/docker简单使用（二）/</id>
    <published>2019-06-11T08:06:36.000Z</published>
    <updated>2019-06-11T08:07:36.209Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（二）</p><p>Dockerfile简介一<br><a id="more"></a></p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile是一个包含一条条指令的文本文件，其中每一条指令都构建一层（每一条指令的内存，就是描述该层应当如何构建）（docker镜像采用联合文件系统）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</span><br></pre></td></tr></table></figure><p>Dockerfile使用示例，建立一个空白文件夹，进去文件夹，创建Dockerfile，编辑Dockerfile，编写指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir nginxtest</span><br><span class="line"></span><br><span class="line">cd nginxtest</span><br><span class="line"></span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure></p><p>Dockerfile内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></p><p>在当前文件夹，构建镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginxtest]# docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"> ---&gt; 62c261073ecf</span><br><span class="line">Step 2/2 : RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running in c20926fff810</span><br><span class="line">Removing intermediate container c20926fff810</span><br><span class="line"> ---&gt; 6ee9e7b88db2</span><br><span class="line">Successfully built 6ee9e7b88db2</span><br><span class="line">Successfully tagged nginx:v3</span><br></pre></td></tr></table></figure></p><p>注意docker build最后有个<code>.</code>表示镜像构建的上下文（Context）</p><h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h3><p>说实话，网上全是抄的一模一样的，全部来去《docker practice》，我也说不好自己理解的是对是错。。</p><p>首先，我也抄一下，docker其实是C/S架构，在执行docker build的时候，其实是有和server端（Docker引擎，服务端守护进程）进行交互。<br>Docker运行时，Docker引擎提供一组REST API，docker命令这样的客户端，就是通过这组API与Docker引擎交互，从而完成各种功能。<br>因此，在进行docker build的时候，看起来像是在本地进行构建，实际上，是先将上下文定义的路径下构建需要的包上传到Docker引擎，在Docker引擎处（服务端）完成构建。之前进行构建示例时候，有一行可以看出，和server进行了交互：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon  2.048kB</span><br></pre></td></tr></table></figure></p><p>在Dockerfile中经常会需要用到COPY，服务器在执行构建的时候，就需要知道copy的文件的地址，也就是上下文路径，需要注意的是，Docker的镜像构建上下文，即不是docker build执行的路径，也不是Dockerfile当前所在的目录。默认情况下，是建议创建一个空文件夹，然后将构建需要的文件和Dockerfile都放在该文件夹下，这样理所当然的Dockerfile所在路径就是上下文路径。<br>（说实话，这个上下文，有点晕，不是很理解，我只能理解成是构建需要的文件所在的路径为上下文；也就是为什么要创建一个空文件夹，将构建需要的文件和Dockerfile放进该文件夹的原因）<br>一定要记住，<strong>千万不要把Dockerfile放在根目录，不然会打包整个硬盘</strong></p><p>一些Dockerfile指令示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY ./package.json /etc/</span><br><span class="line">COPY pachage.json /etc/</span><br></pre></td></tr></table></figure></p><p>上述两句效果是一样的，都是讲上下文下的<code>package.json</code>拷贝到镜像里面的<code>/etc/</code>下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY /usr/local/nginx/nginx.conf /etc/nginx/</span><br></pre></td></tr></table></figure><p>上面这条，会无法工作，因为<code>/usr/local/nginx/nginx.conf</code>已经超出了上下文范文，服务端无法获取该文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /usr/kyle/dockertest/a/Dockerfile .</span><br></pre></td></tr></table></figure></p><p>当Dockerfile不在构建上下文的根目录下，可以-f指定该文件位置（当前执行docker build在构建上下文下，可以理解为，当前有个空文件夹，里面是构建需要的文件，但是Dockerfile不在当前文件夹下，可以通过-f指定）</p><h4 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h4><p>现在上下文中有不想上传到服务端的文件，就需要使用<code>.dockerignore</code>，例如当前文件夹下有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mynginx]# ls -al</span><br><span class="line">总用量 20</span><br><span class="line">drwxr-xr-x  2 root root  96 6月  11 15:23 .</span><br><span class="line">drwxr-xr-x. 6 root root 147 6月  11 11:07 ..</span><br><span class="line">-rw-r--r--  1 root root  99 6月  11 15:22 Dockerfile</span><br><span class="line">-rw-r--r--  1 root root  10 6月  11 15:23 .dockerignore</span><br><span class="line">-rw-r--r--  1 root root  33 6月  11 15:20 text1.txt</span><br><span class="line">-rw-r--r--  1 root root  37 6月  11 15:20 text2.txt</span><br><span class="line">-rw-r--r--  1 root root  19 6月  11 15:22 text3.txt</span><br></pre></td></tr></table></figure></p><p>不想把text3.txt上传到server，其中Dockerfile内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">COPY text* /home/</span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></p><p>这样，只需要编辑<code>.dockerignore</code>，将text3.txt添加进去，然后构建镜像即可<br>可以起容器，进去验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mynginx]# docker run --name web2 -d -p 8070:80 nginx:v4</span><br><span class="line">76527bd2b0f601e4fa844b9ed3afc4f29da65ee1d202fca6ee6c81380591ad0a</span><br><span class="line">[root@localhost mynginx]# </span><br><span class="line">[root@localhost mynginx]# docker exec -it web2 bash</span><br><span class="line">root@76527bd2b0f6:/# cd /home</span><br><span class="line">root@76527bd2b0f6:/home# ls</span><br><span class="line">text1.txt  text2.txt</span><br></pre></td></tr></table></figure></p><p>可以看到，已经忽略了text3.txt</p><p>tips：<strong>删除镜像</strong>：<code>docker rmi imageid</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mynginx]# docker rmi a59be9875db4</span><br><span class="line">Untagged: nginx:v4</span><br><span class="line">Deleted: sha256:a59be9875db4025dcdab5a26c239302eec9bea47427b04eaa02e2111a800d2ec</span><br><span class="line">Deleted: sha256:7cc4283ef786efa1f9e2885533d3c3eb815a273548f5e7bbfda777726173a7b9</span><br><span class="line">Deleted: sha256:9e87263adf6572244788519ce5c9338c3e70b6e62cc6f1092e9b257a487ecb3c</span><br><span class="line">Deleted: sha256:79b76358156ea32a59800f6d4600a8ce79cc3798cd0ddfcad3362a014f96b397</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（二）&lt;/p&gt;
&lt;p&gt;Dockerfile简介一&lt;br&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简单使用（一）</title>
    <link href="http://tokyle.com/2019/06/10/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://tokyle.com/2019/06/10/docker简单使用（一）/</id>
    <published>2019-06-11T02:14:21.000Z</published>
    <updated>2019-06-11T02:15:35.700Z</updated>
    
    <content type="html"><![CDATA[<p>docker简单使用（一）</p><a id="more"></a><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>docker获取镜像很简单，<code>docker pull image:tag</code>即可，不加tag默认获取最新<code>latest</code><br>例如，获取Ubuntu和nginx：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu#获取latest</span><br><span class="line"></span><br><span class="line">docker pull ubuntu:16.04#获取16.04版本ubuntu</span><br><span class="line"></span><br><span class="line">docker pull nginx#获取latest版nginx</span><br></pre></td></tr></table></figure></p><h4 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h4><p>获取完镜像之后，可以通过<code>dokcer images</code>来查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                 latest              62c261073ecf        5 days ago          109MB</span><br><span class="line">ubuntu                16.04               2a697363a870        3 weeks ago         119MB</span><br><span class="line">ubuntu                latest              7698f282e524        3 weeks ago         69.9MB</span><br><span class="line">hello-world           latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line">ngrinder/controller   latest              e7f8d86685cd        3 years ago         246MB</span><br></pre></td></tr></table></figure></p><p>镜像的运行，以ubuntu:16.04为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu:16.04</span><br></pre></td></tr></table></figure></p><p>可以通过<code>docker ps -a</code>来查看当前运行的镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker  ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS                  NAMES</span><br><span class="line">385364730b09        ubuntu:16.04        &quot;/bin/bash&quot;              18 seconds ago      Up 16 seconds                                         nervous_jones</span><br></pre></td></tr></table></figure></p><p>其中<code>-it</code>表示以交互式方式运行镜像，这样，就可以进入交互式终端（ubuntu），来进行一些操作，例如查看当前系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@385364730b09:/# cat /etc/os-release</span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION=&quot;16.04.6 LTS (Xenial Xerus)&quot;</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 16.04.6 LTS&quot;</span><br><span class="line">VERSION_ID=&quot;16.04&quot;</span><br><span class="line">HOME_URL=&quot;http://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br></pre></td></tr></table></figure></p><p>使用<code>exit</code>退出容器</p><p>查看当前容器状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS                  NAMES</span><br><span class="line">385364730b09        ubuntu:16.04        &quot;/bin/bash&quot;              2 minutes ago       Exited (0) 4 seconds ago                              nervous_jones</span><br></pre></td></tr></table></figure></p><p>可以看见当前STATUS状态从<code>Up xxx</code>变成了<code>Exited</code>，容器以及被关闭，如果该容器只是用来调试错误，在关闭之后可以进行删除操作：<code>docker rm 385364730b09</code>(Container id)</p><p>或者在启动镜像时候就直接指定关闭即删除容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm ubuntu:16.04</span><br></pre></td></tr></table></figure></p><h4 id="运行webserver"><a href="#运行webserver" class="headerlink" title="运行webserver"></a>运行webserver</h4><p>像类似nginx这样的webserver，运行时候，需要指定端口，可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web1 -d -p 8088:80 nginx</span><br></pre></td></tr></table></figure></p><p>以nginx镜像启动名为web1的容器，端口从80映射到8088，这样，在浏览器中可以使用<strong><a href="http://ip:8088" target="_blank" rel="noopener">http://ip:8088</a></strong>打开nginx欢迎页面。</p><h4 id="commit保存新镜像"><a href="#commit保存新镜像" class="headerlink" title="commit保存新镜像"></a>commit保存新镜像</h4><p>前面已经启动了nginx的镜像，并且以8088端口运行，现在，修改nginx的欢迎页面来生成一个新的镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it web1 bash</span><br></pre></td></tr></table></figure></p><p>进入容器之后，修改默认页：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p><p>刷新浏览器页面即可，当前欢迎页已被修改<br>修改了容器的文件，也就是改动了容器的存储层，可以通过<code>docker diff web1</code>来查看具体改动</p><p>以上已经完成了修改nginx默认页，现在需要将修改保存成新的镜像，这样后面就可以直接使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker commit \</span><br><span class="line">&gt; --author &quot;kyle&quot; \</span><br><span class="line">&gt; --message &quot;change the default page&quot; \</span><br><span class="line">&gt; web1 \</span><br><span class="line">&gt; nginx:v2</span><br><span class="line">sha256:f531cfc896d61fd557748ddabb1ce2233e57f4e88e6cf49502e4c3e03de77eff</span><br></pre></td></tr></table></figure></p><p>然后使用docker images查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                 v2                  f531cfc896d6        12 minutes ago      109MB</span><br><span class="line">nginx                 latest              62c261073ecf        6 days ago          109MB</span><br><span class="line">ubuntu                16.04               2a697363a870        3 weeks ago         119MB</span><br><span class="line">ubuntu                latest              7698f282e524        3 weeks ago         69.9MB</span><br><span class="line">hello-world           latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line">ngrinder/controller   latest              e7f8d86685cd        3 years ago         246MB</span><br></pre></td></tr></table></figure></p><p>通过<code>docker history</code>查看镜像的历史记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker history nginx:v2</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">f531cfc896d6        15 minutes ago      nginx -g daemon off;                            106B                change the default page</span><br><span class="line">62c261073ecf        6 days ago          /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B                  </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c #(nop)  STOPSIGNAL SIGTERM           0B                  </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c #(nop)  EXPOSE 80                    0B                  </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c ln -sf /dev/stdout /var/log/nginx…   22B                 </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c set -x     &amp;&amp; addgroup --system -…   54MB                </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c #(nop)  ENV PKG_RELEASE=1~stretch    0B                  </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c #(nop)  ENV NJS_VERSION=0.3.2        0B                  </span><br><span class="line">&lt;missing&gt;           6 days ago          /bin/sh -c #(nop)  ENV NGINX_VERSION=1.17.0     0B                  </span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B                  </span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B                  </span><br><span class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop) ADD file:fcb9328ea4c115670…   55.3MB</span><br></pre></td></tr></table></figure></p><p><strong>备注：</strong> docker commit要慎用，该操作，即使是简单的修改一个默认页面，也会同时添加或改动很多文件，如果是安装软件包、编译构建，那会有大量无关内容被添加进来，不小心清理会导致镜像极为臃肿；并且，docker commit除了制作镜像的人，其他没有人知道执行过什么命令，无法保证下一次可以生成一个一模一样的镜像（以上，来自docker practice）</p><p>关于docker镜像的制作，最优良的方式是写<code>dockerfile</code> 这个后面再说</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker简单使用（一）&lt;/p&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>几个测试问题思考</title>
    <link href="http://tokyle.com/2019/05/29/%E5%87%A0%E4%B8%AA%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83/"/>
    <id>http://tokyle.com/2019/05/29/几个测试问题思考/</id>
    <published>2019-05-29T09:07:26.000Z</published>
    <updated>2019-05-29T09:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>几个测试问题思考</p><a id="more"></a><p>翻到了关于测试职业生涯的文章，里面有提到几个问题，自己想了想，挺震撼的，之前真没仔细考虑过</p><h3 id="如果测试时间不够，怎么办"><a href="#如果测试时间不够，怎么办" class="headerlink" title="如果测试时间不够，怎么办"></a>如果测试时间不够，怎么办</h3><p>或者可以延伸为，<strong>如果测试时间不够，肯定不能够全部覆盖的进行测试，是否可以只测试客户关心的，比较常用的功能？</strong></p><p>想了挺久，结合网友的讨论，我给出的答案是：<br>作为测试，碰到时间紧张，测试资源欠缺，我们所唯一能做的就是上报公司，让公司协调人工和资源做延期处理。这样做，公司可能会因为不能如期交付而受到一定的经济损失，但交付一个合格的产品给客户，绝对不会有信誉上的损失（即使做了常用功能的测试，也不能保障产品就已经达到的交付标准，实在是中彩票的事情），从长远来看，会有更多的收益；</p><p>作为测试，我们没有任何权利自己做风险处理，“测客户关心的，测主要功能”都是错误的测试行为；</p><p>作为测试，坚守自己的职业道德底线，只做职责范围内和力所能及的事情；</p><p>最后，一个大话，作为测试，不仅需要对支付你工资的老板负责，也请为你手中的产品负责，为客户支付的金钱负责。</p><h3 id="如果让你测试一个完全不熟悉的系统，怎么办"><a href="#如果让你测试一个完全不熟悉的系统，怎么办" class="headerlink" title="如果让你测试一个完全不熟悉的系统，怎么办"></a>如果让你测试一个完全不熟悉的系统，怎么办</h3><p>前提当然是可能没有需求说明书，甚至没有产品架构图<br>看到testerhome上一个回答，很有启发性<br>没有标准答案，参考如下：</p><ol><li><p>先去直接操作和观察被测物。（比直接奔向需求要加分很多，想一下，你实际工作中，快速理解一个东西靠的是什么？肯定不是先读文档，且不说这些文档是不是能够正确的描述被测物）</p></li><li><p>其他信息来源：同类产品，说明书，直接操作、观察被测物，原有版本，找产品经理，找开发，找销售，运维，客服，找用户，公司知识库，历史邮件，会议纪要，原来的各种文档，代码，google，相关法规，行业标准。。。</p></li><li><p>如果项目进度很赶，会先上手操作，参考能找到的一切文档及信息源，通过迭代，一边学一边加深理解，一边给出质量反馈；</p></li><li><p>思考是什么原因造成这样的局面：没有需求文档，没有架构图，开发很赶没空搭理。怎么解决：推动知识库建设和必要的文档输出，也是很重要的。</p></li></ol><h3 id="怎么优化测试工作"><a href="#怎么优化测试工作" class="headerlink" title="怎么优化测试工作"></a>怎么优化测试工作</h3><p>开发提测质量不高。测试的头几天，很多主流程都走不通，导致测试总是在等待，或者是跟着开发一起联调。而这段时间，已经被习惯性的认为是测试时间了，因为：提测了</p><p>项目抱怨，测试时间过长，如何缩短测试时间</p><p>先分析测试时间过长的原因，可能是：</p><ol><li><p>测试环境不可用，测试环境被占用</p></li><li><p>开发提测质量不高，主流程都走不通</p></li></ol><p>解决办法：<br>关于环境问题，可能可以实施：</p><ol><li><p>监控环境使用率，可用率（时间占比）；</p></li><li><p>规范部署，部署时间，操作人，checklist；</p></li><li><p>制定规则，权限分明，操作环境的人员，分工；</p></li><li><p>确定部署人员，backup人员，完整可行的部署手册</p></li><li><p>环境分组，分版本操作（更新devops技能，docker容器化进行环境隔离） </p></li><li><p>等等… </p></li></ol><p>关于提测质量</p><p>测试可以：</p><ol><li><p>有明确的测试计划，并让所有干系人都有明确的预期</p></li><li><p>测试依据风险测试，最大的风险得到最快的cover，科学分配时间，明显缩短bug反馈时间弧</p></li><li><p>bug严格管理，所有重要bug都及时修复</p></li><li><p>良好的沟通和汇报机制，每天让团队主要干系人清晰的知道，距离发布还差多远</p></li><li><p>外部资源联调非常早的进行，不会让它在测试后期成为测试blocker。</p></li></ol><p>要求开发可以：</p><ol><li><p>根据测试提供冒烟用例，开发必须完成一定程度的自测才能提测。</p></li><li><p>测试和开发做自动化同期共建，在开发过程中，核心功能就被自动化用例保护起来了。</p></li><li><p>开发切分feature提测，而不是攒一个大招一下子提一坨</p></li><li><p>代码Codereview变成团队常规活动，QA在早期跟进核心代码，把问题坑杀在萌芽阶段</p></li></ol><p>结合新的理念，测试左移：提前参与；测试右移：生产监控体系；全面保障产品质量，并且提高测试效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个测试问题思考&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://tokyle.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="lives" scheme="http://tokyle.com/tags/lives/"/>
    
  </entry>
  
  <entry>
    <title>闲谈测试理论</title>
    <link href="http://tokyle.com/2019/05/28/%E9%97%B2%E8%B0%88%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    <id>http://tokyle.com/2019/05/28/闲谈测试理论/</id>
    <published>2019-05-28T09:37:16.000Z</published>
    <updated>2019-05-28T09:37:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>闲谈测试理论</p><a id="more"></a><h3 id="测试理念"><a href="#测试理念" class="headerlink" title="测试理念"></a>测试理念</h3><p>也是个人的测试坚持吧，有很多，最在意的几条</p><p><strong>不为进度牺牲质量</strong></p><p><strong>软件测试，绝对不存在随便点点</strong></p><p><strong>测试人员要全力关注的是测试设计</strong></p><p><strong>测试工程师，是产品的第一批用户，关注用户满意度</strong></p><h3 id="测试工作"><a href="#测试工作" class="headerlink" title="测试工作"></a>测试工作</h3><h4 id="从需求出发"><a href="#从需求出发" class="headerlink" title="从需求出发"></a>从需求出发</h4><p>软件产品的设计、研发、测试、投产，一定是为了满足一定的需求，PRD（产品需求文档）所描述的产品需求，是切研发、测试开展的基础。或许现在很多公司号称敏捷开发， 没有PRD，那也一定会在类似wiki上有相应的记载，如果这个也没有，那产品最终的质量是很值得怀疑的，毕竟一点需求痕迹都没有，那测试人员的测试根据，就只是开发实现了，比起PO的需求，已经产生了很大的偏差。</p><p>测试人员进行软件测试必须从需求出发。首先要全面了解需求，包括其背景、关联性、用户特点等；其次要深入挖掘隐含的需求和关联，包括某个需求隐含了 对于系统现有功能的修改等等。 我们只有在全面、深入了解需求的基础上，才能设计全面、有效的测试用例来进行测试，以满足对于软件产品满足需求的基本质量保证。</p><h4 id="测试设计"><a href="#测试设计" class="headerlink" title="测试设计"></a>测试设计</h4><p>测试活动，最应该关注的是测试设计，而不是最后冷冰冰的执行了多少多少用例，提交了多少多少bug。</p><p>测试设计的基础是对于需求的全面理解，并且在需求的基础上，对于需求实现的设计进行一定的了解；很多测试人员进行测试活动的依据都是需求文档，而忽略了开发的逻辑设计这一块；如果可以进行一定的开发设计分析的话，可以帮助我们测试人员更加全面的进行质量验证（有些时候，开发是可以实现需求，但是会出现数组溢出等问题，这样的问题，在其他地方可能就会引起重大的bug）</p><p>个人觉得，关注测试设计，才是关注了软件测试之道</p><h4 id="测试目标"><a href="#测试目标" class="headerlink" title="测试目标"></a>测试目标</h4><p>需要明确的是，软件测试，是在生命周期的接近最末端，单单靠测试，是无法保证软件质量的，测试人员，是软件质量的验证者，并不是保障，软件质量需要整个生命周期，整个团队一起努力。</p><p>软件测试并不能保证测试活动结束之后，产品没有bug，这是不现实的，没有一个软件产品可以号称自己没有bug，同样，这也不是测试的目标。</p><p>引用网上看到的一句话：<br><strong>测试活动-是一个运用测试的思维和各种测试理论及方法，将所测试的软件产品的每一个功能都改变成一组特定的输入和一组特定的输出一一确定对应的形式，形成测试用例，然后待开发人员提交测试后，在测试环境部署被测程序，根据测试用例进行主动测试的过程。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闲谈测试理论&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://tokyle.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="lives" scheme="http://tokyle.com/tags/lives/"/>
    
  </entry>
  
  <entry>
    <title>所谓测试新时代</title>
    <link href="http://tokyle.com/2019/05/27/%E6%89%80%E8%B0%93%E6%B5%8B%E8%AF%95%E6%96%B0%E6%97%B6%E4%BB%A3/"/>
    <id>http://tokyle.com/2019/05/27/所谓测试新时代/</id>
    <published>2019-05-27T08:57:56.000Z</published>
    <updated>2019-05-27T08:59:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>所谓测试新时代</p><a id="more"></a><h3 id="2019-软件测试"><a href="#2019-软件测试" class="headerlink" title="2019 软件测试"></a>2019 软件测试</h3><p>翻到了<code>World Quality Report 2018-19</code>看了好几项，也看了testerhome，软件质量报告等优秀公众号的文章，世界的确在变。</p><p>2019甚至之后很多年，国内的软件测试和质量保障人员的职责，已经不是单纯的找bug，现在我们需要做的，是客户满意度和业务成果的推动者。<br>刚入行时候，就一直挂在嘴边的一句话，软件测试，是要站在客户角度看问题，但是随着节奏越来越快，“涉世”越来越深，逐渐的，也就成了，找到个bug，提交各jira，结束，曾几何时，我们就迷失了自己；现在<code>World Quality Report 2018-19</code>再次提出了，<strong>客户满意度</strong>这个词，也是对我们已经迷茫的测试人员一个警醒。</p><h4 id="2019软件测试的趋势"><a href="#2019软件测试的趋势" class="headerlink" title="2019软件测试的趋势"></a>2019软件测试的趋势</h4><h5 id="AI在质量保障和测试中的作用"><a href="#AI在质量保障和测试中的作用" class="headerlink" title="AI在质量保障和测试中的作用"></a>AI在质量保障和测试中的作用</h5><p>随着过去一年甚至几年的AI大潮，AI技术在软件测试中越来越有应用市场，对于自动化的保障、对本身的AI产品的测试、使用AI进行质量预测等等，说实话，是个新技术，也是未来的一个趋势，但是目前该方案还没有那么的普及，很多公司，自身都没有响应的人工智能开发，所以，至少对我来说，是个值得参考的方向，但当前阶段，我不会去过多关注。</p><h5 id="敏捷以及devops"><a href="#敏捷以及devops" class="headerlink" title="敏捷以及devops"></a>敏捷以及devops</h5><p>这个，至少在我现在在的公司，是大谈特谈，从最高层开始，大力推行所谓敏捷开发，敏捷团队，说实话，一个小而优的团队，进行快速迭代对于产品来说，肯定是好的，同时配以devops，辅助CI\CD，全自动化回滚，测试等，可以想象，这样的团队，日常开发、测试、发布的效率有多高。但是实际上呢，从我现在公司的状况来看，一味的牺牲质量去追求速度，为了敏捷实施敏捷，到头来是留下了一堆祸根，客户生产问题接踵而至，整个产线疲于应付客户问题，无心关注新的功能点的设计，质量控制，继续往后，新的功能点进行快速迭代上线，缺乏有效的测试，更加增加了祸根数量，为后续的生产问题集中爆发写下了引言，整个，已经形成了恶性循环。</p><p>同时，敏捷团队和devops的转型，已经打乱了原来的QA团队，所有人分配到了不同的产线，这样使得跨项目的合作共享变成尤其困难。这点值得吐槽的更多，算了，不说了。</p><h5 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h5><p>这个已经不是新鲜事了，几乎所有公司都在追求自动化。也用现在的公司来举例子吧，当前实现的自动化</p><ol><li>产品重构多，自动化脚本几乎每次都会随着产品新迭代进行更新，没有一个可以适应多版本的自动化方案；</li><li>自动化测试环境以及自动化测试数据，准备异常繁琐，大多时间是消耗在环境排查及数据准备上；</li><li>自动化技术及理念不推陈出新，并没有思考过怎么样进行更高效的自动化覆盖，一味的沉溺于维护当前脚本；</li></ol><h5 id="测试环境和成本"><a href="#测试环境和成本" class="headerlink" title="测试环境和成本"></a>测试环境和成本</h5><p>关于测试环境和测试数据，很多公司做法不一样，但是同样的，对于测试来说，很多时候，问题是出现在测试环境上，很多时间是消耗在准备测试数据上，如何进行快速的测试环境部署，以及如何保障测试数据复用真的是衡量一个企业测试团队成熟度的一项指标。</p><h4 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h4><h5 id="以智能的、分阶段的方式提升基础自动化和智能测试自动化水平"><a href="#以智能的、分阶段的方式提升基础自动化和智能测试自动化水平" class="headerlink" title="以智能的、分阶段的方式提升基础自动化和智能测试自动化水平"></a>以智能的、分阶段的方式提升基础自动化和智能测试自动化水平</h5><p>未来，自动化肯定是测试的必备技能，团队的自动化测试水平，很直接的会影响到后续一系列开展，是真的可以决定团队是否能真正开展敏捷的关键。</p><p><code>World Quality Report 2018-19</code>给的建议如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 优化测试</span><br><span class="line">2，实施基础的自动化测试</span><br><span class="line">3，采用智能的、自适应的测试自动化方案让自动化变得更加“智能”</span><br></pre></td></tr></table></figure></p><h5 id="以非孤立的方式实施测试数据和测试环境的管理"><a href="#以非孤立的方式实施测试数据和测试环境的管理" class="headerlink" title="以非孤立的方式实施测试数据和测试环境的管理"></a>以非孤立的方式实施测试数据和测试环境的管理</h5><p>企业要开始生命周期的自动化，把测试自动化和数据、环境的准备工作一起开展，不要分离开来。另外，要采用更加智能的方式来管理测试环境和数据。</p><h5 id="构建超出测试开发（SDET）之外的质量工程技能"><a href="#构建超出测试开发（SDET）之外的质量工程技能" class="headerlink" title="构建超出测试开发（SDET）之外的质量工程技能"></a>构建超出测试开发（SDET）之外的质量工程技能</h5><p>这项，原谅才疏学浅，暂时get不到，抄录一下。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">敏捷、DevOps、云、IoT、区块链和AI这些新趋势的发展，以及更加自动的、集成的质量保障方法的需求，企业需要关注新的质量技能。</span><br><span class="line"></span><br><span class="line">推荐以下方式做好质量保障能力建设：</span><br><span class="line"></span><br><span class="line">1、第一优先级是吸引敏捷测试专家，需要具备功能自动化技能和领域测试技能，自动化测试将是每个质量保障人员的必备技能；</span><br><span class="line"></span><br><span class="line">2、第二优先级是吸引 SDET ，他们的必备技能要求有高级自动化测试、白盒测试、开发和平台构建能力，同时最好还有 AI 应用的基础算法应用能力和自然语言处理技能；</span><br><span class="line"></span><br><span class="line">3、第三优先级是吸引拥有一些特定 QA 技能集的人员，比如安全等非功能测试、测试环境和数据的管理技能等；</span><br><span class="line"></span><br><span class="line">4、第四优先级是吸引高级 QA 专家，需要有AI架构技能，以构建能够执行重复、智能任务的“智能资产”，这些技能由深度机器学习概念和算法组成，比如决策树、分类器、神经网络、高级统计学和数据优化技能。</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1，未来，我们需要更加关注客户满意度，追求速度，忽视客户满意度，迟早药丸；<br>2，低水平的自动化测试，测试数据及测试环境的管理已经影响到整个敏捷的实施；加强自动化培训，更加规范科学的进行测试数据及环境的管理，才能更好保障QA实施；<br>3，测试人员，需要更多的必备技能，来应对未来的挑战；这点上，个人还是坚持，测试人员需要明了并坚定自己的测试理念。以此为根基，进行测试技术的扩展，才是可行的路。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote><p><a href="https://mp.weixin.qq.com/s/voKNIhVOPLrjgQhDUhte9w" target="_blank" rel="noopener">2019 软件测试行业 5 大关键趋势与应对策略</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓测试新时代&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://tokyle.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="lives" scheme="http://tokyle.com/tags/lives/"/>
    
  </entry>
  
</feed>
