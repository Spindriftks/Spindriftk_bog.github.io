<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>它夏了夏天</title>
  
  <subtitle>生命中有一种遇见，就让它美如行云流水，然后一生去回味。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tokyle.com/"/>
  <updated>2019-05-16T01:37:09.277Z</updated>
  <id>http://tokyle.com/</id>
  
  <author>
    <name>Kyle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>几个linux命令小技巧</title>
    <link href="http://tokyle.com/2019/05/15/%E5%87%A0%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://tokyle.com/2019/05/15/几个linux命令小技巧/</id>
    <published>2019-05-16T01:36:27.000Z</published>
    <updated>2019-05-16T01:37:09.277Z</updated>
    
    <content type="html"><![CDATA[<p>一些Linux技巧型命令</p><a id="more"></a><p>可能不是太常用，算是可以提高效率的一点点方式，简单实践了一下。</p><h3 id="光标类"><a href="#光标类" class="headerlink" title="光标类"></a>光标类</h3><p>不同于vi/vim下的<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>上下左右移动，这边介绍的是普通模式下的光标移动。</p><h4 id="删除从行开头到光标处的命令"><a href="#删除从行开头到光标处的命令" class="headerlink" title="删除从行开头到光标处的命令"></a>删除从行开头到光标处的命令</h4><p><code>ctrl + u</code><br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /home/;ll光标处</span><br></pre></td></tr></table></figure></p><p>按下<code>ctrl+u</code>，会将<code>cd /home/;ll</code>该行删除</p><h4 id="删除从光标到结尾处的命令"><a href="#删除从光标到结尾处的命令" class="headerlink" title="删除从光标到结尾处的命令"></a>删除从光标到结尾处的命令</h4><p><code>ctrl + k</code><br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /home/;光标处ll</span><br></pre></td></tr></table></figure></p><p>按下<code>ctrl+k</code>，会将<code>ll</code>删除</p><h4 id="删除一个词（空格隔开的字符串）"><a href="#删除一个词（空格隔开的字符串）" class="headerlink" title="删除一个词（空格隔开的字符串）"></a>删除一个词（空格隔开的字符串）</h4><p><code>ctrl + w</code><br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -al光标处</span><br></pre></td></tr></table></figure></p><p>按下<code>ctrl w</code>，会将<code>-al</code>删除</p><h3 id="资源查看"><a href="#资源查看" class="headerlink" title="资源查看"></a>资源查看</h3><h4 id="各目录子目录占用空间大小"><a href="#各目录子目录占用空间大小" class="headerlink" title="各目录子目录占用空间大小"></a>各目录子目录占用空间大小</h4><p>tips: <strong>-h参数会将结果展示为人类可读的方式，所以结果会加上M、G这样的单位</strong></p><p>查看当前磁盘占用情况，这个都知道<code>df -h</code><br>查看目录各子目录占用空间大小，例如查看<code>/home</code>下各子目录空间大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# du -h --max-depth=1 /home/</span><br><span class="line">91M/home/ngrinder</span><br><span class="line">0/home/docker</span><br><span class="line">143M/home/</span><br></pre></td></tr></table></figure></p><p>查看内存情况：<code>free -h</code></p><h3 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h3><h4 id="获取pid"><a href="#获取pid" class="headerlink" title="获取pid"></a>获取pid</h4><p>很多时候，我们需要查看运行进行的PID，无论是进行分析还是杀进程。。以前的常用做法是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep zabbix_server</span><br></pre></td></tr></table></figure></p><p>这样，拿到<code>zabbix_server</code>这个进程的PID，同时会输出一堆信息，如果我们只想要一个pid，也有办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pgrep zabbix_server</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">pidof zabbix_server</span><br></pre></td></tr></table></figure></p><h4 id="杀进程"><a href="#杀进程" class="headerlink" title="杀进程"></a>杀进程</h4><p>之前杀进程，比较常用的就是<code>ps -ef|grep XX</code>拿到pid，然后kill掉，或者写的复杂点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 `ps -ef | grep zabbix | grep -v grep | awk &apos;&#123;print $2&#125;&apos;`</span><br></pre></td></tr></table></figure></p><p>现在有比较简单的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill zabbix</span><br></pre></td></tr></table></figure></p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="清空文件内容"><a href="#清空文件内容" class="headerlink" title="清空文件内容"></a>清空文件内容</h4><p>之前清空日志文件的内容，一直很头疼，文件太大根本进不去，sed和awk又没那么熟练，现在找到个比较快捷的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;zabbix_server.log</span><br></pre></td></tr></table></figure></p><p>完成清空<br>效果展示：<br>清空前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost zabbix]# ll</span><br><span class="line">total 108</span><br><span class="line">-rw-rw-r-- 1 zabbix zabbix 50071 May 16 08:55 zabbix_server.log</span><br></pre></td></tr></table></figure></p><p>清空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost zabbix]# &gt;zabbix_server.log</span><br><span class="line"></span><br><span class="line">[root@localhost zabbix]# ll</span><br><span class="line">total 56</span><br><span class="line">-rw-rw-r-- 1 zabbix zabbix     0 May 16 08:57 zabbix_server.log</span><br></pre></td></tr></table></figure></p><p>linux是个非常有意思的系统啊，有事没事多多研究<code>grep</code>、<code>sed</code>、<code>awk</code>以及<code>vi/vim</code>啊！</p><p>以上，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些Linux技巧型命令&lt;/p&gt;
    
    </summary>
    
      <category term="skill" scheme="http://tokyle.com/categories/skill/"/>
    
    
      <category term="linux" scheme="http://tokyle.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>centos7安装docker</title>
    <link href="http://tokyle.com/2019/05/14/centos7%E5%AE%89%E8%A3%85docker/"/>
    <id>http://tokyle.com/2019/05/14/centos7安装docker/</id>
    <published>2019-05-14T06:21:34.000Z</published>
    <updated>2019-05-14T06:33:02.734Z</updated>
    
    <content type="html"><![CDATA[<p>Centos7安装docker</p><a id="more"></a><p>容器化大潮，微服务最后一里路，至少掌握docker的基本使用</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>查看内核版本，大于3.10才能安装</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p><code>更新yum源</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><p><code>卸载旧版本</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker docker-common docker-selinux docker-engine -y</span><br></pre></td></tr></table></figure><p><code>安装需要的安装包</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p><code>配置yum源（防止万里长城，配置阿里yum源）</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><code>查看可选择版本</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p><code>安装最新稳定版（repo中默认开启了stable仓库）</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><p><code>或者指定版本</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce-18.06.3.ce</span><br></pre></td></tr></table></figure><p><code>启动并加自启动</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p><code>验证</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:           18.09.6</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.10.8</span><br><span class="line"> Git commit:        481bc77156</span><br><span class="line"> Built:             Sat May  4 02:34:58 2019</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.6</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.8</span><br><span class="line">  Git commit:       481bc77</span><br><span class="line">  Built:            Sat May  4 02:02:43 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br></pre></td></tr></table></figure></p><p>有client和server表示安装成功</p><p>本篇算是容器化的第一篇，计划后续好好折腾折腾docker和K8S，去年欠下的，要补回来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Centos7安装docker&lt;/p&gt;
    
    </summary>
    
      <category term="容器化" scheme="http://tokyle.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="Centos7" scheme="http://tokyle.com/tags/Centos7/"/>
    
      <category term="docker" scheme="http://tokyle.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>修改Linux时间</title>
    <link href="http://tokyle.com/2019/04/28/%E4%BF%AE%E6%94%B9Linux%E6%97%B6%E9%97%B4/"/>
    <id>http://tokyle.com/2019/04/28/修改Linux时间/</id>
    <published>2019-04-28T05:37:01.000Z</published>
    <updated>2019-04-28T05:38:51.544Z</updated>
    
    <content type="html"><![CDATA[<p>linux修改系统时间</p><a id="more"></a><h3 id="手动修改"><a href="#手动修改" class="headerlink" title="手动修改"></a>手动修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s 04/28/19</span><br></pre></td></tr></table></figure><p>修改日期为：2019/04/28</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s 11:28:00</span><br></pre></td></tr></table></figure><p>修改时间为11:28:00</p><p>或者一次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s &quot;2019-04-28 11:28:00&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock -w</span><br></pre></td></tr></table></figure><p>将时间写入bios避免重启失效</p><h3 id="同步网络时间"><a href="#同步网络时间" class="headerlink" title="同步网络时间"></a>同步网络时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ntp</span><br></pre></td></tr></table></figure><p>ntp常用服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">中国国家授时中心：210.72.145.44</span><br><span class="line">NTP服务器(上海) ：ntp.api.bz</span><br><span class="line">美国：time.nist.gov </span><br><span class="line">复旦：ntp.fudan.edu.cn </span><br><span class="line">微软公司授时主机(美国) ：time.windows.com </span><br><span class="line">台警大授时中心(台湾)：asia.pool.ntp.org</span><br></pre></td></tr></table></figure></p><h4 id="同步时间："><a href="#同步时间：" class="headerlink" title="同步时间："></a>同步时间：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate -dv ntp.api.bz</span><br></pre></td></tr></table></figure><p>同步完成之后，发现时间有点不对，12h误差<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# date</span><br><span class="line">Sun Apr 28 01:20:14 EDT 2019</span><br></pre></td></tr></table></figure></p><p>查了下，<code>EDT</code>是美国东部时间，需要改成北京时间</p><h3 id="时区修改"><a href="#时区修改" class="headerlink" title="时区修改"></a>时区修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/localtime /etc/localtime.bak </span><br><span class="line"></span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime </span><br><span class="line"></span><br><span class="line">date</span><br></pre></td></tr></table></figure><p>完成~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux修改系统时间&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://tokyle.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux" scheme="http://tokyle.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter调用python完成HmacSHA256加密处理</title>
    <link href="http://tokyle.com/2019/04/23/Jmeter%E8%B0%83%E7%94%A8python%E5%AE%8C%E6%88%90HmacSHA256%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86/"/>
    <id>http://tokyle.com/2019/04/23/Jmeter调用python完成HmacSHA256加密处理/</id>
    <published>2019-04-23T07:18:16.000Z</published>
    <updated>2019-04-23T07:24:22.404Z</updated>
    
    <content type="html"><![CDATA[<p>Jmeter调用python完成HmacSHA256加密处理</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>同事有个需求，一个获取人员信息的接口，请求头里面需要有一个<code>sign</code>参数，这个参数是几个实时获取的参数最后进行Hmachash256加密之后生成的，具体示例：<br>获取用户接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://192.168.0.1/api/user?userName=20190101&amp;tenant=testtenant</span><br></pre></td></tr></table></figure></p><p>请求头：</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>Authorization</td><td>Bearer ${token}</td></tr><tr><td>content-type</td><td>application/json</td></tr><tr><td>tenant</td><td>testtenant</td></tr><tr><td>timestamp</td><td>当前时间戳</td></tr><tr><td>randoms</td><td>随机数</td></tr><tr><td>sign</td><td>签名</td></tr></tbody></table><p>其中签名生成规则如下：<br><code>tenanttesttenantuserName20190101tenanttesttenanttimestamp当前时间戳randoms随机数</code><br>这一长串再使用指定密码，进行<strong>HmacSHA256</strong>加密，生成的密文即为<code>sign</code></p><blockquote><p><a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">加密工具</a></p></blockquote><h3 id="jmeter方案"><a href="#jmeter方案" class="headerlink" title="jmeter方案"></a>jmeter方案</h3><p>因为后期接口要进行性能测试，所以还是选了jmeter进行性能测试，按照接口描述的先排序再加密，在jmeter中，首先想到的就是通过<code>beanshell</code>外部实现，然后生成对应jar包，在jmeter中引用，然后就有个问题，我java太菜了。。。没办法，折腾python。</p><h4 id="jmeter中使用python脚本"><a href="#jmeter中使用python脚本" class="headerlink" title="jmeter中使用python脚本"></a>jmeter中使用python脚本</h4><p>在jmeter中使用python脚本，搜了下，找到三种方式：<br><strong>1</strong>. 使用Jython包 </p><blockquote><p><a href="https://www.jython.org/downloads.html" target="_blank" rel="noopener">下载地址</a><br>下载 <code>Download Jython 2.7.0 - Standalone Jar</code> 包，放到jmeter/lib/目录下，重启jmeter，就能在<code>sampler</code>中找到<code>JSR223 Sampler</code>，里面就有python，但是，是python2.7，所以，对我没啥用</p></blockquote><p><strong>2</strong>. jmeter-functions-execute-python-script-1.0.jar，网上有个这个包，可以从函数助手那边进去执行python脚本，试了下失败了，就不介绍了，有兴趣可以百度下咋弄</p><p><strong>3</strong>. <strong>OS Process Sampler</strong>，使用这个组件可以执行脚本，后面着重介绍这个，使用了下，很强的组件，理论上，只要你脚本能力强，可以获得各种想要的（终于看到摆脱java的希望了。。）</p><h4 id="OS-Process-Sampler"><a href="#OS-Process-Sampler" class="headerlink" title="OS Process Sampler"></a>OS Process Sampler</h4><p>这个组件可以用来启动一个可执行程序，由于是通过命令行方式启动，所以我们可以用任何语言编写一个测试用的可执行程序(比如Linux的sh脚本)。在该可执行程序中调用我们的接口，并把返回的原始数据输出而交由JMeter做后续解析判断。</p><p>位置：<code>/sampler/OS Process Sampler</code><br>这个组件有几栏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command: 可执行文件（windows系统建议放.bat脚本或exe文件，linux系统放shell；干过windows下放了shell直接报非可执行文件。。）</span><br><span class="line"></span><br><span class="line">working directory：工作目录，默认是jmeterbin 目录，可指定</span><br><span class="line">command parameters：参数，如果脚本需要传参，可在这边传</span><br></pre></td></tr></table></figure></p><p>既然这个组件可以执行bat文件，那我们在bat文件里面再调python文件不就实现了嘛~</p><h3 id="加密实现"><a href="#加密实现" class="headerlink" title="加密实现"></a>加密实现</h3><p>前面说了，思路就是使用<code>OS Process Sampler</code>来调用<code>.bat</code>文件，然后在<code>.bat</code>文件中再调python文件，实现加密，脚本如下：</p><h4 id="jmeter"><a href="#jmeter" class="headerlink" title="jmeter"></a>jmeter</h4><p>OS Process Sampler中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command: oss.bat路径</span><br><span class="line"></span><br><span class="line">working directory：默认</span><br><span class="line">command parameters：secret，userName，tenant（三个传参，方便参数化）</span><br></pre></td></tr></table></figure></p><p>同时，在<code>OS Process Sampler</code>后追加三个正则表达式提取器，分别获取<strong>时间戳</strong>，<strong>随机数</strong>，<strong>签名</strong></p><p>正则表达式提取器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">引用名称：sign</span><br><span class="line">正则表达式：sign:(.+?)&lt;&gt;</span><br><span class="line">模板：$1$</span><br><span class="line">匹配数字: 1</span><br></pre></td></tr></table></figure></p><p>时间戳和随机数相同方式获取</p><h4 id="oss-bat"><a href="#oss-bat" class="headerlink" title="oss.bat"></a>oss.bat</h4><p>oss.bat:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set secret = %1</span><br><span class="line">set userName = %2</span><br><span class="line">set tenant = %3</span><br><span class="line"></span><br><span class="line">python  E:\py_workspace\hashtest\JmeterSSTest.py  %*</span><br></pre></td></tr></table></figure></p><p>Windows批处理文件，首先获取传进去的三个参数，再将这三个参数作为入参传给python脚本</p><h4 id="JmeterSSTest-py"><a href="#JmeterSSTest-py" class="headerlink" title="JmeterSSTest.py"></a>JmeterSSTest.py</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*-coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: kyle</span><br><span class="line">@time: 2019/4/23 12:44</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import hashlib</span><br><span class="line">import hmac</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># 定义传参，按顺序，secret,userName,tenant</span><br><span class="line">secret = sys.argv[1]</span><br><span class="line">userName = sys.argv[2]</span><br><span class="line">tenant = sys.argv[3]</span><br><span class="line"></span><br><span class="line"># 获取当前时间戳</span><br><span class="line">timestamp = int(time.time())</span><br><span class="line"></span><br><span class="line"># 获取随机数</span><br><span class="line">randoms = random.randint(0, 999999999)</span><br><span class="line"></span><br><span class="line"># 获取sign</span><br><span class="line">strsign = str(u&apos;tenant&apos; + str(tenant) + u&apos;userName&apos; + str(userName) + u&apos;tenant&apos; + str(tenant) +</span><br><span class="line">               u&apos;timestamp&apos; + str(timestamp) + u&apos;randoms&apos; + str(randoms))</span><br><span class="line"></span><br><span class="line"># hmacsha256加密</span><br><span class="line">intsign = hmac.new(bytes(str(secret), encoding=&apos;utf-8&apos;), bytes(str(strsign), encoding=&apos;utf-8&apos;),</span><br><span class="line">                    digestmod=hashlib.sha256).digest()</span><br><span class="line"></span><br><span class="line"># 二进制转义</span><br><span class="line">sign = intsign.hex()</span><br><span class="line"></span><br><span class="line">print(u&apos;timestamp&apos; + &apos;:&apos; + str(timestamp) + &apos;&lt;&gt;&apos;)</span><br><span class="line">print(u&apos;randoms&apos; + &apos;:&apos; + str(randoms) + &apos;&lt;&gt;&apos;)</span><br><span class="line">print(u&apos;sign&apos; + &apos;:&apos; + str(sign) + &apos;&lt;&gt;&apos;)</span><br></pre></td></tr></table></figure><p>脚本就不解释了，不难</p><h3 id="完整jmeter结构"><a href="#完整jmeter结构" class="headerlink" title="完整jmeter结构"></a>完整jmeter结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 获取token接口（简单控制器）</span><br><span class="line">-- http信息头管理器</span><br><span class="line">    -- http请求</span><br><span class="line">    -- 响应断言</span><br><span class="line">    --查看结果树</span><br><span class="line">    -- JSON Extractor</span><br><span class="line">-- 加密sign</span><br><span class="line">   -- OS Process Sampler</span><br><span class="line">     -- 正则提取 timestamp</span><br><span class="line">     -- 正则提取 randoms</span><br><span class="line">     -- 正则提取 sign</span><br><span class="line">-- 获取用户接口</span><br><span class="line">   -- http信息头管理器</span><br><span class="line">   -- http请求</span><br><span class="line">   -- 查看结果树</span><br><span class="line">   -- 响应断言</span><br></pre></td></tr></table></figure><p>以上，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jmeter调用python完成HmacSHA256加密处理&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="jmeter" scheme="http://tokyle.com/tags/jmeter/"/>
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
      <category term="HmacSHA256" scheme="http://tokyle.com/tags/HmacSHA256/"/>
    
  </entry>
  
  <entry>
    <title>Android性能测试——内存</title>
    <link href="http://tokyle.com/2019/04/18/Android%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/"/>
    <id>http://tokyle.com/2019/04/18/Android性能测试——内存/</id>
    <published>2019-04-18T09:06:22.000Z</published>
    <updated>2019-04-18T09:08:11.718Z</updated>
    
    <content type="html"><![CDATA[<p>Android性能测试——内存</p><a id="more"></a><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>通常情况下我们说的内存都是指手机的RAM，RAM主要包括：</p><ul><li>寄存器：速度最快的存储</li><li>栈（stack）：在jvm中栈用来存储一些对象的引用、局部变量以及计算过程的中间数据，在方法退出后那么这些变量也会被销毁。它的存储比堆快得多，只比CPU里的寄存器慢</li><li>堆（Heap）：用来存储程序中的一些对象，比如你用new关键字创建的对象，它就会被存储在堆内存中，但是这个对象在堆内存中的首地址会存储在栈中；堆中分配的内存，由java虚拟机自动垃圾回收器（GC）来管理。<br>关于GC的，记得之前稍微记过点<a href="http://tokyle.com/%2F2018%2F11%2F02%2FJVM%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%2F">JVM内存性能问题定位</a></li><li>… …</li></ul><h3 id="Dalvik和JVM"><a href="#Dalvik和JVM" class="headerlink" title="Dalvik和JVM"></a>Dalvik和JVM</h3><p>Davlik虚拟机（DVM）是Android系统在java虚拟机（JVM）基础上优化得到的，DVM是基于寄存器的，而JVM是基于栈的，由于寄存器更高效，DVM性能相比JVM要好一点。</p><h3 id="Android中进程的堆内存"><a href="#Android中进程的堆内存" class="headerlink" title="Android中进程的堆内存"></a>Android中进程的堆内存</h3><p>RAM作为进程运行不可或缺的资源，对Android系统性能和稳定性有着决定性影响，RAM的一部分被操作系统留作他用，比如显存等等，当然这个程序员无法干预，我们也不必过多地关注它。进程空间中的heap空间是我们需要重点关注的。heap空间完全由程序员控制，我们使用的C++ new和java new所申请的空间都是heap空间， C/C++申请的内存空间在native heap中，而java申请的内存空间则在dalvik heap中。</p><h3 id="Android的java程序为什么容易OOM"><a href="#Android的java程序为什么容易OOM" class="headerlink" title="Android的java程序为什么容易OOM"></a>Android的java程序为什么容易OOM</h3><p>这个是因为Android系统对dalvik的vmheapsize作了硬性限制，当java进程申请的java空间超过阈值时，就会抛出OOM异常（这个阈值可以是48M、24M、16M等，视机型而定），可以通过adb shell getprop | grep dalvik.vm.heapgrowthlimit查看此值。也就是说，程序发生OMM并不表示RAM不足，而是因为程序申请的java heap对象超过了dalvik vmheapgrowthlimit。也就是说，在RAM充足的情况下，也可能发生OOM。</p><p>这样的设计似乎有些不合理，但是Google为什么这样做呢？这样设计的目的是为了让Android系统能同时让比较多的进程常驻内存，这样程序启动时就不用每次都重新加载到内存，能够给用户更快的响应。迫使每个应用程序使用较小的内存，移动设备非常有限的RAM就能使比较多的app常驻其中。但是有一些大型应用程序是无法忍受vmheapgrowthlimit的限制的</p><p>实际上<code>dalvik.vm.heapgrowthlimit</code>和<code>dalvik.vm.heapsize</code>都是java虚拟机的最大内存限制，应用如果不想在dalvikheap达到heapgrowthlimit限制的时候出现OOM，需要在Manifest中的application标签中声明<code>android:largeHeap=“true”</code>，声明后应用dalvik heap达到heapsize的时候才会出现OOM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; adb shell getprop | grep dalvik.vm.heapgrowthlimit</span><br><span class="line">[dalvik.vm.heapgrowthlimit]: [192m]</span><br><span class="line"></span><br><span class="line">&#123;lamb&#125; adb shell getprop | grep dalvik.vm.heapsize</span><br><span class="line">[dalvik.vm.heapsize]: [512m]</span><br></pre></td></tr></table></figure><h3 id="Android内存采集"><a href="#Android内存采集" class="headerlink" title="Android内存采集"></a>Android内存采集</h3><p><strong>dumpsys</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; adb shell dumpsys meminfo com.kuaikan.comic                                                                 </span><br><span class="line">Applications Memory Usage (in Kilobytes):                                                                          </span><br><span class="line">Uptime: 467997959 Realtime: 2137774428                                                                             </span><br><span class="line">** MEMINFO in pid 15956 [com.kuaikan.comic] **                                                                     </span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap                                       </span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free                                       </span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------                                       </span><br><span class="line">  Native Heap    98778    98668       64      406   127872   120081     7790                                       </span><br><span class="line">  Dalvik Heap     8247     8204       24       52    20111     7823    12288                                       </span><br><span class="line"> Dalvik Other     2505     2496        4        2                                                                  </span><br><span class="line">        Stack     2464     2464        0        0  </span><br><span class="line">       Ashmem      258      256        0        0   </span><br><span class="line">      Gfx dev    24048    23372      676        0  </span><br><span class="line">    Other dev       45        8       28        0  </span><br><span class="line">     .so mmap     4157     2036      716       26  </span><br><span class="line">    .jar mmap        8        8        0        0  </span><br><span class="line">    .apk mmap     9900     9676      160        0  </span><br><span class="line">    .dex mmap    20863    17524     2380        0  </span><br><span class="line">    .oat mmap     2731        0      384        0  </span><br><span class="line">    .art mmap     8290     6736      148       12   </span><br><span class="line">   Other mmap       29        4        0        0                                                                  </span><br><span class="line">   EGL mtrack    38636    38636        0        0                                                                  </span><br><span class="line">    GL mtrack     5480     5480        0        0   </span><br><span class="line">      Unknown     6031     6016        0        3  </span><br><span class="line">        TOTAL   232971   221584     4584      501   147983   127904    20078  </span><br><span class="line"> App Summary                                                                                                       </span><br><span class="line">                       Pss(KB)   </span><br><span class="line">                        ------    </span><br><span class="line">           Java Heap:    15088   </span><br><span class="line">         Native Heap:    98668    </span><br><span class="line">                Code:    32884   </span><br><span class="line">               Stack:     2464    </span><br><span class="line">            Graphics:    68164   </span><br><span class="line">       Private Other:     8900   </span><br><span class="line">              System:     6803     </span><br><span class="line">               TOTAL:   232971       TOTAL SWAP PSS:      501   </span><br><span class="line"> Objects                                                                                                           </span><br><span class="line">               Views:      927         ViewRootImpl:        2  </span><br><span class="line">         AppContexts:       11           Activities:        1   </span><br><span class="line">              Assets:        8        AssetManagers:        5    </span><br><span class="line">       Local Binders:       89        Proxy Binders:       42    </span><br><span class="line">       Parcel memory:       56         Parcel count:      226   </span><br><span class="line">    Death Recipients:        5      OpenSSL Sockets:       10  </span><br><span class="line">            WebViews:        0       </span><br><span class="line"> SQL                                                                                                               </span><br><span class="line">         MEMORY_USED:     3886    </span><br><span class="line">  PAGECACHE_OVERFLOW:     1026          MALLOC_SIZE:      309</span><br><span class="line"> DATABASES                                                                                                      </span><br><span class="line">      pgsz     dbsz   Lookaside(b)          cache  Dbname </span><br><span class="line">         4       52            109       54/31/17  /data/user/0/com.kuaikan.comic/databases/bugly_db_    </span><br><span class="line">         4      100             76        83/57/9  /data/user/0/com.kuaikan.comic/databases/kkmh-room.db      </span><br><span class="line">         4       12                         0/0/0    (attached) temp   </span><br><span class="line">         4      100            109      147/26/14  /data/user/0/com.kuaikan.comic/databases/kkmh-room.db (1)       </span><br><span class="line">         4       20             24         1/16/2  /data/user/0/com.kuaikan.comic/databases/ThrowalbeLog.db        </span><br><span class="line">         4      564             88       52/43/25  /data/user/0/com.kuaikan.comic/databases/kkmh.db    </span><br><span class="line">         4       20            109      185/24/10  /data/user/0/com.kuaikan.comic/databases/btechainh.db           </span><br><span class="line">         4       20             45         6/19/5  /data/user/0/com.kuaikan.comic/databases/sharesdk.db            </span><br><span class="line">         4       20             52        23/24/6  /data/user/0/com.kuaikan.comic/databases/aa_in_techain.db       </span><br><span class="line">         4       36             92      106/41/25  /data/user/0/com.kuaikan.comic/databases/techain_d.db           </span><br><span class="line">         4       52             47         2/17/3  /data/user/0/com.kuaikan.comic/databases/volcano_ac_techain.db  </span><br><span class="line">         4       20             29         1/16/2  /data/user/0/com.kuaikan.comic/databases/tracker.db   </span><br><span class="line">         4       60             97         3/21/5  /data/user/0/com.kuaikan.comic/databases/tes_db     </span><br><span class="line">         4       16             52        12/17/5  /storage/emulated/0/Mob/comm/dbs/.dh </span><br><span class="line">         4       20             65        16/19/5  /data/user/0/com.kuaikan.comic/databases/x24_techain_typhoon.db </span><br><span class="line">         4       76             38        54/17/3  /data/user/0/com.kuaikan.comic/databases/com.kuaikan.comic      </span><br><span class="line">         4       28             50         5/18/4  /data/user/0/com.kuaikan.comic/databases/tcyrtsdb.db            </span><br><span class="line">         4       44             80        10/21/7  /data/user/0/com.kuaikan.comic/databases/beacon_tbs_db   </span><br><span class="line">         4       20             26         1/16/2  /data/user/0/com.kuaikan.comic/databases/kk-push </span><br><span class="line"> Asset Allocations                                                                            </span><br><span class="line">    zip:/data/user/0/com.tencent.mm/app_tbs/core_share/res.apk:/resources.arsc: 97K</span><br></pre></td></tr></table></figure><h4 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h4><ul><li><p>私有内存(Dirty and Clean)<br>进程独占内存。也就是进程销毁时可以回收的内存容量。通常private Dirty内存是最重要的部分，因为只被自己进程使用。Dirty内存是已经被修改的内存页，因此必须常驻内存（因为没有swap）；Clean内存是已经映射持久文件使用的内存页（例如正在被执行的代码），因此一段时间不使用的话就可以置换出去。</p></li><li><p>实际使用内存(PSS)<br>将跨进程共享页也加入进来， 进行按比例计算PSS。这样能够比较准确的表示<strong>进程占用的实际物理内存</strong></p></li><li><p>Native Heap Alloc<br>JNI层的内存分配</p></li><li><p>Dalvik Heap Alloc<br>Java层的内存分配</p></li></ul><p>这两个值一直增长，应用程序可能出现了内存泄漏</p><h3 id="测试Android内存"><a href="#测试Android内存" class="headerlink" title="测试Android内存"></a>测试Android内存</h3><p><strong>1.</strong> monkey压力测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p com.kuaikan.comic --ignore-crashes --ignore-timeouts --ignore-security-exceptions  --ignore-native-crashes --pct-touch 70 --pct-motion 25 --pct-majornav 5 -v -v -v --throttle 300 100000</span><br></pre></td></tr></table></figure><p><strong>2.</strong> adb shell dumpsys meminfo监控内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.kuaikan.comic</span><br></pre></td></tr></table></figure><p>如发现内存过大，保存<strong>HPROF文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am dumpheap com.kuaikan.comic /data/local/tmp/1.hprof</span><br></pre></td></tr></table></figure></p><p><strong>3.</strong> 格式化<br><code>D:\dev\android\android-sdk-windows\platform-tools</code>下有个<strong>hprof-conv.exe</strong>工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hprof-conv 1.hprof 2.hprof</span><br></pre></td></tr></table></figure></p><p><strong>4.</strong> 用MAT分析<br><a href="https://pan.baidu.com/s/1mF70g1IyS8wYIuXaNx7vaQ" target="_blank" rel="noopener">MAT度娘盘地址（提取码：jidc）</a></p><h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><h4 id="Android沙盒"><a href="#Android沙盒" class="headerlink" title="Android沙盒"></a>Android沙盒</h4><p>由于Android是建立在Linux系统之上的，所以Android系统继承了Linux的 类Unix继承进程隔离机制与最小权限原则，并且在原有Linux的进程管理基础上对UID的使用做了改进，形成了Android应用的”沙箱“机制。</p><p>普通的Linux中启动的应用通常和登陆用户相关联，同一用户的UID相同。但是Android中给不同的应用都赋予了不同的UID，这样不同的应用将不能相互访问资源。对应用而言，这样会更加封闭，安全。</p><p>在Android系统中，应用（通常）都在一个独立的沙箱中运行，即每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。Dalvik经过优化，允许在有限的内存中同时高效地运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行。Android这种基于Linux的进程“沙箱”机制，是整个安全设计的基础之一。</p><p>简单点说就是在Android的世界中每一个应用相当与一个Linux中的用户，他们相互独立，不能相互共享与访问，（这也就解释了Android系统中为什么需要进程间通信），正是由于沙盒机制的存在最大程度的保护了应用之间的安全，但是也带来了每一个应用所分配的内存大小是有限制的问题。</p><h4 id="获取当前页面activity"><a href="#获取当前页面activity" class="headerlink" title="获取当前页面activity"></a>获取当前页面activity</h4><p>通过<code>adb shell dumpsys window |findstr mCurrent</code>，捕获当前页面的activity<br>通过<code>adb shell dumpsys activity|findstr &quot;realActivity&quot;</code>, 捕获到当前页面的activity</p><h4 id="频繁GC的可能原因"><a href="#频繁GC的可能原因" class="headerlink" title="频繁GC的可能原因"></a>频繁GC的可能原因</h4><ol><li><p>Memory Churn（内存抖动），内存抖动是因为大量的对象被创建又在短时间内马上被释放</p></li><li><p>瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加 Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。</p></li></ol><h3 id="优秀Android博客"><a href="#优秀Android博客" class="headerlink" title="优秀Android博客"></a>优秀Android博客</h3><blockquote><p><a href="https://www.jianshu.com/p/2bceb820b435?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">Android性能优化-详解内存优化来龙去脉</a><br><a href="https://www.jianshu.com/p/0df5ad0d2e6a" target="_blank" rel="noopener">Android性能优化&amp;内存篇</a><br><a href="https://blog.csdn.net/carson_ho/article/details/79549417" target="_blank" rel="noopener">一份详细&amp;全面内存优化指南</a></p></blockquote><p>以上，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android性能测试——内存&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Android" scheme="http://tokyle.com/tags/Android/"/>
    
      <category term="adb" scheme="http://tokyle.com/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>记一次Linux磁盘清理</title>
    <link href="http://tokyle.com/2019/04/18/%E8%AE%B0%E4%B8%80%E6%AC%A1Linux%E7%A3%81%E7%9B%98%E6%B8%85%E7%90%86/"/>
    <id>http://tokyle.com/2019/04/18/记一次Linux磁盘清理/</id>
    <published>2019-04-18T07:20:41.000Z</published>
    <updated>2019-04-18T07:21:57.142Z</updated>
    
    <content type="html"><![CDATA[<p>记一次Linux清磁盘</p><a id="more"></a><p>最近发现有台机器磁盘满了，搜了下，nohub.out占完了</p><p>然后果断的rm -rf nohub.out，以为结束了，然而df -h看了下，一点都没释放。。。</p><p>因为被删除的文件在删除的时侯还是进程在操作(打开、访问等)的缘故，rm只完成了在磁盘上文件实体的释放，而类似free list结构中相应的文件系统因进程的操作相应的inode并未释放。</p><p>解决的方法：<br>这样的问题解决起来也很简单，找到操作的进程，kill掉就可以了</p><p>当然，闲得无聊，你重启机器，也没话说<br>(最后，别忘了重启你的程序)</p><p>在网上发现两个可以不用停止服务就可清空nohup.out的命令。<br>第一种：cp /dev/null nohup.out<br>第二种：cat /dev/null &gt; nohup.out</p><p>以上，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记一次Linux清磁盘&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://tokyle.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux" scheme="http://tokyle.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>centos7搭建testlink</title>
    <link href="http://tokyle.com/2019/04/16/centos7%E6%90%AD%E5%BB%BAtestlink/"/>
    <id>http://tokyle.com/2019/04/16/centos7搭建testlink/</id>
    <published>2019-04-17T01:51:39.000Z</published>
    <updated>2019-04-17T01:53:08.517Z</updated>
    
    <content type="html"><![CDATA[<p>centos 7搭建testlink</p><p>帮忙搭建了个testlink，说实话，不习惯用这个</p><a id="more"></a><h3 id="系统版本"><a href="#系统版本" class="headerlink" title="系统版本"></a>系统版本</h3><p>搭建版本<br><code>testlink</code>: 1.9.19<br><code>MySQL</code>：5.7.25 （mysql -V）<br><code>PHP</code>：5.6 (php -v)<br><code>Linux</code>：Centos 7.6.1810 (Core) （cat /etc/redhat-release）</p><h3 id="前置操作"><a href="#前置操作" class="headerlink" title="前置操作"></a>前置操作</h3><p>升级yum：<code>yum update</code></p><p>关闭防火墙：<code>systemctl  stop   firewalld.service</code><br>防火墙禁止自启动：<code>systemctl   disable   firewalld.service</code></p><p>关闭selinux：<code>sudo sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config</code></p><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>下载源包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>安装MySQL源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>检查可选包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist enabled | grep &quot;mysql.*-community.*&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql-connectors-community/x86_64 MySQL Connectors Community                  51</span><br><span class="line">mysql-tools-community/x86_64      MySQL Tools Community                       63</span><br><span class="line">mysql57-community/x86_64          MySQL 5.7 Community Server                 267</span><br></pre></td></tr></table></figure><p>可修改配置：<code>/etc/yum.repos.d/mysql-community.repo</code>选择想要安装的版本，将对应<code>enable</code>改为<strong>1</strong></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-community-server</span><br></pre></td></tr></table></figure><p>启动服务：<code>systemctl start mysqld</code><br>查看服务状态：<code>systemctl status mysqld</code></p><p>配置开机启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></p><h4 id="安装后配置"><a href="#安装后配置" class="headerlink" title="安装后配置"></a>安装后配置</h4><h5 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h5><p>查看原始密码：<code>grep &#39;temporary password&#39; /var/log/mysqld.log</code></p><p>进入控制台<code>mysql -uroot -p</code>，修改密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;yourpwd&apos;;</span><br></pre></td></tr></table></figure></p><p>修改权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;yourpwd&apos; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure></p><h4 id="创建testlink库"><a href="#创建testlink库" class="headerlink" title="创建testlink库"></a>创建testlink库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE testlink;</span><br><span class="line"></span><br><span class="line">CREATE USER ‘testlinkuser‘@‘localhost‘ IDENTIFIED BY ‘yourpwd‘;</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES ON testlink.* TO ‘testlinkuser‘@‘localhost‘ IDENTIFIED BY ‘yourpwd‘ WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line">EXIT;</span><br></pre></td></tr></table></figure><h3 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd</span><br></pre></td></tr></table></figure><p>配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i ‘s/^/#&amp;/g‘ /etc/httpd/conf.d/welcome.conf</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/Options Indexes FollowSymLinks/Options FollowSymLinks/&quot; /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure></p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start httpd.service</span><br><span class="line"></span><br><span class="line">systemctl enable httpd.service</span><br></pre></td></tr></table></figure></p><h3 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a>安装php</h3><p>直接用yum install php安装的，默认是5.4版本，然而testlink要求至少是<strong>5.5</strong>（这点坑的我，zabbix直接不能和它装一台机器）</p><p>配置yum源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line"></span><br><span class="line">rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</span><br></pre></td></tr></table></figure></p><p>安装<strong>php5.6</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install php56 php56-php php56-php-mysqlnd php56-php-gd php56-php-mcrypt php56-php-mbstring php56-php-xml php56-php-cli php56-php-ldap</span><br></pre></td></tr></table></figure><p>修改参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/session.gc_maxlifetime = 1440/session.gc_maxlifetime = 2880/&quot; /opt/remi/php56/root/etc/php.ini</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/max_execution_time = 30/max_execution_time = 120/&quot; /opt/remi/php56/root/etc/php.ini</span><br></pre></td></tr></table></figure></p><h3 id="安装testlink"><a href="#安装testlink" class="headerlink" title="安装testlink"></a>安装testlink</h3><blockquote><p><a href="https://sourceforge.net/projects/testlink/files/" target="_blank" rel="noopener">官网下载地址</a></p></blockquote><p>下载完成后传到linux下（rz…），解压缩到<code>/var/www/html</code>目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf testlink-1.9.19.tar.gz -C /var/www/html</span><br></pre></td></tr></table></figure></p><p>重命名：<code>mv testlink-1.9.19 testlink</code></p><p>创建<strong>upload_area</strong>：<code>mkdir /var/www/html/upload_area</code></p><p>修改项目属主以及日志文件权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown -R apache:apache /var/www/html/testlink</span><br><span class="line"></span><br><span class="line">chmod -R 755 /var/www/html/testlink/logs</span><br></pre></td></tr></table></figure></p><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><p>首先是创建（直接把示例文件备份重命名）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /var/www/html/testlink/custom_config.inc.php.example/var/www/html/testlink/custom_config.inc.php</span><br></pre></td></tr></table></figure></p><p>修改配置(日志路径等)可直接vim进入之后查找<code>?log_path</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// $tlCfg-&gt;log_path = ‘/var/testlink-ga-testlink-code/logs/‘; /* unix example */</span><br><span class="line">// $g_repositoryPath = ‘/var/testlink-ga-testlink-code/upload_area/‘;  /* unix example */</span><br><span class="line"></span><br><span class="line">$tlCfg-&gt;log_path = ‘/var/www/html/testlink/logs/‘;</span><br><span class="line">$g_repositoryPath = ‘/var/www/html/testlink/upload_area/‘;</span><br><span class="line">$tlCfg-&gt;config_check_warning_mode = ‘SILENT‘;</span><br></pre></td></tr></table></figure></p><p>重启Apache<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart httpd.service</span><br></pre></td></tr></table></figure></p><h3 id="启动testlink"><a href="#启动testlink" class="headerlink" title="启动testlink"></a>启动testlink</h3><p>浏览器输入<code>http://IP/testlink</code><br>进入安装页面，依次<code>new installation</code>-&gt;<code>agree license</code>-&gt;<code>continue</code>开始一堆校验，继续<code>continue</code>，进入数据库配置页面，依次填写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Database name：testlink（testlink库名）</span><br><span class="line"></span><br><span class="line">Database admin login：root</span><br><span class="line">Database admin password：yourpwd（你MySQL的root密码）</span><br><span class="line"></span><br><span class="line">Testlink DB login：testlinkuser（testlink数据库用户名）</span><br><span class="line">Testlink DB password：yourpwd（你testlink库密码）</span><br></pre></td></tr></table></figure></p><p>填写完成，点击<code>Process Testlink Setup</code><br>结束！</p><h3 id="登录testlink"><a href="#登录testlink" class="headerlink" title="登录testlink"></a>登录testlink</h3><p><code>http://IP/testlink</code><br>默认账密：<code>admin/admin</code></p><p>以上，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;centos 7搭建testlink&lt;/p&gt;
&lt;p&gt;帮忙搭建了个testlink，说实话，不习惯用这个&lt;/p&gt;
    
    </summary>
    
      <category term="Devops" scheme="http://tokyle.com/categories/Devops/"/>
    
    
      <category term="Centos7" scheme="http://tokyle.com/tags/Centos7/"/>
    
      <category term="testlink" scheme="http://tokyle.com/tags/testlink/"/>
    
  </entry>
  
  <entry>
    <title>adb进阶四 —— dumpsys</title>
    <link href="http://tokyle.com/2019/04/12/adb%E8%BF%9B%E9%98%B6%E5%9B%9B-%E2%80%94%E2%80%94-dumpsys/"/>
    <id>http://tokyle.com/2019/04/12/adb进阶四-——-dumpsys/</id>
    <published>2019-04-12T09:21:17.000Z</published>
    <updated>2019-04-12T09:22:15.881Z</updated>
    
    <content type="html"><![CDATA[<p>adb进阶四 —— dumpsys</p><a id="more"></a><h3 id="dumpsys简介"><a href="#dumpsys简介" class="headerlink" title="dumpsys简介"></a>dumpsys简介</h3><p>Dumpsys用于系统诊断，并提供系统服务状态信息,命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys [system serbices]</span><br></pre></td></tr></table></figure></p><h4 id="系统服务查询"><a href="#系统服务查询" class="headerlink" title="系统服务查询"></a>系统服务查询</h4><p>直接运行<code>adb shell dumpsys</code>会输出很多很多信息，可以指定需要检查的服务</p><p>查看系统服务、：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell service list</span><br><span class="line">或者</span><br><span class="line">adb shell dumpsys -l</span><br></pre></td></tr></table></figure></p><p>可以看见<code>cpuinfo</code>，<code>meminfo</code>等服务，因此指定检查的服务示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; adb shell dumpsys cpuinfo</span><br><span class="line">Load: 6.04 / 6.17 / 6.21</span><br><span class="line">CPU usage from 364288ms to 62061ms ago (2019-04-12 16:20:56.605 to 2019-04-12 16:25:58.831):</span><br><span class="line">  99% 28771/com.tencent.tmgp.supercell.clashofclans: 99% user + 0% kernel / faults: 128 minor</span><br><span class="line">  2.4% 1641/system_server: 1.4% user + 0.9% kernel / faults: 5586 minor 1 major</span><br><span class="line">  1.3% 582/android.hardware.sensors@1.0-service: 0.5% user + 0.7% kernel</span><br><span class="line">  0.9% 441/ueventd: 0.6% user + 0.3% kernel</span><br><span class="line">  0.6% 4950/kworker/u16:2: 0% user + 0.6% kernel</span><br><span class="line">  0.5% 5727/kworker/u16:0: 0% user + 0.5% kernel</span><br><span class="line">  0.5% 5679/kworker/u16:5: 0% user + 0.5% kernel</span><br><span class="line">  </span><br><span class="line">... ...</span><br></pre></td></tr></table></figure></p><p>命令行参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-h：对于大多数的服务，可以添加-h看到文本的帮助</span><br><span class="line">-c：对于一些服务，可以添加-c查看数据会更友好</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; adb shell dumpsys usb -h</span><br><span class="line">Dump current USB state or issue command:</span><br><span class="line">  ports</span><br><span class="line">  set-port-roles &lt;id&gt; &lt;source|sink|no-power&gt; &lt;host|device|no-data&gt;</span><br><span class="line">  add-port &lt;id&gt; &lt;ufp|dfp|dual|none&gt;</span><br><span class="line">  connect-port &lt;id&gt; &lt;ufp|dfp&gt;&lt;?&gt; &lt;source|sink&gt;&lt;?&gt; &lt;host|device&gt;&lt;?&gt;</span><br><span class="line">    (add ? suffix if mode, power role, or data role can be changed)</span><br><span class="line">  disconnect-port &lt;id&gt;</span><br><span class="line">  remove-port &lt;id&gt;</span><br><span class="line">  reset</span><br></pre></td></tr></table></figure></p><h3 id="包服务查询"><a href="#包服务查询" class="headerlink" title="包服务查询"></a>包服务查询</h3><p>格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys package [-h] [-f] [—checkin] [cmd]…</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-h</td><td>打印帮助信息</td></tr><tr><td>-f</td><td>打印intent filter的信息</td></tr><tr><td>–checkin</td><td>打印出已经登记的库、系统功能、安装包</td></tr><tr><td>cmd</td><td>子命令（可以在-h帮助文档中查看有哪些子命令）</td></tr></tbody></table><table><thead><tr><th>cmd子命令</th><th>说明</th></tr></thead><tbody><tr><td>prov[iders]</td><td>获取content providers</td></tr><tr><td>p[ackages]</td><td>获取安装包基本信息</td></tr><tr><td>s[hared-user]</td><td>获取共享用户ID的应用</td></tr><tr><td>m[essages]</td><td>打印运行时收集的信息</td></tr><tr><td>v[erifiers]</td><td>打印包校验信息</td></tr><tr><td>version</td><td>打印数据库版本信息</td></tr><tr><td>write</td><td>写当前位置</td></tr><tr><td>package.name</td><td>输出给定包的信息</td></tr><tr><td>installs</td><td>安装会话的详细信息</td></tr><tr><td>l[ibraries]</td><td>列出已知的共享库</td></tr><tr><td>f[ibraries]</td><td>列出手机的功能</td></tr><tr><td>k[eysets]</td><td>列出各个包的Signing KeySets</td></tr><tr><td>r[esolvers]</td><td>获取intent filter</td></tr><tr><td>perm[issions]</td><td>获取权限</td></tr><tr><td>pref[erred]</td><td>打印包首选项</td></tr><tr><td>preferred-xml [—full]</td><td>打印包首选项，xml格式打印</td></tr></tbody></table><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; adb shell dumpsys package com.kuaikan.comic </span><br><span class="line">Activity Resolver Table: </span><br><span class="line">  Schemes: </span><br><span class="line">      qwallet1104081998:  </span><br><span class="line">        2d32642 com.kuaikan.comic/com.kuaikan.pay.kkb.activity.RechargeCenterActivity filter ba2036f</span><br><span class="line">          Action: &quot;android.intent.action.VIEW&quot;</span><br><span class="line">          Category: &quot;android.intent.category.BROWSABLE&quot; </span><br><span class="line">          Category: &quot;android.intent.category.DEFAULT&quot; </span><br><span class="line">          Scheme: &quot;qwallet1104081998&quot; </span><br><span class="line">      commonqwallet20181030: </span><br><span class="line">        7efe8c0 com.kuaikan.comic/com.kuaikan.pay.cashPay.TranslucentPayActivity filter b5a1d49</span><br><span class="line">          Action: &quot;android.intent.action.VIEW&quot;   </span><br><span class="line">          Category: &quot;android.intent.category.BROWSABLE&quot;  </span><br><span class="line">          Category: &quot;android.intent.category.DEFAULT&quot; </span><br><span class="line">          Scheme: &quot;commonqwallet20181030&quot;   </span><br><span class="line">          Scheme: &quot;commonalipay20181030&quot;   </span><br><span class="line">          Scheme: &quot;commonwx20181030&quot;</span><br><span class="line">          Scheme: &quot;commonpay20181105&quot;</span><br><span class="line">      comicwx201804028:</span><br></pre></td></tr></table></figure></p><h3 id="activity信息查询"><a href="#activity信息查询" class="headerlink" title="activity信息查询"></a>activity信息查询</h3><p>格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity [-a] [-c]…</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>包括所有可用的服务器状态</td></tr><tr><td>-c</td><td>包括客户端状态</td></tr><tr><td>-p</td><td>限制输出为给定的包，例如： adb shell dumpsys activity -p com.android.browser</td></tr><tr><td>-h</td><td>打印帮助信息</td></tr><tr><td>cmd</td><td>子命令</td></tr></tbody></table><table><thead><tr><th>cmd子命令</th><th>说明</th></tr></thead><tbody><tr><td>a[ctivities]</td><td>activity堆栈状态</td></tr><tr><td>r[recents]</td><td>最近activity的状态</td></tr><tr><td>b[rodacasts] [package_name] [histpry [-s]]</td><td>广播状态</td></tr><tr><td>i[ntents] [package_name]</td><td>挂起的intent状态</td></tr><tr><td>p[rocesses] [package_name]</td><td>进程状态</td></tr><tr><td>o[om]</td><td>oom管理</td></tr><tr><td>perm[issions]</td><td>url权限授权状态</td></tr><tr><td>prov[iders] [comp_spec…]</td><td>content provider状态</td></tr><tr><td>provider [comp_spec]</td><td>provider客户端状态</td></tr><tr><td>s[ervices] [comp_spec…]</td><td>服务状态</td></tr><tr><td>as[sociations]</td><td>跟踪应用程序的关联</td></tr><tr><td>service [comp_spec]</td><td>服务客户端状态</td></tr><tr><td>package [package_name]</td><td>给的包的所有状态</td></tr><tr><td>all</td><td>转储所有的activityes</td></tr><tr><td>top</td><td>转储栈顶的activity</td></tr><tr><td>write</td><td>写入所有挂起状态存储</td></tr><tr><td>track-associations</td><td>允许会话跟踪</td></tr><tr><td>untrack-associations</td><td>禁用和明确会话跟踪，命令参数可能也是一个comp_spec 转储的activity</td></tr></tbody></table><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 获取当前页面UI信息</span><br><span class="line">adb shell dumpsys activity top</span><br><span class="line"></span><br><span class="line"># 获取当前页面的Activity</span><br><span class="line">adb shell dumpsys activity top | findstr ACTIVITY</span><br></pre></td></tr></table></figure></p><h3 id="网络信息查询"><a href="#网络信息查询" class="headerlink" title="网络信息查询"></a>网络信息查询</h3><table><thead><tr><th>子命令</th><th>说明</th><th>命令格式</th></tr></thead><tbody><tr><td>connectivity</td><td>网络连接</td><td>adb shell dumpsys connectivity</td></tr><tr><td>netpolicy</td><td>网络策略</td><td>adb shell dumpsys netpolicy</td></tr><tr><td>netstats</td><td>网络状态</td><td>adb shell dumpsys netstats</td></tr><tr><td>network_management</td><td>网络管理</td><td>adb shell dumpsys network_management</td></tr></tbody></table><h3 id="其他常用服务信息查询"><a href="#其他常用服务信息查询" class="headerlink" title="其他常用服务信息查询"></a>其他常用服务信息查询</h3><table><thead><tr><th>子命令</th><th>说明</th><th>命令格式</th></tr></thead><tbody><tr><td>meminfo</td><td>内存</td><td>adb shell dumpsys meminfo</td></tr><tr><td>cpuinfo</td><td>CPU</td><td>adb shell dumpsys cpuinfo</td></tr><tr><td>gfxinfo</td><td>帧率</td><td>adb shell dumpsys gfxinfo</td></tr><tr><td>display</td><td>显示</td><td>adb shell dumpsys display</td></tr><tr><td>power</td><td>电源</td><td>adb shell dumpsys power</td></tr><tr><td>batterystats</td><td>电池状态</td><td>adb shell dumpsys batterystats</td></tr><tr><td>battery</td><td>电池</td><td>adb shell dumpsys battery</td></tr><tr><td>alarm</td><td>闹钟</td><td>adb shell dumpsys alarm</td></tr><tr><td>location</td><td>位置</td><td>adb shell dumpsys location</td></tr><tr><td>wifi</td><td>wifi</td><td>adb shell dumpsys wifi</td></tr><tr><td>power</td><td>电源</td><td>adb shell dumpsys power</td></tr><tr><td>notification</td><td>通知</td><td>adb shell dumpsys notification</td></tr></tbody></table><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 电池信息</span><br><span class="line">&#123;lamb&#125; adb shell dumpsys battery</span><br><span class="line">Current Battery Service state:</span><br><span class="line">  AC powered: false</span><br><span class="line">  USB powered: true</span><br><span class="line">  Wireless powered: false</span><br><span class="line">  Max charging current: 500000</span><br><span class="line">  Max charging voltage: 5000000</span><br><span class="line">  Charge counter: 3321815</span><br><span class="line">  status: 5 #电池状态</span><br><span class="line">  health: 2 </span><br><span class="line">  present: true</span><br><span class="line">  level: 100 #电量</span><br><span class="line">  scale: 100</span><br><span class="line">  voltage: 4369</span><br><span class="line">  temperature: 310  #电池温度</span><br><span class="line">  technology: Li-poly</span><br></pre></td></tr></table></figure></p><p>完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;adb进阶四 —— dumpsys&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://tokyle.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="http://tokyle.com/tags/Android/"/>
    
      <category term="adb" scheme="http://tokyle.com/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>adb进阶三 —— Monkey (2)</title>
    <link href="http://tokyle.com/2019/04/11/adb%E8%BF%9B%E9%98%B6%E4%B8%89-%E2%80%94%E2%80%94-Monkey-2/"/>
    <id>http://tokyle.com/2019/04/11/adb进阶三-——-Monkey-2/</id>
    <published>2019-04-11T08:33:46.000Z</published>
    <updated>2019-04-24T05:38:22.972Z</updated>
    
    <content type="html"><![CDATA[<p>adb进阶三 —— Monkey (2)</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为原生的monkey，是一系列的随机事件，很多时候事满足不了我们自定义场景需求的，比如只想验证APP的登录的稳定性，使用原生的<code>adb shell monkey</code>貌似做不到，这边就需要自定义脚本来实现</p><h3 id="Monkey-API"><a href="#Monkey-API" class="headerlink" title="Monkey API"></a>Monkey API</h3><table><thead><tr><th>API</th><th>描述</th></tr></thead><tbody><tr><td>LaunchActivity(pkg_name, cl_name)</td><td>启动应用的Activity。参数：包名和启动的Activity</td></tr><tr><td>Tap(x, y, tapDuration)</td><td>模拟一次手指单击事件。参数：x,y为控件坐标，tapDuration为点击的持续时间，此参数可省略</td></tr><tr><td>DispatchPress(keycode)</td><td>按键。参数： keycode</td></tr><tr><td>RotateScreen(rotationDegree, persist)</td><td>旋转屏幕。 参数：rotationDegree为旋转角度， e.g. 1代表90度；persist表示旋转之后是否固定，0表示旋转后恢复，非0则表示固定不变</td></tr><tr><td>DispatchFlip(true/false)</td><td>打开或者关闭软键盘</td></tr><tr><td>LongPress()</td><td>长按</td></tr><tr><td>PressAndHold(x, y, pressDuration)</td><td>模拟长按事件</td></tr><tr><td>DispatchString(input)</td><td>输入字符串</td></tr><tr><td>Drag(xStart, yStart, xEnd, yEnd, stepCount)</td><td>拖拽</td></tr><tr><td>PinchZoom(x1Start, y1Start, x1End, y1End, x2Start, y2Start, x2End, y2End, stepCount)</td><td>缩放</td></tr><tr><td>UserWait(sleepTime)</td><td>休眠</td></tr><tr><td>DeviceWakeUp()</td><td>唤醒屏幕</td></tr><tr><td>PowerLog(power_log_type, test_case_status)</td><td>模拟电池电量信息</td></tr><tr><td>WriteLog()</td><td>将电池信息写入sd卡</td></tr><tr><td>RunCmd(cmd)</td><td>运行shell命令</td></tr><tr><td>DispatchPointer(long downTime,  long eventTime, int action, loat x, float y, float pressure, float size, int metaState,  float xPrecision, float yPrecision, int device, int edgeFlags)</td><td>向指定位置，发送单个手势，点击事件</td></tr><tr><td>DispatchKey(long downTime, long eventTime, int action, int code, int repeat, int metaState, int device, int scancode)</td><td>发送键值</td></tr><tr><td>LaunchInstrumentation(test_name,runner_name)</td><td>运行一个instrumentation测试用例</td></tr><tr><td>DispatchTrackball(long downTime, long eventTime, int action, float x, float y, float pressure, float size, int metaState, float xPrecision, float yPrecision, int device, int edgeFlags)</td><td>模拟发送轨迹球事件</td></tr><tr><td>ProfileWait</td><td>等待5秒</td></tr><tr><td>StartCaptureFramerate()</td><td>获取帧率</td></tr><tr><td>EndCaptureFramerate(input)</td><td>结束获取帧率</td></tr></tbody></table><p>以<strong>点击事件</strong>为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DispatchPointer(long downTime,  long eventTime, int action, loat x, float y, float pressure, float size, int metaState,  float xPrecision, float yPrecision, int device, int edgeFlags)</span><br></pre></td></tr></table></figure></p><p>参数很多，只需要关注<code>action</code>，<code>x</code>，<code>y</code>，对于参数action值为0代表按下（KeyDown），1代表弹起（KeyUp）。如果使用这个方法实现点击事件，这个方法就应该成对出现，先0再1。</p><ul><li>long downTime：键最初被按下时间</li><li>long eventTime：事件发生时间</li><li>int action：动作ACTION_DOWN=0,ACTION_UP=1,ACTION_MULTIPLE=2</li><li>float x：x坐标</li><li>float y：y坐标</li><li>float pressure：当前事件的压力，值为0～1</li><li>float size：触摸的近似值，范围为0～1</li><li>int metaState：当前按下的meta键的标识</li><li>float xPrecision：x坐标精确值</li><li>float yPrecision：y坐标精确值</li><li>int device：事件来源，范围0～x，0表示不来自物理设备</li><li>int edgeFlags：坐标是否超出了屏幕范围</li></ul><blockquote><p><a href="http://tokyle.com/2018/01/17/appium%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/">Android键盘事件，keycode</a></p></blockquote><h3 id="Monkey脚本"><a href="#Monkey脚本" class="headerlink" title="Monkey脚本"></a>Monkey脚本</h3><p>和自动化测试时候差不多实现，<strong>打开首页-点击用户名-输入用户名-点击密码-输入密码-点击登录</strong>，相应的，也就是只需要获取用户名和密码以及确定按键的坐标，传到<code>DispatchPointer</code>即可，获取坐标可以使用<code>uiautomatorviewer.bat</code>挺简单的，直接上脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 头部</span><br><span class="line">type= user</span><br><span class="line">count= 1</span><br><span class="line">speed= 1.0</span><br><span class="line">UserWait(200)</span><br><span class="line">start data &gt;&gt;</span><br><span class="line"></span><br><span class="line"># 打开app登录页</span><br><span class="line">LaunchActivity(com.android.testapp,com.android.testapp.MainActivity)</span><br><span class="line"># 休眠</span><br><span class="line">UserWait(10000)</span><br><span class="line"># 点击用户名文本框（460,751）为坐标</span><br><span class="line">DispatchPointer(10,10,0,460,751,1,1,-1,1,1,0,0)</span><br><span class="line">DispatchPointer(10,10,1,460,751,1,1,-1,1,1,0,0)</span><br><span class="line">UserWait(5000)</span><br><span class="line"># 输入用户名</span><br><span class="line">DispatchString(monkeytest)</span><br><span class="line">DispatchFlip(false)</span><br><span class="line">UserWait(2000)</span><br><span class="line"># 点击密码文本框（490,867）为坐标</span><br><span class="line">DispatchPointer(10,10,0,490,867,1,1,-1,1,1,0,0)</span><br><span class="line">DispatchPointer(10,10,1,490,867,1,1,-1,1,1,0,0)</span><br><span class="line">UserWait(5000)</span><br><span class="line"># 输入密码</span><br><span class="line">DispatchString(123456)</span><br><span class="line">DispatchFlip(false)</span><br><span class="line">UserWait(2000)</span><br><span class="line"># 点击确定</span><br><span class="line">Tap(541,1096)</span><br></pre></td></tr></table></figure></p><p>保存为monkey_test.txt文件，上传到android设备：<code>adb push monkey_test.txt /mnt/sdcard/</code><br>执行脚本：<code>adb shell monkey -f /mnt/sdcard/monkey_test.txt -v 1</code></p><p>完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;adb进阶三 —— Monkey (2)&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://tokyle.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="http://tokyle.com/tags/Android/"/>
    
      <category term="adb" scheme="http://tokyle.com/tags/adb/"/>
    
      <category term="Monkey" scheme="http://tokyle.com/tags/Monkey/"/>
    
  </entry>
  
  <entry>
    <title>adb进阶二 —— Monkey (1)</title>
    <link href="http://tokyle.com/2019/04/11/adb%E8%BF%9B%E9%98%B6%E4%B8%80-%E2%80%94%E2%80%94-Monkey-1/"/>
    <id>http://tokyle.com/2019/04/11/adb进阶一-——-Monkey-1/</id>
    <published>2019-04-11T06:12:22.000Z</published>
    <updated>2019-04-24T05:37:50.819Z</updated>
    
    <content type="html"><![CDATA[<p>adb进阶二 —— Monkey (1)</p><a id="more"></a><h3 id="Monkey简介"><a href="#Monkey简介" class="headerlink" title="Monkey简介"></a>Monkey简介</h3><p>Monkey是一个可运行在Android环境中的命令行工具，使用monkey尅发送一些伪随机事件（pseudo-random）的用户事件流，例如点击，触摸，手势等。通过monkey，我们可以注入随机事件流或者自定义特定事件来对应用进行健壮性、稳定性测试。</p><h4 id="Monkey用途"><a href="#Monkey用途" class="headerlink" title="Monkey用途"></a>Monkey用途</h4><p>通过使用monkey来对应用进行压力测试。</p><p>Monkey包含一系列选项，主要包括以下方面：</p><ol><li>基础配置项，比如设置注入事件的数量<code>adb shell monkey 500</code></li><li>备选限制，比如限制测试单个包<code>adb shell monkey -p com.android.camera  5000</code></li><li>事件类型和频率</li><li>调试选项</li></ol><h4 id="Monkey程序简介"><a href="#Monkey程序简介" class="headerlink" title="Monkey程序简介"></a>Monkey程序简介</h4><p>monkey在Android文件系统存放路径为：<code>/system/framework/monkey.jar</code><br>启动monkey.jar的shell脚本文件在Android文件系统存放路径为<code>system/bin/monkey</code><br>导到本地:<code>adb pull /system/bin/monkey E:\app_workstation\Android_files\MONKEY</code><br>可以看到monkey的shell内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Script to start &quot;monkey&quot; on the device, which has a very rudimentary</span><br><span class="line"># shell.</span><br><span class="line">#</span><br><span class="line">base=/system</span><br><span class="line">export CLASSPATH=$base/framework/monkey.jar</span><br><span class="line">trap &quot;&quot; HUP</span><br><span class="line">for a in &quot;$@&quot;; do</span><br><span class="line">    echo &quot;  bash arg:&quot; $a</span><br><span class="line">done</span><br><span class="line">exec app_process $base/bin com.android.commands.monkey.Monkey &quot;$@&quot;</span><br></pre></td></tr></table></figure></p><p>可以看到调用的是<code>com.android.commands.monkey.Monkey</code>包</p><h3 id="Monkey命令"><a href="#Monkey命令" class="headerlink" title="Monkey命令"></a>Monkey命令</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p>基础语法：<code>adb shell monkey [option] &lt;event-count&gt;</code><br>当不指定任何选项时，monkey将默认静态模式，并且会向目标设备的所有包发送随机事件</p><p>基本使用：<code>adb shell monkey</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; adb shell monkey                                                 </span><br><span class="line">args: []                                                                </span><br><span class="line">usage: monkey [-p ALLOWED_PACKAGE [-p ALLOWED_PACKAGE] ...]             </span><br><span class="line">              [-c MAIN_CATEGORY [-c MAIN_CATEGORY] ...]                 </span><br><span class="line">              [--ignore-crashes] [--ignore-timeouts]                    </span><br><span class="line">              [--ignore-security-exceptions]                            </span><br><span class="line">              [--monitor-native-crashes] [--ignore-native-crashes]      </span><br><span class="line">              [--kill-process-after-error] [--hprof]                    </span><br><span class="line">              [--match-description TEXT]                                </span><br><span class="line">              [--pct-touch PERCENT] [--pct-motion PERCENT]              </span><br><span class="line">              [--pct-trackball PERCENT] [--pct-syskeys PERCENT]         </span><br><span class="line">              [--pct-nav PERCENT] [--pct-majornav PERCENT]              </span><br><span class="line">              [--pct-appswitch PERCENT] [--pct-flip PERCENT]            </span><br><span class="line">              [--pct-anyevent PERCENT] [--pct-pinchzoom PERCENT]        </span><br><span class="line">              [--pct-permission PERCENT]                                </span><br><span class="line">              [--pkg-blacklist-file PACKAGE_BLACKLIST_FILE]             </span><br><span class="line">              [--pkg-whitelist-file PACKAGE_WHITELIST_FILE]             </span><br><span class="line">              [--wait-dbg] [--dbg-no-events]                            </span><br><span class="line">              [--setup scriptfile] [-f scriptfile [-f scriptfile] ...]  </span><br><span class="line">              [--port port]                                             </span><br><span class="line">              [-s SEED] [-v [-v] ...]                                   </span><br><span class="line">              [--throttle MILLISEC] [--randomize-throttle]              </span><br><span class="line">              [--profile-wait MILLISEC]                                 </span><br><span class="line">              [--device-sleep-time MILLISEC]                            </span><br><span class="line">              [--randomize-script]                                      </span><br><span class="line">              [--script-log]                                            </span><br><span class="line">              [--bugreport]                                             </span><br><span class="line">              [--periodic-bugreport]                                    </span><br><span class="line">              [--permission-target-system]                              </span><br><span class="line">              COUNT</span><br></pre></td></tr></table></figure></p><p>可以看见列出了所有monkey的usage，但是并没有启动，因为缺少事件数量，只要加上数量，即可<code>adb shell monkey 10000</code></p><h4 id="Monkey-Option"><a href="#Monkey-Option" class="headerlink" title="Monkey Option"></a>Monkey Option</h4><p>monkey的option可以根据实际需要进行选择，主要分为<strong>常规类</strong>、<strong>事件类</strong>、<strong>约束类</strong>和<strong>调试类</strong></p><h5 id="常规类"><a href="#常规类" class="headerlink" title="常规类"></a>常规类</h5><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>- - help</td><td>显示帮助信息，usage</td></tr><tr><td>-v</td><td>打印日志信息，每增加一个-v，日志显示的信息越详细，目前最多支持三个-v，即：-v -v -v;  L0:一个-v，除启动提示、测试完成和最终结果之外，提供较少信息；  L1：两个-v，-v -v，提供较详细的运行测试信息，如发送到Activity的事件； L2：三个-v，-v -v -v，提供更加详细的信息，如测试中被选中的或未选中的Activity</td></tr></tbody></table><h5 id="事件类"><a href="#事件类" class="headerlink" title="事件类"></a>事件类</h5><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-s</td><td>伪随机数生成器的seed值，如果用相同的seed值再次运行mnkey，会生成相同的事件序列(重复执行刚才的随机操作，复现问题好用)</td></tr><tr><td>- -throttle</td><td>后面接时间，单位毫秒，表示事件之间的固定延时（执行 每一个指令的间隔时间）</td></tr><tr><td>- -pct-touch</td><td>后接触摸事件百分比(触摸事件是一个down-up事件，它发生在屏幕上的某单一位置)，点击</td></tr><tr><td>- -pct-motion</td><td>后接动作事件百分比(动作事件由屏幕上某处的一个down事件、一系列的伪随机事件和一个up事件组成)，滑动</td></tr><tr><td>- -pct-trackball</td><td>后面接轨迹事件的百分比(轨迹事件由一个或几个随机的移动组成，有时还伴随有点击)</td></tr><tr><td>- -pct-syskeys</td><td>后面接“系统”按键事件的百分比(这些按键通常被保留，由系统使用，如Home、Back、StartCall、End Call及音量控制键)。</td></tr><tr><td>- -pct-nav</td><td>后面接“基本”导航事件百分比(导航事件主要来自方向输入设备的上，下，左，右事件)</td></tr><tr><td>- -pct-majornav</td><td>后面接“主要”导航事件的百分比(这些导航事件通常引发图形界面中的动作，如：键盘的中间按键、回退按键、菜单按键)</td></tr><tr><td>- -pct-appswitch</td><td>后面接启动Activity的百分比。在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法。</td></tr><tr><td>- -pct-flip</td><td>键盘翻转事件</td></tr><tr><td>- -pct-anyevent</td><td>调整其他时间比例，比如很少使用的keypress等事件</td></tr><tr><td>- -pct-pinchzoom</td><td>缩放事件</td></tr><tr><td>- -pct-permission</td><td>未知</td></tr></tbody></table><h5 id="约束类"><a href="#约束类" class="headerlink" title="约束类"></a>约束类</h5><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p</td><td>指定包，可一个可多个，多个包需要多个-p</td></tr><tr><td>-c</td><td>指定类，可一个可多个，多个需多个-c</td></tr></tbody></table><h5 id="调试类"><a href="#调试类" class="headerlink" title="调试类"></a>调试类</h5><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>- -hprof</td><td>设置此选项，将在Monkey事件序列之前和之后立即生成profiling报告。这将会在data/misc中生成大文件(~5Mb)，所以要小心使用它</td></tr><tr><td>- -ignore-crashes</td><td>当应用程序崩溃或发生任何失控异常时，Monkey将停止运行。如果设置此选项，Monkey将继续向系统发送事件，直到计数完成</td></tr><tr><td>- -ignore-timeouts</td><td>当应用程序发生任何超时错误(如“ApplicationNot Responding”对话框)时，Monkey将停止运行。如果设置此选项，Monkey将继续向系统发送事件，直到计数完成</td></tr><tr><td>- -ignore-security-exceptions</td><td>当应用程序发生任何权限错误（如启动一个需要某些权限的Activity)时，monkey将继续运行直到计数完成</td></tr><tr><td>- -ignore-native-crashes</td><td>当应用程序发生native code的崩溃事件时，monkey将继续运行直至计数完成</td></tr><tr><td>- -kill-process-after-error</td><td>设置此项后，当monkey因为应用程序发生错误而停止时，将会通知系统停止发生错误的进程</td></tr><tr><td>- -monitor-native-crashes</td><td>设置此项后，monkey运行时native code的崩溃事件将被监视并报告</td></tr></tbody></table><h4 id="常用monkey示例"><a href="#常用monkey示例" class="headerlink" title="常用monkey示例"></a>常用monkey示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p com.android.camera --ignore-crashes --ignore-timeouts --ignore-security-exceptions  --ignore-native-crashes --pct-touch 70 --pct-motion 25 --pct-majornav 5 -v -v -v --throttle 300 100000 &gt; E:\app_workstation\Android_files\MONKEY\1.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>以上命令执行效果：忽略app崩溃，忽略超时，忽略权限异常，忽略应用程序发生崩溃的本地代码，触摸事件百分比70%，手势事件25%，主要导航事件5%；日志等级三级，事件间隔3s，执行100000次事件，输出和错误都打印进D盘1.log文件中</p><h5 id="补充标准输出知识"><a href="#补充标准输出知识" class="headerlink" title="补充标准输出知识"></a>补充标准输出知识</h5><p>linux中，标准输入<code>stdin</code>，标准输出<code>stdout</code>，标准错误<code>stderr</code>，分别使用0,1,2代替，所以就有了以下几种常用的重定向方式：</p><ol><li><code>sh test.sh &gt; 1.log</code>，标准错误输出到屏幕，标准输出打印到1.log文件中，1.log中没有错误内容</li><li><code>sh test.sh &gt; 2.log 2&gt;&amp;1</code>，标准输出和标准错误都打印到2.log文件中</li><li><code>sh test.sh &gt; 3.log 2 &gt;err.log</code>，标准输出打印到3.log文件，标准错误打印到err.log文件</li></ol><p>使用monkey生成日志之后，需要对日志进行筛查，看是否有APP崩溃记录或者无响应记录。</p><ul><li>崩溃记录查找”CRASH”</li><li>无响应记录查找”ANR”（Application No Responding）</li><li>内存泄露问题搜索”GC”（需进一步分析）</li><li>异常问题搜索“Exception”（如果出现空指针，NullPointerException，需格外重视）</li></ul><h4 id="停止Monkey"><a href="#停止Monkey" class="headerlink" title="停止Monkey"></a>停止Monkey</h4><p>既然是linux进程，想停，很简单，找出来，kill掉..<br><code>adb shell ps | grep monkey</code><br><code>adb shell kill -9 PID</code></p><p>完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;adb进阶二 —— Monkey (1)&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://tokyle.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="http://tokyle.com/tags/Android/"/>
    
      <category term="adb" scheme="http://tokyle.com/tags/adb/"/>
    
      <category term="Monkey" scheme="http://tokyle.com/tags/Monkey/"/>
    
  </entry>
  
  <entry>
    <title>adb进阶一 —— logcat</title>
    <link href="http://tokyle.com/2019/04/10/adb%E8%BF%9B%E9%98%B6%E4%B8%80-%E2%80%94%E2%80%94-logcat/"/>
    <id>http://tokyle.com/2019/04/10/adb进阶一-——-logcat/</id>
    <published>2019-04-10T08:18:18.000Z</published>
    <updated>2019-04-10T08:19:31.368Z</updated>
    
    <content type="html"><![CDATA[<p>adb进阶一 —— logcat</p><a id="more"></a><h3 id="logcat-简介"><a href="#logcat-简介" class="headerlink" title="logcat 简介"></a>logcat 简介</h3><p>logcat是Android中的一个命令行工具，可以用于测试过程中获取程序的log<br>基本用法：<br>测试开始前，可以先清缓存:<code>adb logcat -c</code><br>获取日志：<code>adb logcat &gt; E:\app_workstation\Android_files\logs\1.log</code></p><p>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[adb] logcat [&lt;option&gt;] … [&lt;filter – spec&gt;] …</span><br></pre></td></tr></table></figure></p><p>推荐搭配grep使用</p><h3 id="logcat-缓冲区"><a href="#logcat-缓冲区" class="headerlink" title="logcat 缓冲区"></a>logcat 缓冲区</h3><p>Android log输出量巨大， 特别是通信类log，好在Android降log放在不同的缓冲区内，可用于指定缓冲区输出log，目前有四个缓冲区：</p><table><thead><tr><th>缓冲区名称</th><th>用途</th></tr></thead><tbody><tr><td>Radio</td><td>输出通信系统的log</td></tr><tr><td>System</td><td>输出系统组件的log</td></tr><tr><td>Event</td><td>输出event模块的log</td></tr><tr><td>Main</td><td>所有java层的log，以及不属于上面三层的log</td></tr></tbody></table><p>缓冲区主要是给系统组件使用的，一般的应用不需要考虑，应用的log都在<strong>main</strong>缓冲区中<br>默认log输出（不指定缓冲区的情况下）是输出<code>System</code>和<code>Main</code>缓冲区的log</p><p>获取缓冲区命令：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-b <buffer></buffer></td><td>加载一个可使用的日志缓冲区提供查看，默认是main</td></tr></tbody></table><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb logcat –b radio</span><br><span class="line"></span><br><span class="line">adb logcat –b system</span><br><span class="line"></span><br><span class="line">adb logcat –b events</span><br><span class="line"></span><br><span class="line">adb logcat –b main</span><br></pre></td></tr></table></figure></p><h3 id="logcat-参数"><a href="#logcat-参数" class="headerlink" title="logcat 参数"></a>logcat 参数</h3><h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><p>由低到高</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>V</td><td>Verbose（最低优先级）明细</td></tr><tr><td>D</td><td>Debug调试</td></tr><tr><td>I</td><td>Info    信息</td></tr><tr><td>W</td><td>Warning警告</td></tr><tr><td>E</td><td>Error    错误</td></tr><tr><td>F</td><td>Fatal    严重错误</td></tr><tr><td>S</td><td>Silent（Super all output）</td></tr></tbody></table><p>日志过滤器格式：<code>tag: priority</code></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 仅输出标记为“ActivityManager”且优先级大于等于“Info”和 标记为“PowerManagerService”并且优先级大于等于“Debug”的日志</span><br><span class="line"></span><br><span class="line">adb logcat ActivityManager:I PowerManagerService:D *:S</span><br><span class="line"></span><br><span class="line"># 显示所有优先级大于等于“warning”的日志</span><br><span class="line"></span><br><span class="line">adb logcat *:W</span><br><span class="line"></span><br><span class="line"># 显示PowerManagerService的日志信息</span><br><span class="line"></span><br><span class="line">adb logcat -s PowerManagerService</span><br></pre></td></tr></table></figure></p><p>tips：<code>*:S</code>设置所有日志级别高于S的日志，由于没有这样级别，所以加上该过滤器可以确保只会输出符合条件的日志</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-b</td><td>加载一个可使用的日志缓冲区供查看，默认值为main</td></tr><tr><td>-c</td><td>清除缓冲区中的全部日志并退出（清除完成后可使用-g 查看）</td></tr><tr><td>-g</td><td>打印日志缓冲区的大小并退出</td></tr><tr><td>-d</td><td>将缓冲区的log转存到屏幕中然后退出</td></tr><tr><td>-f</td><td>将log输出到制定的文件中&lt;文件名&gt;，默认为标准输出（stdout）</td></tr><tr><td>-n</td><td>设置日志的最大数目，默认值为4，需要和-r选项一起使用</td></tr><tr><td>-r</td><td>按照每千字节输出日志，默认值为16，需要和-f一起使用</td></tr><tr><td>-s</td><td>设置过滤器</td></tr><tr><td>-v</td><td>设置输出格式的日志消息</td></tr></tbody></table><p>一般长时间输出log的话建议-f -n -r三个参数连用，这样当一个文件日志输出满了之后可以马上在另一个中进行输出（输出多个指定大小的日志文件）<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -f /data/local/tmp/log.txt -n 2 -r 3</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -b radio -v time &gt; /tmp/event.log</span><br></pre></td></tr></table></figure><p>tips:<code>-v time</code>表示在log中加入每条log发生的时间</p><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>-v更多格式：</p><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>brief</td><td>显示优先级/标记和过程的PID发出的消息（默认格式）</td></tr><tr><td>process</td><td>仅显示进程PID</td></tr><tr><td>tag</td><td>仅显示优先级/标记</td></tr><tr><td>thread</td><td>仅显示进程：线程和优先级/标记</td></tr><tr><td>raw</td><td>显示原始的日志信息，没有其他的元数据字段</td></tr><tr><td>time</td><td>显示日期，调用时间，优先级/标记，PID</td></tr><tr><td>long</td><td>显示所有的元数据字段并且用空行分隔消息内容</td></tr></tbody></table><p>示例：<code>adb logcat -v thread</code></p><p>以上，完~</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote><p><a href="https://www.cnblogs.com/bydzhangxiaowei/p/8168598.html" target="_blank" rel="noopener">ADB logcat 过滤方法(抓取日志)</a><br><a href="https://www.cnblogs.com/JianXu/p/5468839.html" target="_blank" rel="noopener">Android logcat命令详解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;adb进阶一 —— logcat&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://tokyle.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="http://tokyle.com/tags/Android/"/>
    
      <category term="adb" scheme="http://tokyle.com/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>Android调试工具adb简介</title>
    <link href="http://tokyle.com/2019/04/10/Android%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7adb%E7%AE%80%E4%BB%8B/"/>
    <id>http://tokyle.com/2019/04/10/Android调试工具adb简介/</id>
    <published>2019-04-10T05:32:15.000Z</published>
    <updated>2019-04-10T05:35:29.880Z</updated>
    
    <content type="html"><![CDATA[<p>Android调试工具adb简介</p><a id="more"></a><p>对于Android测试和开发，adb使用应该算是一个基本技能，正好最近需要用到这个，结合网上前人经验稍微总结一下。</p><h3 id="adb"><a href="#adb" class="headerlink" title="adb"></a>adb</h3><p>adb全称<code>Android Debug Bridge</code>Android的调试桥，其实就是一个C/S架构的命令行工具。<br>adb有三个部分：</p><ol><li>运行在PC端（Windows，linux，Mac os）的client，功能是可以进行Android应用的安装，卸载，调试。</li><li>运行在PC端的service，作用是管理客户端到Android设备上adb后台进程的连接（adb服务启动后，在Windows资源管理器中可以查看adb.exe是启动状态）</li><li>运行在Android设备上的adb后台进程（adb shell ps | grep adb可见，占用端口5037）</li></ol><h3 id="常用abd命令"><a href="#常用abd命令" class="headerlink" title="常用abd命令"></a>常用abd命令</h3><ul><li><p>安装应用（apk文件在PC本地）<br>命令行进入apk文件所在路径，执行<code>adb install kuaikan.apk</code></p></li><li><p>卸载应用（应用已安装在Android设备）<br>区别与安装应用是试用apk文件，卸载应用试用的是包名，类似：<code>com.android.camera</code><br>连接上设备，执行<code>adb uninstall com.kuaikan.comic</code><br>(关于获取包名，可以问开发，也可以反编译apk文件，从<code>AndroidManifest.xml</code>文件中获取，反编译方法：推荐使用<code>apktool</code>,直接命令行执行<code>java -jar 路径\apktool.jar d 、路径yourApkFile.apk</code>即可，包名在<code>AndroidManifest.xml</code>中的<code>package</code>项可获取，顺便activity也可以在此获取<code>activity</code>)</p><blockquote><p><a href="https://bitbucket.org/iBotPeaches/apktool/downloads/" target="_blank" rel="noopener">apktool下载地址</a></p></blockquote></li><li><p>文件互传<br>Android设备和PC之间的文件互传<br><code>adb pull 文件 目录</code>文件从Android设备推送到本地PC<br><code>adb push 文件 目录</code>文件从本地PC上传到Android设备</p></li><li><p>设备连接<br><code>adb devices</code> 获取设备列表及设备状态<br><code>adb get-state</code> 获取设备状态（device表示连接正常；offline表示连接异常，设备无响应；unknown表示为止设备）</p></li><li><p>日志操作<br><code>adb logcat</code>打印Android系统日志，类似的<code>bugreport</code>、<code>dumpsys</code>、<code>dumpstate</code>，建议重定向到本地：<br><code>adb bugreport &gt; D:\applogs\bugreport.log</code></p></li></ul><h3 id="adb-shell"><a href="#adb-shell" class="headerlink" title="adb shell"></a>adb shell</h3><p>adb shell其实就是调用Android系统中的命令，应该都知道，Android底层其实是linux，adb shell个人理解，和进入linux敲命令差不多，只是敲的是封装好的Android命令，因此，可以直接先执行adb shell进入shell模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E:\app_workstation &#123;git&#125;</span><br><span class="line">&#123;lamb&#125; adb shell</span><br><span class="line">sakura:/ $</span><br><span class="line">2|sakura:/ $ cd /data/</span><br><span class="line">sakura:/data $</span><br></pre></td></tr></table></figure></p><p>另外，adb shell的命令，都是执行的/system/bin目录下的执行文件，如果设备是root过的，可以尝试把这个目录导出来，看看命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /system/bin/ E:\app_workstation\BIN</span><br></pre></td></tr></table></figure></p><p>导出之后，可以看一下<code>am</code>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/system/bin/sh</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; != &quot;instrument&quot; ] ; then</span><br><span class="line">    cmd activity &quot;$@&quot;</span><br><span class="line">else</span><br><span class="line">    base=/system</span><br><span class="line">    export CLASSPATH=$base/framework/am.jar</span><br><span class="line">    exec app_process $base/bin com.android.commands.am.Am &quot;$@&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>其实就是shell脚本</p><ul><li>服务启停<br>停：<code>adb kill-server</code><br>启：<code>adb start-server</code><br>一般设备连接异常时，adb devices未显示设备，可以先停再重启服务</li></ul><h4 id="pm"><a href="#pm" class="headerlink" title="pm"></a>pm</h4><ul><li><p>列出安装在设备上的应用<br><code>adb shell pm list package</code></p></li><li><p>列出系统应用<br><code>adb shell pm list package -s</code></p></li><li><p>列出第三方应用<br><code>adb shell pm list package -3</code></p></li><li><p>列出包名及对应的apk名和存放路径<br><code>adb shell pm list package -f</code></p></li><li><p>组合查找，过滤(查找相机包名及安装路径)<br><code>adb shell pm list package -f -i camera</code></p></li><li><p>列出对应包名的.apk位置<br><code>adb shell pm path com.android.camera</code></p></li><li><p>列出对应包名的dump信息（可重定向到本地）<br><code>adb shell pm dump com.android.camera &gt; E:\app_workstation\android_files\camera.dump</code></p></li></ul><h4 id="am"><a href="#am" class="headerlink" title="am"></a>am</h4><ul><li><p>启动activity<br><code>adb shell am start -n package/activity</code><br>例如：<code>adb shell am start -n com.android.camera/.Camera</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; adb shell am start -n com.android.camera/.Camera</span><br><span class="line">Starting: Intent &#123; cmp=com.android.camera/.Camera &#125;</span><br></pre></td></tr></table></figure></li><li><p>先停止应用再启动<br><code>adb shell am start -S com.android.camera/.Camera</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; adb shell am start -S com.android.camera/.Camera</span><br><span class="line">Stopping: com.android.camera</span><br><span class="line">Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.android.camera/.Camera &#125;</span><br></pre></td></tr></table></figure></li><li><p>启动默认浏览器并打开网页<br><code>adb shell am start -a android.intent.action.VIEW -d https://www.baidu.com</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; adb shell am start -a android.intent.action.VIEW -d https://www.baidu.com</span><br><span class="line">Starting: Intent &#123; act=android.intent.action.VIEW dat=https://www.baidu.com/... &#125;</span><br></pre></td></tr></table></figure></li><li><p>停止应用<br><code>adb shell am force-stop package</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; adb shell am force-stop com.android.camera</span><br></pre></td></tr></table></figure></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>截图<br><code>adb shell screencap -p /sdcard/screen.png</code></p></li><li><p>录制<br><code>adb shell screenrecord sdcard/record.mp4</code></p></li><li><p>查看设备信息（如Android版本号）<br><code>adb shell getprop</code><br>示例：获取sdk版本：<code>adb shell getprop ro.build.version.sdk</code></p></li><li><p>查看分辨率<br><code>adb shell wm size</code></p></li><li><p>查看屏幕密度<br><code>adb shell wm density</code></p></li></ul><p>当设备root后，其实能获取的就更多了，例如MAC 地址啥的</p><p>以上，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android调试工具adb简介&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://tokyle.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="http://tokyle.com/tags/Android/"/>
    
      <category term="adb" scheme="http://tokyle.com/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>记cmder/git一个报错解决</title>
    <link href="http://tokyle.com/2019/04/09/%E8%AE%B0cmder-git%E4%B8%80%E4%B8%AA%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
    <id>http://tokyle.com/2019/04/09/记cmder-git一个报错解决/</id>
    <published>2019-04-10T01:39:50.000Z</published>
    <updated>2019-04-10T01:40:32.624Z</updated>
    
    <content type="html"><![CDATA[<p>记cmder/git一个报错解决</p><a id="more"></a><h3 id="Couldn’t-reserve-space-for-cygwin’s-heap-Win32-error-0"><a href="#Couldn’t-reserve-space-for-cygwin’s-heap-Win32-error-0" class="headerlink" title="Couldn’t reserve space for cygwin’s heap, Win32 error 0"></a>Couldn’t reserve space for cygwin’s heap, Win32 error 0</h3><p>早上开机想试试adb工具，由于是在Windows机器，第一个想到的还是用<code>cmder</code>来命令行操作，然后不知道是昨天系统自动更新强制杀了昨天的cmder进程造成文件损坏还是什么鬼，<code>ls</code>直接报错（普通用户打开cmder就可以执行ls，用管理员打开，就不行），具体报错信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; ls</span><br><span class="line">      0 [main] us 0 init_cheap: VirtualAlloc pointer is null, Win32 error 487</span><br><span class="line">AllocationBase 0x0, BaseAddress 0x68570000, RegionSize 0x450000, State 0x10000</span><br><span class="line">D:\dev\cmder\vendor\msysgit\bin\ls.exe: *** Couldn&apos;t reserve space for cygwin&apos;s heap, Win32 error 0</span><br></pre></td></tr></table></figure></p><p>同样的报错也可能出现在使用<code>git</code>时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Git\bin\git.exe pull --progress &quot;origin&quot; </span><br><span class="line">Done</span><br><span class="line">    0 [main] us 0 init_cheap: VirtualAlloc pointer is null, Win32 error 487</span><br><span class="line">AllocationBase 0x0, BaseAddress 0x68560000, RegionSize 0x390000, State 0x10000</span><br><span class="line">C:\Program Files\Git\bin\sh.exe: *** Couldn&apos;t reserve space for cygwin&apos;s heap, Win32 error 0</span><br></pre></td></tr></table></figure></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="重装cmder"><a href="#重装cmder" class="headerlink" title="重装cmder"></a>重装cmder</h4><p>首先以为是昨天系统自动升级时候强制杀了cmder进程造成文件损坏，就尝试重装了次，为了避免注册表问题，还选了其他的地址，安装完毕之后管理员打开cmder，ls还是报那个错，失败</p><h4 id="rebase-exe-b"><a href="#rebase-exe-b" class="headerlink" title="rebase.exe -b"></a>rebase.exe -b</h4><p>这个办法，原理不知道。。。在stackoverflow翻到的，不过是真解决了</p><ol><li><p>首先是进<code>路径\msysgit\bin</code>查看是否有<code>rebase.exe</code>该程序</p></li><li><p>命令行进入<code>路径\msysgit\bin</code>目录，执行<code>rebase.exe -b 0x50000000 msys-1.0.dll</code>即可，正常情况下执行该命令没任何响应，重启cmder或者git即解决</p></li></ol><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><ol><li><code>rebase.exe</code>文件所在路径不固定，可能在<code>路径\msysgit\bin</code>下，也可能在<code>C:\Program Files (x86)\Git\bin</code>下</li><li>在执行<code>rebase</code>之前，需要确保<code>msys-1.0.dll</code>不是运行状态，<br> 查看方法，启动命令行，执行<code>tasklist /m msys-1.0.dll</code></li><li>养成好习惯，在执行rebase之前，先备份：<code>copy msys-1.0.dll msys-1.0.dll.bak</code>，如果执行失败<code>ReBaseImage (msys-1.0.dll) failed with last error = 6</code><br>考虑按以下步骤：</li></ol><ul><li>把dll文件拷贝到其他的目录下</li><li>重新复制生成备份文件</li><li>用副本替换原文件<br>另外，考虑用管理员身份运行</li></ul><p>以上，完~</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote><p><a href="http://jakob.engbloms.se/archives/1403" target="_blank" rel="noopener">初始解决：jakob</a><br><a href="https://stackoverflow.com/questions/18502999/git-extensions-win32-error-487-couldnt-reserve-space-for-cygwins-heap-win32" target="_blank" rel="noopener">stackoverflow问题解决</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记cmder/git一个报错解决&lt;/p&gt;
    
    </summary>
    
      <category term="skill" scheme="http://tokyle.com/categories/skill/"/>
    
    
      <category term="cmder" scheme="http://tokyle.com/tags/cmder/"/>
    
      <category term="git" scheme="http://tokyle.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>网站性能杂货</title>
    <link href="http://tokyle.com/2019/04/08/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%9D%82%E8%B4%A7/"/>
    <id>http://tokyle.com/2019/04/08/网站性能杂货/</id>
    <published>2019-04-08T07:17:59.000Z</published>
    <updated>2019-04-08T07:19:24.084Z</updated>
    
    <content type="html"><![CDATA[<p>页面性能优化参考</p><a id="more"></a><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>很多时候，会打开chrome F12的network栏，查看页面信息，页面底部会有三个时间：<br><code>DOMContentLoaded</code>,<code>Load</code>,<code>Finish</code></p><h4 id="DOMContentLoaded-和-Load"><a href="#DOMContentLoaded-和-Load" class="headerlink" title="DOMContentLoaded 和 Load"></a>DOMContentLoaded 和 Load</h4><p>DOMContentLoaded 和 Load 分别对应 页面 DOMContentLoaded 和 Load 事件触发的时间点，即：</p><p><code>DOMContentLoaded</code>：DOM树构建完成。即HTML页面由上向下解析HTML结构到末尾封闭标签 。</p><p><code>Load</code>:页面加载完毕。 DOM树构建完成后，继续加载html/css 中的图片资源等外部资源，加载完成后视为页面加载完毕。</p><p>DOMContentLoaded 会比 Load 时间小，两者时间差大致等于外部资源加载的时间。</p><h4 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h4><p><code>Finish</code> 时间是页面上所有 http 请求发送到响应完成的时间，HTTP1.0/1.1 协议限定，单个域名的请求并发量是 6 个，即Finish是所有请求（不只是XHR请求，还包括DOC，img，js，css等资源的请求）在并发量为6的限制下完成的时间。</p><h3 id="优化实践"><a href="#优化实践" class="headerlink" title="优化实践"></a>优化实践</h3><h4 id="Make-fewer-HTTP-requests-（最大限度地减少HTTP请求）"><a href="#Make-fewer-HTTP-requests-（最大限度地减少HTTP请求）" class="headerlink" title="Make fewer HTTP requests （最大限度地减少HTTP请求）"></a>Make fewer HTTP requests （最大限度地减少HTTP请求）</h4><p>终端用户响应的时间中，有80%用于下载各项内容。这部分时间包括下载页面中的图像、样式表、脚本、Flash等。通过减少页面中的元素可以减少HTTP请求的次数。这是提高网页速度的关键步骤。<br>     减少页面组件的方法其实就是简化页面设计。那么有没有一种方法既能保持页面内容的丰富性又能达到加快响应时间的目的呢？这里有几条减少HTTP请求次数同时又可能保持页面内容丰富的技术。</p><p>合并文件是通过把所有的脚本放到一个文件中来减少HTTP请求的方法，如可以简单地把所有的CSS文件都放入一个样式表中。当脚本或者样式表在不同页面中使用时需要做不同的修改，这可能会相对麻烦点，但即便如此也要把这个方法作为改善页面性能的重要一步。</p><p>CSS Sprites是减少图像请求的有效方法。把所有的背景图像都放到一个图片文件中，然后通过CSS的background-image和background-position属性来显示图片的不同部分；</p><p>图片地图是把多张图片整合到一张图片中。虽然文件的总体大小不会改变，但是可以减少HTTP请求次数。图片地图只有在图片的所有组成部分在页面中是 紧挨在一起的时候才能使用，如导航栏。确定图片的坐标和可能会比较繁琐且容易出错，同时使用图片地图导航也不具有可读性，因此不推荐这种方法；</p><p>内联图像是使用data:URL scheme的方法把图像数据加载页面中。这可能会增加页面的大小。把内联图像放到样式表（可缓存）中可以减少HTTP请求同时又避免增加页面文件的大小。但是内联图像现在还没有得到主流浏览器的支持。</p><h4 id="Use-a-Content-Delivery-Network-CDN-（使用内容分发网络）"><a href="#Use-a-Content-Delivery-Network-CDN-（使用内容分发网络）" class="headerlink" title="Use a Content Delivery Network (CDN)（使用内容分发网络）"></a>Use a Content Delivery Network (CDN)（使用内容分发网络）</h4><p>用户与你网站服务器的接近程度会影响响应时间的长短。把你的网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。但是首先我们应该做些什么呢？</p><p>按地域布置网站内容的第一步并不是要尝试重新架构你的网站让他们在分发服务器上正常运行。根据应用的需求来改变网站结构，这可能会包括一些比较复杂的任 务，如在服务器间同步Session状态和合并数据库更新等。要想缩短用户和内容服务器的距离，这些架构步骤可能是不可避免的。</p><p>要记住，在终端用户的响应时间中有80%到90%的响应时间用于下载图像、样式表、脚本、Flash等页面内容。这就是网站性能黄金守则。和重新设计你的 应用程序架构这样比较困难的任务相比，首先来分布静态内容会更好一点。这不仅会缩短响应时间，而且对于内容分发网络来说它更容易实现。</p><p>内容分发网络（Content Delivery Network，CDN）是由一系列分散到各个不同地理位置上的Web服务器组成的，它提高了网站内容的传输速度。用于向用户传输内容的服务器主要是根据 和用户在网络上的靠近程度来指定的。例如，拥有最少网络跳数（network hops）和响应速度最快的服务器会被选定。</p><p>一些大型的网络公司拥有自己的CDN，但是使用像Akamai Technologies，Mirror Image Internet， 或者Limelight Networks这样的CDN服务成本却非常高。对于刚刚起步的企业和个人网站来说，可能没有使用CDN的成本预算，但是随着目标用户群的不断扩大和更加 全球化，CDN就是实现快速响应所必需的了。以Yahoo来说，他们转移到CDN上的网站程序静态内容节省了终端用户20%以上的响应时间。使用CDN是 一个只需要相对简单地修改代码实现显著改善网站访问速度的方法。</p><h4 id="Add-Expires-headers添加一个Expires或Cache-Control头"><a href="#Add-Expires-headers添加一个Expires或Cache-Control头" class="headerlink" title="Add Expires headers添加一个Expires或Cache-Control头"></a>Add Expires headers添加一个Expires或Cache-Control头</h4><p>这条守则包括两方面的内容：<br>对于静态内容：设置文件头过期时间Expires的值为“Never expire”（永不过期）<br>对于动态内容：使用恰当的Cache-Control文件头来帮助浏览器进行有条件的请求</p><p>网页内容设计现在越来越丰富，这就意味着页面中要包含更多的脚本、样式表、图片和Flash。第一次访问你页面的用户就意味着进行多次的HTTP请求，但 是通过使用Expires文件头就可以使这样内容具有缓存性。它避免了接下来的页面访问中不必要的HTTP请求。Expires文件头经常用于图像文件， 但是应该在所有的内容都使用他，包括脚本、样式表和Flash等。</p><p>浏览器（和代理）使用缓存来减少HTTP请求的大小和次数以加快页面访问速度。Web服务器在HTTP响应中使用Expires文件头来告诉客户端内容需 要缓存多长时间。</p><h4 id="Compress-components-with-gzip-用gzip的压缩内容"><a href="#Compress-components-with-gzip-用gzip的压缩内容" class="headerlink" title="Compress components with gzip  用gzip的压缩内容"></a>Compress components with gzip  用gzip的压缩内容</h4><p>网络传输中的HTTP请求和应答时间可以通过前端机制得到显著改善。的确，终端用户的带宽、互联网提供者、与对等交换点的靠近程度等都不是网站开发者所能决定的。但是还有其他因素影响着响应时间。通过减小HTTP响应的大小可以节省HTTP响应时间。</p><p>从HTTP/1.1开始，web客户端都默认支持HTTP请求中有Accept-Encoding文件头的压缩格式<br> Accept-Encoding: gzip, deflate</p><p>如果web服务器在请求的文件头中检测到上面的代码，就会以客户端列出的方式压缩响应内容。Web服务器把压缩方式通过响应文件头中的Content-Encoding来返回给浏览器<br> Content-Encoding: gzip</p><p>Gzip是目前最流行也是最有效的压缩方式。这是由GNU项目开发并通过RFC 1952来标准化的。另外仅有的一个压缩格式是deflate，但是它的使用范围有限效果也稍稍逊色。</p><h4 id="Reduce-DNS-lookups（减少DNS查找）"><a href="#Reduce-DNS-lookups（减少DNS查找）" class="headerlink" title="Reduce DNS lookups（减少DNS查找）"></a>Reduce DNS lookups（减少DNS查找）</h4><p>域名系统（DNS）提供了域名和IP的对应关系，就像电话本中人名和他们的电话号码的关系一样。当你在浏览器地址栏中输入www.dudo.org时，DNS解析服务器就会返回这个域名对应的IP地址。DNS解析的过程同样也是需要时间的。一般情况下返回给定域名对应的IP地址会花费20到120毫秒的时间。而且在这个过程中浏览器什么都不会做直到DNS查找完毕。</p><p> 缓存DNS查找可以改善页面性能。这种缓存需要一个特定的缓存服务器，这种服务器一般属于用户的ISP提供商或者本地局域网控制，但是它同样会在用户使用 的计算机上产生缓存。DNS信息会保留在操作系统的DNS缓存中（微软Windows系统中DNS Client Service）。大多数浏览器有独立于操作系统以外的自己的缓存。由于浏览器有自己的缓存记录，因此在一次请求中它不会受到操作系统的影响。</p><p>Internet Explorer默认情况下对DNS查找记录的缓存时间为30分钟，它在注册表中的键值为DnsCacheTimeout。Firefox对DNS的查找 记录缓存时间为1分钟，它在配置文件中的选项为network.dnsCacheExpiration（Fasterfox把这个选项改为了1小时）</p><p>当客户端中的DNS缓存都为空时（浏览器和操作系统都为空），DNS查找的次数和页面中主机名的数量相同。这其中包括页面中URL、图片、脚本文件、样式表、Flash对象等包含的主机名。减少主机名的数量可以减少DNS查找次数。</p><p>减少主机名的数量还可以减少页面中并行下载的数量。减少DNS查找次数可以节省响应时间，但是减少并行下载却会增加响应时间。我的指导原则是把这些页面中 的内容分割成至少两部分但不超过四部分。这种结果就是在减少DNS查找次数和保持较高程度并行下载两者之间的权衡了</p><h4 id="Reduce-the-number-of-DOM-elements（减少DOM元素的数量）"><a href="#Reduce-the-number-of-DOM-elements（减少DOM元素的数量）" class="headerlink" title="Reduce the number of DOM elements（减少DOM元素的数量）"></a>Reduce the number of DOM elements（减少DOM元素的数量）</h4><p>一个复杂的页面意味着需要下载更多数据，同时也意味着JavaScript遍历DOM的效率越慢。比如当你增加一个事件句柄时在500和5000个DOM元素中循环效果肯定是不一样的。</p><p>  大量的DOM元素的存在意味着页面中有可以不用移除内容只需要替换元素标签就可以精简的部分。你在页面布局中使用表格了吗？你有没有仅仅为了布局而引入更多的<div>元素呢？也许会存在一个适合或者在语意是更贴切的标签可以供你使用。</div></p><p>DOM元素数量很容易计算出来，只需要在Firebug的控制台内输入：<br>document.getElementsByTagName(‘*’).length</p><h4 id="Reduce-cookie-size-（减少Cookie的大小）"><a href="#Reduce-cookie-size-（减少Cookie的大小）" class="headerlink" title="Reduce cookie size （减少Cookie的大小）"></a>Reduce cookie size （减少Cookie的大小）</h4><p>HTTP coockie可以用于权限验证和个性化身份等多种用途。coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。因此保持coockie尽可能的小以减少用户的响应时间十分重要。</p><p>有关更多信息可以查看Tenni Theurer和Patty Chi的文章“When the Cookie Crumbles”。这们研究中主要包括：<br>去除不必要的coockie<br>使coockie体积尽量小以减少对用户响应的影响<br>注意在适应级别的域名上设置coockie以便使子域名不受影响<br>设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。</p><h4 id="Use-cookie-free-domains使用无Cookie的域名"><a href="#Use-cookie-free-domains使用无Cookie的域名" class="headerlink" title="Use cookie-free domains使用无Cookie的域名"></a>Use cookie-free domains使用无Cookie的域名</h4><p>当浏览器在请求中同时请求一张静态的图片和发送coockie时，服务器对于这些coockie不会做任何地使用。因此他们只是因为某些负面因素而创建的 网络传输。所有你应该确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容</p><p>如果你的域名是www.example.org，你可以在static.example.org上存在静态内容。但是，如果你不是在www.example.org上 而是在顶级域名example.org设置了coockie，那么所有对于static.example.org的请求都包含coockie。在这种情况 下，你可以再重新购买一个新的域名来存在静态内容，并且要保持这个域名是无coockie的。Yahoo!使用的是ymig.com，YouTube使用 的是ytimg.com，Amazon使用的是images-anazon.com等等。</p><p>使用无coockie域名存在静态内容的另外一个好处就是一些代理（服务器）可能会拒绝对coockie的内容请求进行缓存。一个相关的建议就是，如果你想确定应该使用example.org还是www.example.org作 为你的一主页，你要考虑到coockie带来的影响。忽略掉www会使你除了把coockie设置到<em>.example.org（</em>是泛域名解析，代表了 所有子域名译者dudo注）外没有其它选择，因此出于性能方面的考虑最好是使用带有www的子域名并且在它上面设置coockie。</p><h3 id="…-…"><a href="#…-…" class="headerlink" title="… …"></a>… …</h3><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote><p><a href="http://www.cnblogs.com/jiahaohk/archive/2009/08/29/1556330.html" target="_blank" rel="noopener">加快您的网站的最佳实践（Best Practices for Speeding Up Your Web Site）</a><br><a href="http://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">英文原文</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;页面性能优化参考&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="性能" scheme="http://tokyle.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>伪·influxdb删除数据</title>
    <link href="http://tokyle.com/2019/04/08/%E4%BC%AA%C2%B7influxdb%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/"/>
    <id>http://tokyle.com/2019/04/08/伪·influxdb删除数据/</id>
    <published>2019-04-08T05:34:15.000Z</published>
    <updated>2019-04-08T05:35:07.577Z</updated>
    
    <content type="html"><![CDATA[<p>伪 influxdb删除数据</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大早上的，一大佬跟我说grafan登不上了，让帮忙看看啥情况，登录服务器一通乱看，磁盘满了，因为那台服务器还装了个influxdb，估计也就是数据写的，没空间了。</p><p>influxdb作为时序数据库的一种，是不提供类似mysql的delete操作，也就是，原则上，你删不了数据，除非删库。</p><p>但是，influxdb提供了数据保留策略<code>policies</code>，通过对<code>policies</code>操作，可以达到删除数据的效果</p><h3 id="数据保存策略（Retention-Policies）"><a href="#数据保存策略（Retention-Policies）" class="headerlink" title="数据保存策略（Retention Policies）"></a>数据保存策略（Retention Policies）</h3><p>influxdb的数据保存策略<code>policies</code>主要是用于指定数据的保留时间，超过指定时间，就会删除这部分数据。</p><h4 id="查询策略"><a href="#查询策略" class="headerlink" title="查询策略"></a>查询策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; show retention policies on exceptionless;</span><br><span class="line">name    duration shardGroupDuration replicaN default</span><br><span class="line">----    -------- ------------------ -------- -------</span><br><span class="line">autogen 0s       168h0m0s           1        true</span><br></pre></td></tr></table></figure><ul><li>name: 策略名称</li><li>duration： 保留时间，0s表示永久保存</li><li>shardGroupDuration：shardGroup的存储时间，shardGroup是InfluxDB的一个基本储存结构，个人理解为时间分区</li><li>replicaN：全称是REPLICATION，副本个数</li><li>default：是否是默认策略</li></ul><h4 id="新建策略"><a href="#新建策略" class="headerlink" title="新建策略"></a>新建策略</h4><p>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE RETENTION POLICY ON &lt;retention_policy_name&gt; </span><br><span class="line">ON &lt;database_name&gt; </span><br><span class="line">DURATION &lt;duration&gt; </span><br><span class="line">REPLICATION &lt;n&gt; [SHARD DURATION &lt;duration&gt; ] [DEFAULT]</span><br></pre></td></tr></table></figure></p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE RETENTION POLICY &quot;3_day&quot; ON &quot;exceptionless&quot; DURATION 3d REPLICATION 1 SHARD DURATION 3h DEFAULT;</span><br></pre></td></tr></table></figure><p>为库exceptionless创建了一个名称为3_day的策略，其中数据保存时间为3天，SHARDDURATION为3h。</p><h4 id="ShardGroup"><a href="#ShardGroup" class="headerlink" title="ShardGroup"></a>ShardGroup</h4><p>shardgroup是InfluxDB中一个重要的逻辑概念，它负责指定时间跨度的数据存储，这个时间跨度在创建RP时指定。如果没有指定，系统将通过RP的数据保留时间来计算：</p><table><thead><tr><th>Retention Policy‘s DURATION</th><th>Shard Group Duration</th></tr></thead><tbody><tr><td>&lt; 2days</td><td>1h</td></tr><tr><td>&gt;= 2days and &lt;= 6months</td><td>24h</td></tr><tr><td>&gt; 6months</td><td>168h</td></tr></tbody></table><p>不同shardgroup的时间跨度不会重叠。shardgroup实现了数据按时间分区，这样的设计可以：</p><ol><li>一定程度上缓解数据写入热点问题</li><li>加快数据删除效率(将数据按照时间分割成小的粒度会使得数据过期实现非常简单，InfluxDB中数据过期删除的执行粒度就是Shard Group，系统会对每一个Shard Group判断是否过期，而不是一条一条记录判断。InfluxDB没有提供删除和更新数据的接口，数据只能通过RP进行删除)</li><li>加快数据按时间维度查找的效率(实现了将数据按照时间分区的特性。将时序数据按照时间分区是时序数据库一个非常重要的特性，基本上所有时序数据查询操作都会带有时间的过滤条件，比如查询最近一小时或最近一天，数据分区可以有效根据时间维度选择部分目标分区，淘汰部分分区)</li></ol><h4 id="修改及删除策略"><a href="#修改及删除策略" class="headerlink" title="修改及删除策略"></a>修改及删除策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 修改策略</span><br><span class="line">alter retention policy &quot;autogen&quot; on &quot;exceptionless&quot; duration 72h0m0s default;</span><br><span class="line"></span><br><span class="line"># 删除策略</span><br><span class="line">drop retention POLICY &quot;2_hours&quot; ON &quot;exceptionless&quot;</span><br></pre></td></tr></table></figure><h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><p>说回大佬的问题，连接进influxdb：<code>influx -host ip:port -precision rfc3339</code>之后，查看当前库的存储策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; show retention policies on exceptionless;</span><br><span class="line">name    duration shardGroupDuration replicaN default</span><br><span class="line">----    -------- ------------------ -------- -------</span><br><span class="line">autogen 0s       168h0m0s           1        true</span><br></pre></td></tr></table></figure></p><p>嗯，保存时间是永久。。再新建一个7天的策略，把原策略删除即可。</p><p>以上，完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;伪 influxdb删除数据&lt;/p&gt;
    
    </summary>
    
      <category term="Devops" scheme="http://tokyle.com/categories/Devops/"/>
    
    
      <category term="influxdb" scheme="http://tokyle.com/tags/influxdb/"/>
    
  </entry>
  
  <entry>
    <title>Linux垃圾清理</title>
    <link href="http://tokyle.com/2019/02/27/Linux%E5%9E%83%E5%9C%BE%E6%B8%85%E7%90%86/"/>
    <id>http://tokyle.com/2019/02/27/Linux垃圾清理/</id>
    <published>2019-02-28T02:00:04.000Z</published>
    <updated>2019-02-28T02:01:53.729Z</updated>
    
    <content type="html"><![CDATA[<p>linux垃圾清理</p><a id="more"></a><p>起因是阿里云上面一台很穷的机器，大早上来看了下，搭在那服务器上面的grafana直接就登不上了，登服务器看了下日志，磁盘满了，因为就50G的空间，上面还有个influxdb占了大头，在重新申请扩充磁盘空间之前，只能先看看能删啥了。</p><h3 id="Linux垃圾"><a href="#Linux垃圾" class="headerlink" title="Linux垃圾"></a>Linux垃圾</h3><p>坊间有句话：Linux不像windows，Linux没有垃圾。对这句话，只能笑笑。。</p><p>首先<code>df -h</code>看一下哪个分区满了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@izuf633r5fhkmlfxl47zbkz log]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1        50G   43G  28M  100% /</span><br><span class="line">devtmpfs        3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs           3.9G  500K  3.9G   1% /run</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           783M     0  783M   0% /run/user/1002</span><br></pre></td></tr></table></figure></p><p>可以看到<code>/dev/vda1</code>分区基本已经使用100%了，这个分区是挂载在<code>/</code>目录下，所以，需要清理的也就是<code>/</code>目录下的垃圾。</p><p>进根目录，一层一层的看文件大小并按文件大小倒序排列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br><span class="line"></span><br><span class="line">du -sh * | sort -h</span><br></pre></td></tr></table></figure></p><p>找到最大的文件夹/文件，进入对应的文件夹，一层一层的筛选<br>基本上可以找到<code>/var/log</code>这个文件夹，这个文件夹中有很大的日志文件，尤其是<code>/var/log/messages</code>文件以及<code>/var/log/journal</code>文件夹，这两个都是系统操作日志的记录，尤其是<code>journal</code>文件夹，里面存的大量的日志，这台服务器的日志有4G，需要清理的就是这个文件夹了。</p><h3 id="journalctl"><a href="#journalctl" class="headerlink" title="journalctl"></a>journalctl</h3><p>linux继承unix，也有类似syslog的记录，linux有个journald的日志解决方案，说实话，我对linux底层不是非常了解，所以这个日志系统当前也没多少时间去深究，只能停留在使用上。<br>journald日志系统有个读取日志的工具：<code>journalctl</code>，这个工具应该算是经常用到的一个，经常搭建环境时候出错需要：<code>journalctl -xe</code>查看详细日志</p><p>关于<code>journalctl</code>这个工具的详细介绍这边不说，提供官方地址，不行就直接<code>--help</code></p><blockquote><p><a href="https://www.freedesktop.org/software/systemd/man/journalctl.html" target="_blank" rel="noopener">journalctl各参数详细介绍</a></p></blockquote><p>其中可以找到一个参数：<code>--vacuum-size=, --vacuum-time=, --vacuum-files=</code><br>官方解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Removes the oldest archived journal files until the disk space they use falls below the specified size (specified with the usual &quot;K&quot;, &quot;M&quot;, &quot;G&quot; and &quot;T&quot; suffixes), or all archived journal files contain no data older than the specified timespan (specified with the usual &quot;s&quot;, &quot;m&quot;, &quot;h&quot;, &quot;days&quot;, &quot;months&quot;, &quot;weeks&quot; and &quot;years&quot; suffixes), or no more than the specified number of separate journal files remain. Note that running --vacuum-size= has only an indirect effect on the output shown by --disk-usage, as the latter includes active journal files, while the vacuuming operation only operates on archived journal files. Similarly, --vacuum-files= might not actually reduce the number of journal files to below the specified number, as it will not remove active journal files.</span><br></pre></td></tr></table></figure></p><p>这三个参数，可以帮助我们删除journald的日志</p><p>用法：<br><code>journalctl --vacuum-size=1G</code>  指定日志文件最大占据空间为1G<br><code>journalctl --vacuum-time=1years</code> 指定日志文件保存时间为1年</p><p>更多用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#查看所有日志（默认情况下 ，只保存本次启动的日志）</span><br><span class="line">$ sudo journalctl</span><br><span class="line"></span><br><span class="line">#查看内核日志（不显示应用日志）</span><br><span class="line">$ sudo journalctl -k</span><br><span class="line"></span><br><span class="line">#查看系统本次启动的日志</span><br><span class="line">$ sudo journalctl -b</span><br><span class="line">$ sudo journalctl -b -0</span><br><span class="line"></span><br><span class="line">#查看上一次启动的日志（需更改设置）</span><br><span class="line">$ sudo journalctl -b -1</span><br><span class="line"></span><br><span class="line">#查看指定时间的日志</span><br><span class="line">$ sudo journalctl --since=&quot;2012-10-30 18:17:16&quot;</span><br><span class="line">$ sudo journalctl --since &quot;20 min ago&quot;</span><br><span class="line">$ sudo journalctl --since yesterday</span><br><span class="line">$ sudo journalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;</span><br><span class="line">$ sudo journalctl --since 09:00 --until &quot;1 hour ago&quot;</span><br><span class="line"></span><br><span class="line">#显示尾部的最新10行日志</span><br><span class="line">$ sudo journalctl -n</span><br><span class="line"></span><br><span class="line">#显示尾部指定行数的日志</span><br><span class="line">$ sudo journalctl -n 20</span><br><span class="line"></span><br><span class="line">#实时滚动显示最新日志</span><br><span class="line">$ sudo journalctl -f</span><br><span class="line"></span><br><span class="line">#查看指定服务的日志</span><br><span class="line">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class="line"></span><br><span class="line">#查看指定进程的日志</span><br><span class="line">$ sudo journalctl _PID=1</span><br><span class="line"></span><br><span class="line">#查看某个路径的脚本的日志</span><br><span class="line">$ sudo journalctl /usr/bin/bash</span><br><span class="line"></span><br><span class="line">#查看指定用户的日志</span><br><span class="line">$ sudo journalctl _UID=33 --since today</span><br><span class="line"></span><br><span class="line">#查看某个 Unit 的日志</span><br><span class="line">$ sudo journalctl -u nginx.service</span><br><span class="line">$ sudo journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line">#实时滚动显示某个 Unit 的最新日志</span><br><span class="line">$ sudo journalctl -u nginx.service -f</span><br><span class="line"></span><br><span class="line">#合并显示多个 Unit 的日志</span><br><span class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class="line"></span><br><span class="line">#查看指定优先级（及其以上级别）的日志，共有8级</span><br><span class="line"># 0: emerg</span><br><span class="line"># 1: alert</span><br><span class="line"># 2: crit</span><br><span class="line"># 3: err</span><br><span class="line"># 4: warning</span><br><span class="line"># 5: notice</span><br><span class="line"># 6: info</span><br><span class="line"># 7: debug</span><br><span class="line">$ sudo journalctl -p err -b</span><br><span class="line"></span><br><span class="line">#日志默认分页输出，--no-pager 改为正常的标准输出</span><br><span class="line">$ sudo journalctl --no-pager</span><br><span class="line"></span><br><span class="line">#以 JSON 格式（单行）输出</span><br><span class="line">$ sudo journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line">#以 JSON 格式（多行）输出，可读性更好</span><br><span class="line">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class="line"> -o json-pretty</span><br><span class="line"></span><br><span class="line">#显示日志占据的硬盘空间</span><br><span class="line">$ sudo journalctl --disk-usage</span><br><span class="line"></span><br><span class="line">#指定日志文件占据的最大空间</span><br><span class="line">$ sudo journalctl --vacuum-size=1G</span><br><span class="line"></span><br><span class="line">#指定日志文件保存多久</span><br><span class="line">$ sudo journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure></p><p>附上一篇关于<code>systemd</code>命令介绍的博客：</p><blockquote><p><a href="https://www.linuxprobe.com/systemd-command.html" target="_blank" rel="noopener">systemd命令</a></p></blockquote><p>完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux垃圾清理&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://tokyle.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="journalctl" scheme="http://tokyle.com/tags/journalctl/"/>
    
      <category term="systemd" scheme="http://tokyle.com/tags/systemd/"/>
    
  </entry>
  
  <entry>
    <title>Centos7安装pip3</title>
    <link href="http://tokyle.com/2019/01/29/Centos7%E5%AE%89%E8%A3%85pip3/"/>
    <id>http://tokyle.com/2019/01/29/Centos7安装pip3/</id>
    <published>2019-01-30T01:58:33.000Z</published>
    <updated>2019-01-30T01:59:22.984Z</updated>
    
    <content type="html"><![CDATA[<p>centos7安装pip3</p><a id="more"></a><p>当前基本拿到手的centos安装的可能都是python2.7，对应的pip版本也很低，很多后面的工具包都安装不了，所以，需要安装个pip3</p><blockquote><p><a href="http://tokyle.com/2018/04/20/Centos%E4%B8%8B%E5%8D%87%E7%BA%A7python2-7%E5%88%B03-6/">python2.7和python3共存</a></p></blockquote><p>安装完python3之后，就可以安装pip</p><h3 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">wget --no-check-certificate  https://pypi.python.org/packages/source/p/pip/pip-8.0.2.tar.gz#md5=3a73c4188f8dbad6a1e6f6d44d117eeb</span><br><span class="line"></span><br><span class="line">tar -zxvf pip-8.0.2.tar.gz</span><br><span class="line"></span><br><span class="line">mv pip-8.0.2  /usr/local/pip3</span><br><span class="line"></span><br><span class="line">cd  /usr/local/pip3</span><br><span class="line"></span><br><span class="line">python3 setup.py build</span><br><span class="line"></span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure><p>测试：<code>pip3 install xmind</code></p><p>需要注意的是的，当前安装的pip3不是最新版本，需要升级：<code>pip3 install --upgrade pip</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;centos7安装pip3&lt;/p&gt;
    
    </summary>
    
      <category term="skill" scheme="http://tokyle.com/categories/skill/"/>
    
    
      <category term="Centos7" scheme="http://tokyle.com/tags/Centos7/"/>
    
      <category term="pip3" scheme="http://tokyle.com/tags/pip3/"/>
    
  </entry>
  
  <entry>
    <title>2019年关将至有感</title>
    <link href="http://tokyle.com/2019/01/24/2019%E5%B9%B4%E5%85%B3%E5%B0%86%E8%87%B3%E6%9C%89%E6%84%9F/"/>
    <id>http://tokyle.com/2019/01/24/2019年关将至有感/</id>
    <published>2019-01-25T00:53:07.000Z</published>
    <updated>2019-01-25T00:55:03.239Z</updated>
    
    <content type="html"><![CDATA[<p>2019农历年来临之际有感</p><a id="more"></a><p>年关将近，发发牢骚…<br>近几天“百度已死”的文章铺天盖地，随之而来的很多分析互联网的文章出现，年末了，也扯扯自己感受。最大的感触就是“中国互联网”的确是不再互联。曾经还在百度搜音乐，搜商品..而今，基本都是对应网站（网易云，淘宝）直接搜索。可能也有近几年百度搜索结果太烂的原因，然后呢，不是很关注这行的可能不怎么知道，当前国内互联网，巨头分地，彼此吃像都不怎么样，说到底都是数据，隐私，流量，具体点就是钱。</p><p>微信公众号的内容，普通搜索引擎的爬虫无法收录；<br>淘宝为代表的网购平台, 长时间的封杀搜索引擎爬虫（结果就是搜商品只能淘宝、京东站内搜索）；<br>app之间互转越来越困难（抖音转微信等）<br>加上前段时间的马桶MT，聊天宝，多闪被微信封杀…<br>巨头圈地，彼此不互联貌似已经越来越具象；相比之下，国外谷歌搜索结果仍然可以直连亚马逊…无话可说..</p><p>最后，还是扯到搜索上，当前百度基本我是放弃了，必应最近日子也不好过；最最推荐的方式，就是有能力就买台服务器，自己搭个梯子吧，万里长城永不倒啊（直接买VPN不怎么推荐，有点手段的能把你祖宗辈信息都截到）；科学上网做不到，推荐几个小众的搜索网站：</p><p>无隐私搜索（chrome有插件，地址栏直接输搜索项，实测非常干净）：<br><code>https://www.duckduckgo.com/</code></p><p>类似网站查询网站，可查用户覆盖率和用户标签，其他功能自行体会（有chrome插件）：<br><code>https://www.similarweb.com/</code></p><p>在线问答系统（类似百科）：<br><code>https://www.wolframalpha.com/</code></p><p>（以上网站可能都需要至少科学上网一次装完插件..所以，还是赶紧会科学上网现实，直接Google多方便）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019农历年来临之际有感&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://tokyle.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>jmeter吞吐量几个插件介绍</title>
    <link href="http://tokyle.com/2019/01/18/jmeter%E5%90%9E%E5%90%90%E9%87%8F%E5%87%A0%E4%B8%AA%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>http://tokyle.com/2019/01/18/jmeter吞吐量几个插件介绍/</id>
    <published>2019-01-18T06:50:55.000Z</published>
    <updated>2019-01-18T06:51:35.380Z</updated>
    
    <content type="html"><![CDATA[<p>几个jmeter吞吐量相关插件</p><a id="more"></a><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>测试接口：获取系统时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://192.168.0.1:8080/api/v1/Other/GetServiceTime</span><br></pre></td></tr></table></figure></p><p>jmeter脚本结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 线程组</span><br><span class="line">-- HTTP信息头管理器</span><br><span class="line">    -- Throughput Controller 1</span><br><span class="line">    -- GetService Time 1</span><br><span class="line">    -- Throughput Controller 2</span><br><span class="line">    -- GetService Time 2</span><br><span class="line">    -- 查看结果树</span><br></pre></td></tr></table></figure></p><h3 id="吞吐量控制器（Throughput-Controller）"><a href="#吞吐量控制器（Throughput-Controller）" class="headerlink" title="吞吐量控制器（Throughput Controller）"></a>吞吐量控制器（Throughput Controller）</h3><p>这个组件，其实按照我们的理解，不应该翻译成吞吐量控制器，这个组件的作用是控制子节点执行频率，有两个控制方式：</p><ol><li>Total Executions(执行总次数):控制执行次数</li><li>Percent Executions(执行百分比)：执行设置的测试计划的总测试次数的百分比</li></ol><ul><li>测试计划总测试次数在线程组处设置，总次数=（Number of Threaders(users) * Loop Count）</li></ul><p>这两个很好理解，选择模式为总次数，设置几次，就执行几次；选模式为百分比，执行次数就是总次数的百分之n</p><p>这个组件，还有个<code>per user</code>选项</p><ul><li><p>勾选：会按照每个线程单独计算吞吐量，如线程组设置了5个线程，循环次数为2的情况，吞吐量为1时，吞吐量的子节点每个线程执行一次，总共会执行5次。</p></li><li><p>不勾选：按照全局的执行数次进行计数，如线程组设置了5个线程，循环次数为2的情况，吞吐量为1时，吞吐量的子节点仅会执行一次。</p></li></ul><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>线程组：5个线程，循环次数2次（测试计划总次数为10）</p><ol><li><p>没有 Throughput Controller 这个组件，直接执行，在查看结果树种会有<strong>10</strong>条记录；</p></li><li><p>有Throughput Controller，模式选择Total Executions，Throughput设置为1，不勾选<code>Per User</code>，点击执行，查看结果树会有<strong>1</strong>条记录；（设置的throughput）</p></li><li><p>有Throughput Controller，模式选择Total Executions，Throughput设置为1，<strong>勾选</strong><code>Per User</code>，点击执行，查看结果树会有<strong>5</strong>条记录；（线程数*设置的throughput）</p></li><li><p>有Throughput Controller，模式选择Percent Executions，Throughput设置为40，不勾选<code>Per User</code>，点击执行，查看结果树会有<strong>4</strong>条记录；（设置的throughput% * 总次数）</p></li><li><p>有Throughput Controller，模式选择Percent Executions，Throughput设置为40，<strong>勾选</strong><code>Per User</code>，点击执行，查看结果树会有<strong>5</strong>条记录；（一个用户的吞吐量（1<em>循环次数）</em>设置的throurhput%，四舍五入之后，相加 ）（注意会有四舍五入，所以，当百分比设置为20%时候，一个用户的吞吐量的20%就是 1<em>2</em>20%，直接四舍五入成了0，最后在查看结果树，就看不见执行记录）</p></li></ol><h3 id="Constant-Timer"><a href="#Constant-Timer" class="headerlink" title="Constant Timer"></a>Constant Timer</h3><p>这个就可以理解为  思考时间（thinktime），单位是毫秒</p><p><strong>作用域为当前线程组</strong></p><h4 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h4><p>jmeter测试脚本层级：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 线程组</span><br><span class="line">-- HTTP信息头管理器</span><br><span class="line">    -- GetServiceTim1-$&#123;__time(YMDHMS,)&#125;</span><br><span class="line">    -- Constant Timer（3000 ms）</span><br><span class="line">    -- GetServiceTim2-$&#123;__time(YMDHMS,)&#125;</span><br><span class="line">    -- GetServiceTim3-$&#123;__time(YMDHMS,)&#125;</span><br><span class="line">    -- GetServiceTim4-$&#123;__time(YMDHMS,)&#125;</span><br><span class="line">    -- 查看结果树</span><br></pre></td></tr></table></figure></p><p>点击执行，在点击执行后3s，GetServiceTim1开始执行，再过3s，GetServiceTim2执行，以此类推</p><h3 id="Constant-Throughput-Timer（固定QPS）"><a href="#Constant-Throughput-Timer（固定QPS）" class="headerlink" title="Constant Throughput Timer（固定QPS）"></a>Constant Throughput Timer（固定QPS）</h3><p>这个组件就是给需要特定QPS的场景，组件里有两个菜单：<br>Target throughput(in samples per minute)：目标QPS，单位是分钟，1200/min -&gt; 20/s<br>Calculate Throughput based on：计算基准，有五种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">This thread only ：分别控制每个线程的吞吐量，选择这种模式时，总的吞吐量为设置的 target Throughput 乘以线程的数量</span><br><span class="line"></span><br><span class="line">All active threads ： 设置的target Throughput 将分配在每个活跃线程上，每个活跃线程在上一次运行结束后等待合理的时间后再次运行。活跃线程指同一时刻同时运行的线程。</span><br><span class="line"></span><br><span class="line">All active threads in current thread group ：设置的target Throughput将分配在当前线程组的每一个活跃线程上，当测试计划中只有一个线程组时，该选项和All active threads选项的效果完全相同。</span><br><span class="line"></span><br><span class="line">All active threads （shared ）：与All active threads 的选项基本相同，唯一的区别是，每个活跃线程都会在所有活跃线程上一次运行结束后等待合理的时间后再次运行。</span><br><span class="line"></span><br><span class="line">All cative threads in current thread group （shared ）：与All active threads in current thread group 基本相同，唯一的区别是，每个活跃线程都会在所有活跃线程的上一次运行结束后等待合理的时间后再次运行。</span><br></pre></td></tr></table></figure></p><h4 id="实验-2"><a href="#实验-2" class="headerlink" title="实验"></a>实验</h4><p>线程数设置为10，循环次数：永远，持续时间90s<br>jmeter 脚本层级结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 线程组</span><br><span class="line">-- HTTP信息头管理器</span><br><span class="line">    -- Constant Throughput Timer</span><br><span class="line">    -- GetServiceTime接口</span><br><span class="line">    -- 查看结果树</span><br><span class="line">    -- 聚合报告</span><br><span class="line">    -- jp@gc - Transactions per Second</span><br></pre></td></tr></table></figure></p><ol><li><p>target throughput设置：1200/m（20/s），模式选择：this thread only，点击执行，当前QPS为 <code>20*10（线程数）=200/s</code></p></li><li><p>target throughput设置：1200/m（20/s），模式选择: All active threads，点击执行，当前QPS为 <code>20/s</code><br>(All active threads （shared ）和All cative threads in current thread group （shared ）没怎么实验，感觉至少没怎么用到。。。主要是懒。。)</p></li></ol><p>完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个jmeter吞吐量相关插件&lt;/p&gt;
    
    </summary>
    
    
      <category term="jmeter" scheme="http://tokyle.com/tags/jmeter/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter压测关联接口</title>
    <link href="http://tokyle.com/2019/01/16/Jmeter%E5%8E%8B%E6%B5%8B%E5%85%B3%E8%81%94%E6%8E%A5%E5%8F%A3/"/>
    <id>http://tokyle.com/2019/01/16/Jmeter压测关联接口/</id>
    <published>2019-01-17T04:15:43.000Z</published>
    <updated>2019-01-17T04:19:13.370Z</updated>
    
    <content type="html"><![CDATA[<p>jmeter关联接口性能测试</p><a id="more"></a><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>进行接口性能测试时候，尤其是登录类接口，经常需要先进行登录，然后拿到登录返回的token，比如sessionid，来作为参数传给下一个接口作为入参</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>测试接口：<br>登录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST http://192.168.0.1:8080/api/Login</span><br><span class="line"></span><br><span class="line">POST data:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mobileId&quot;:&quot;ad9ec085&quot;,</span><br><span class="line">    &quot;loginUrl&quot;:&quot;P00019452&quot;,</span><br><span class="line">    &quot;simId&quot;:&quot;|&quot;,</span><br><span class="line">    &quot;phoneModel&quot;:&quot;vivo vivo X6SPlus D&quot;,</span><br><span class="line">    &quot;phoneSysVersion&quot;:&quot;5.1.1&quot;,</span><br><span class="line">    &quot;appVersion&quot;:&quot;4.2.0&quot;,</span><br><span class="line">    &quot;language&quot;:&quot;ZH-CN&quot;,</span><br><span class="line">    &quot;isClearGesturePwd&quot;:0,</span><br><span class="line">    &quot;companyCode&quot;:&quot;test&quot;,</span><br><span class="line">    &quot;registrationId&quot;:&quot;120c83f7601a92735ae&quot;,</span><br><span class="line">    &quot;isAutoLogin&quot;:&quot;0&quot;,</span><br><span class="line">    &quot;sign&quot;:&quot;a8a922d705c15686232d963e3ce9461aa96df4689420e5abab76535c00532417&quot;,</span><br><span class="line">    &quot;timeStamp&quot;:&quot;20181029101835&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口返回信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;result&quot;:true,</span><br><span class="line">    &quot;data&quot;:&#123;</span><br><span class="line">        &quot;sysPara&quot;:&#123;</span><br><span class="line">            &quot;CancelAttachmentAmount&quot;:&quot;0&quot;,</span><br><span class="line">            &quot;CustomerIsVisible&quot;:&quot;N&quot;,</span><br><span class="line">            &quot;ExceptionAttachmentAmount&quot;:&quot;0&quot;,</span><br><span class="line">            &quot;IsAllowRevoke&quot;:&quot;N&quot;,</span><br><span class="line">            &quot;IsNeedApproveComment&quot;:&quot;N&quot;,</span><br><span class="line">            &quot;IsNeedOTReason&quot;:&quot;N&quot;,</span><br><span class="line">            &quot;IsNeedRejectComment&quot;:&quot;Y&quot;,</span><br><span class="line">            &quot;IsShowOTType&quot;:&quot;1&quot;,</span><br><span class="line">            &quot;LeaveAttachmentAmount&quot;:&quot;2&quot;,</span><br><span class="line">            &quot;OTAttachmentAmount&quot;:&quot;0&quot;,</span><br><span class="line">            &quot;OTDayTypeIsVisible&quot;:&quot;N&quot;,</span><br><span class="line">            &quot;ShiftAttachmentAmount&quot;:&quot;0&quot;,</span><br><span class="line">            &quot;isNeedOTExplain&quot;:&quot;1&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;userInfo&quot;:&#123;</span><br><span class="line">            &quot;BackGroundVersion&quot;:&quot;Y1&quot;,</span><br><span class="line">            &quot;GesturePwd&quot;:&quot;&quot;,</span><br><span class="line">            &quot;IsValid&quot;:true,</span><br><span class="line">            &quot;LoginName&quot;:&quot;P00019452&quot;,</span><br><span class="line">            &quot;ModuleList&quot;:Array[9],</span><br><span class="line">            &quot;PersonID&quot;:&quot;www-2f7f-4203-23212-5cc00acbcd0a&quot;,</span><br><span class="line">            &quot;ServiceTime&quot;:&quot;11:37&quot;,</span><br><span class="line">            &quot;SessionId&quot;:&quot;19431489-f4df-4143-b254-15b2f74f449a,a13b648f-6d81-4307-8ee1-b04c5b976246&quot;,</span><br><span class="line">            &quot;TimeClassE&quot;:&quot;&quot;,</span><br><span class="line">            &quot;TimeClassS&quot;:&quot;&quot;,</span><br><span class="line">            &quot;UserID&quot;:&quot;112dcs-6d81-ewew-8ee1-b04c5b976246&quot;,</span><br><span class="line">            &quot;Uuid&quot;:&quot;darcc75332-A4E2-4FB1-AFCF-C6EB07647825&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;user&quot;:&#123;</span><br><span class="line">            &quot;BirthDay&quot;:&quot;&quot;,</span><br><span class="line">            &quot;CompanyEngName&quot;:&quot;&quot;,</span><br><span class="line">            &quot;CompanyName&quot;:&quot;&quot;,</span><br><span class="line">            &quot;DeptId&quot;:&quot;0&quot;,</span><br><span class="line">            &quot;DeptName&quot;:&quot;测试部&quot;,</span><br><span class="line">            &quot;EmpID&quot;:&quot;P00019452&quot;,</span><br><span class="line">            &quot;EmpName&quot;:&quot;虚拟主管&quot;,</span><br><span class="line">            &quot;EnglishName&quot;:&quot;&quot;,</span><br><span class="line">            &quot;Gender&quot;:&quot;&quot;,</span><br><span class="line">            &quot;HeadImgUrl&quot;:&quot;&quot;,</span><br><span class="line">            &quot;LoginName&quot;:&quot;P00019452&quot;,</span><br><span class="line">            &quot;Position&quot;:&quot;测试总经理&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取用户信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.0.1:8080/api/History/GetUserInfo?sessionId=7f959f6d-4b63-4d2d-8f88-025dc80e40f9,a13b648f-6d81-4307-8ee1-b04c5b976246</span><br></pre></td></tr></table></figure></p><p>其中获取用户信息接口，需要传<code>sessionId</code>字段，该字段为登录接口的返回字段</p><p>所以需要先登录，再获取sessionid，再传给获取用户信息接口</p><h4 id="jmeter实现"><a href="#jmeter实现" class="headerlink" title="jmeter实现"></a>jmeter实现</h4><p>jmeter也是正常的创建线程组，添加http请求头，添加http请求，添加响应断言，添加查看结果树和聚合报告</p><p>不同的是，在一个线程组中会有两个接口，第一个是登录，第二个是获取用户信息，并且在登录接口后需要添加一个组件：<code>JSON Extractor</code>作用就是提取登录返回的sessionid</p><p>JSON Extractor内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name of created variables:  变量名（后面参数化的变量名称，这边是sessionid）</span><br><span class="line"></span><br><span class="line">JSON Path expressions:  json提取表达式</span><br></pre></td></tr></table></figure></p><p>根据登录接口返回的层级结构，json表达式可以写成：<code>$.data.userInfo.SessionId</code><br>需要注意的是$后有一个.，表示当前路径</p><p>JSON表达式可以实现，只需要在登录接口后添加一个查看结果树，显示模式切换成<code>JSON Path Tester</code>，右下角就有<code>JSON Path Expression</code>测试</p><p>jmeter关联接口的层级结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- 线程组</span><br><span class="line">  - - CSV数据文件设置</span><br><span class="line">  - - HTTP信息头管理器</span><br><span class="line">  - - 登录接口（http请求）</span><br><span class="line">    - - 查看结果树</span><br><span class="line">    - - 响应断言</span><br><span class="line">    - - JSON Extractor</span><br><span class="line">  - - 获取用户信息接口</span><br><span class="line">  - - 响应断言</span><br><span class="line">  - - 查看结果树</span><br><span class="line">  - - 聚合报告</span><br></pre></td></tr></table></figure></p><p>完~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jmeter关联接口性能测试&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="jmeter" scheme="http://tokyle.com/tags/jmeter/"/>
    
  </entry>
  
</feed>
